<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/keybase/kbpgp"

    >kbpgp (v2.0.69)</a>
</h1>
<h4>Keybase's PGP Implementation</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp">module kbpgp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP">
            function <span class="apidocSignatureSpan">kbpgp.</span>ASP
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer">
            function <span class="apidocSignatureSpan">kbpgp.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner">
            function <span class="apidocSignatureSpan">kbpgp.</span>Burner
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyFetcher">
            function <span class="apidocSignatureSpan">kbpgp.</span>KeyFetcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyRing">
            function <span class="apidocSignatureSpan">kbpgp.</span>KeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing">
            function <span class="apidocSignatureSpan">kbpgp.</span>PgpKeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine">
            function <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message">
            function <span class="apidocSignatureSpan">kbpgp.</span>armor.Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.prototype.Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.prototype.Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.prototype.Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger">
            function <span class="apidocSignatureSpan">kbpgp.</span>bn.BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.box">
            function <span class="apidocSignatureSpan">kbpgp.</span>box
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burn">
            function <span class="apidocSignatureSpan">kbpgp.</span>burn
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign">
            function <span class="apidocSignatureSpan">kbpgp.</span>clearsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.detachsign">
            function <span class="apidocSignatureSpan">kbpgp.</span>detachsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.prototype.Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.prototype.Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.prototype.Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.prototype.Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.RevokedKeyError">
            function <span class="apidocSignatureSpan">kbpgp.</span>errors.RevokedKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.WrongSigningKeyError">
            function <span class="apidocSignatureSpan">kbpgp.</span>errors.WrongSigningKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.MD5
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.RIPEMD160
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA1
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA224
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA256
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA384
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512">
            function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA512
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager">
            function <span class="apidocSignatureSpan">kbpgp.</span>kb.EncKeyManager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.</span>kb.KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.make_simple_literals">
            function <span class="apidocSignatureSpan">kbpgp.</span>make_simple_literals
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial">
            function <span class="apidocSignatureSpan">kbpgp.</span>opkts.KeyMaterial
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature">
            function <span class="apidocSignatureSpan">kbpgp.</span>opkts.Signature
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID">
            function <span class="apidocSignatureSpan">kbpgp.</span>opkts.UserID
            <span class="apidocSignatureSpan">(userid, components)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock">
            function <span class="apidocSignatureSpan">kbpgp.</span>processor.KeyBlock
            <span class="apidocSignatureSpan">(packets, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message">
            function <span class="apidocSignatureSpan">kbpgp.</span>processor.Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Base
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Decryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Encryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC
            <span class="apidocSignatureSpan">(key, klass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC_SHA256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray">
            function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.WordArray
            <span class="apidocSignatureSpan">(words, sigBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.unbox">
            function <span class="apidocSignatureSpan">kbpgp.</span>unbox
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.Warnings">
            function <span class="apidocSignatureSpan">kbpgp.</span>util.Warnings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ASP.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>Buffer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>Burner.__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>Burner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>KeyFetcher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>KeyManager.__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>KeyManager.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>PgpKeyRing.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine.__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>armor.Message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>base32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>base58</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>base91</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>baseburner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>basekeypair</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>bn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>bn.BigInteger.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>burner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>cast5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>cfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>const</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>dh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>dsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.Priv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.Pub.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.curves</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.curves.Curve.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecc.curves.Curve25519.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecdh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ecdsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>eddsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>elgamal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>elgamalse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>encode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>errors.RevokedKeyError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>errors.WrongSigningKeyError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.MD5.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.RIPEMD160.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA1.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA224.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA256.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA384.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA512.klass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hash.streamers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>hilev</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>kb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>kb.EncKeyManager.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>kb.KeyManager.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>keyfetch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>keymanager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>keyring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>keywrapper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>kmi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>main</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>nacl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ocfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>opkts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>opkts.KeyMaterial.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>opkts.Signature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>opkts.UserID.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>pad</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>primegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>processor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>processor.KeyBlock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>processor.Message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>rand</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>rfc3394</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>rsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>s2k</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>sigeng</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>symmetric</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Base.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Decryptor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Encryptor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC_SHA256.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.WordArray.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.ciphers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.ciphers.AES.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.ciphers.Salsa20.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.ciphers.TwoFish.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.hash.SHA3.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.hmac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.prng</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.prng.PRNG.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>triplesec.util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>ukm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>util.Warnings.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>util.base64u</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.</span>verifier</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ASP">module kbpgp.ASP</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.ASP">
            function <span class="apidocSignatureSpan">kbpgp.</span>ASP
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.make">
            function <span class="apidocSignatureSpan">kbpgp.ASP.</span>make
            <span class="apidocSignatureSpan">(asp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ASP.prototype">module kbpgp.ASP.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.prototype.canceler">
            function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>canceler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.prototype.delay">
            function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>delay
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.prototype.progress">
            function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>progress
            <span class="apidocSignatureSpan">(o, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.prototype.progress_hook">
            function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>progress_hook
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ASP.prototype.section">
            function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>section
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.Buffer">module kbpgp.Buffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.Buffer">
            function <span class="apidocSignatureSpan">kbpgp.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.alloc">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>alloc
            <span class="apidocSignatureSpan">(size, fill, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.allocUnsafe">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>allocUnsafe
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.allocUnsafeSlow">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>allocUnsafeSlow
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.byteLength">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>byteLength
            <span class="apidocSignatureSpan">(string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.compare">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.concat">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>concat
            <span class="apidocSignatureSpan">(list, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.from">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>from
            <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.isBuffer">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>isBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.isEncoding">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>isEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.Buffer.</span>poolSize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.Buffer.prototype">module kbpgp.Buffer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.asciiSlice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>asciiSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.asciiWrite">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>asciiWrite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.base64Slice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>base64Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.base64Write">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>base64Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.compare">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>compare
            <span class="apidocSignatureSpan">(target, start, end, thisStart, thisEnd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.copy">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.equals">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>equals
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.fill">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>fill
            <span class="apidocSignatureSpan">(val, start, end, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.hexSlice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>hexSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.hexWrite">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>hexWrite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.includes">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>includes
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.indexOf">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.inspect">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.latin1Slice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>latin1Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.latin1Write">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>latin1Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readDoubleBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readDoubleBE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readDoubleLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readDoubleLE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readFloatBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readFloatBE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readFloatLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readFloatLE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readInt16BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt16BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readInt16LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt16LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readInt32BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt32BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readInt32LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt32LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readInt8">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt8
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readIntBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readIntBE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readIntLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readIntLE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUInt16BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt16BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUInt16LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt16LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUInt32BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt32BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUInt32LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt32LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUInt8">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt8
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUIntBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUIntBE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.readUIntLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUIntLE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.slice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>slice
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.swap16">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.swap32">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.swap64">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.toJSON">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.toString">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.ucs2Slice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>ucs2Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.ucs2Write">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>ucs2Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.utf8Slice">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>utf8Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.utf8Write">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>utf8Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.write">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>write
            <span class="apidocSignatureSpan">(string, offset, length, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeDoubleBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeDoubleBE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeDoubleLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeDoubleLE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeFloatBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeFloatBE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeFloatLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeFloatLE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeInt16BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt16BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeInt16LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt16LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeInt32BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt32BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeInt32LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt32LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeInt8">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt8
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeIntBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeIntBE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeIntLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeIntLE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt16BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt16BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt16LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt16LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt32BE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt32BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt32LE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt32LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt8">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt8
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUIntBE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUIntBE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Buffer.prototype.writeUIntLE">
            function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUIntLE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.Burner">module kbpgp.Burner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.Burner">
            function <span class="apidocSignatureSpan">kbpgp.</span>Burner
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.Burner.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.Burner.__super__">module kbpgp.Burner.__super__</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.__super__._assert_one">
            function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_assert_one
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.__super__._find_encryption_key">
            function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_encryption_key
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.__super__._find_keys">
            function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_keys
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.__super__._find_signing_key">
            function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_signing_key
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.Burner.prototype">module kbpgp.Burner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._compress">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_compress
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._encrypt">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._encrypt_payload">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_payload
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._encrypt_session_key">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_session_key
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._encrypt_session_key_once">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_session_key_once
            <span class="apidocSignatureSpan">(encryption_key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._frame_literals">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_frame_literals
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._make_session_key">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_make_session_key
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype._sign">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_sign
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype.burn">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>burn
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype.collect_packets">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>collect_packets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.Burner.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.KeyFetcher">module kbpgp.KeyFetcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyFetcher.KeyFetcher">
            function <span class="apidocSignatureSpan">kbpgp.</span>KeyFetcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.KeyFetcher.prototype">module kbpgp.KeyFetcher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyFetcher.prototype.fetch">
            function <span class="apidocSignatureSpan">kbpgp.KeyFetcher.prototype.</span>fetch
            <span class="apidocSignatureSpan">(ids, ops, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.KeyManager">module kbpgp.KeyManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager._wrap_pgp">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>_wrap_pgp
            <span class="apidocSignatureSpan">(klass, kmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.generate">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.generate_ecc">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate_ecc
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.generate_rsa">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate_rsa
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.import_from_armored_pgp">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_armored_pgp
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.import_from_p3skb">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_p3skb
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.import_from_pgp_message">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_pgp_message
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.KeyManager.__super__">module kbpgp.KeyManager.__super__</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.can_decrypt">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_decrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.can_verify">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_verify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.check_public_eq">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>check_public_eq
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.constructor">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.export_pgp_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_pgp_private
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.export_pgp_public">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_pgp_public
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.export_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.export_public">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_ids">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_all_pgp_key_ids
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_materials">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_all_pgp_key_materials
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_ekid">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_ekid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_fp2">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_fp2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_fp2_formatted">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_fp2_formatted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_pgp_fingerprint">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_pgp_fingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_primary_keypair">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_primary_keypair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_type">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_userids">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_userids
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.get_userids_mark_primary">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_userids_mark_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.make_sig_eng">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>make_sig_eng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.__super__.pgp_full_hash">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>pgp_full_hash
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.KeyManager.prototype">module kbpgp.KeyManager.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype._apply_to_engines">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>_apply_to_engines
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype._assert_signed">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>_assert_signed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.can_decrypt">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_decrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.can_verify">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_verify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.check_pgp_public_eq">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>check_pgp_public_eq
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.check_pgp_validity">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>check_pgp_validity
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.clear_pgp_internal_sigs">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>clear_pgp_internal_sigs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_keys_to_keyring">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_keys_to_keyring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private_to_client">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_private_to_client
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_public">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_private_to_server">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_private_to_server
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.export_public">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.fetch">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>fetch
            <span class="apidocSignatureSpan">(key_ids, flags, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_best_pgp_key">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_best_pgp_key
            <span class="apidocSignatureSpan">(flags, need_priv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_crypt_pgp_key">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_crypt_pgp_key
            <span class="apidocSignatureSpan">(need_priv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_pgp_key
            <span class="apidocSignatureSpan">(key_id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key_material">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_pgp_key_material
            <span class="apidocSignatureSpan">(key_id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_signing_pgp_key">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_signing_pgp_key
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.find_verifying_pgp_key">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_verifying_pgp_key
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_ids">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_all_pgp_key_ids
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_materials">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_all_pgp_key_materials
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_ekid">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_ekid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_ekid_b64_str">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_ekid_b64_str
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_fp2">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_fp2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_fp2_formatted">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_fp2_formatted
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_fingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint_str">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_fingerprint_str
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_key_id">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_short_key_id">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_short_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_primary_keypair">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_primary_keypair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_userids">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_userids
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.get_userids_mark_primary">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_userids_mark_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.has_keybase_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_keybase_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.has_p3skb_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_p3skb_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.has_pgp_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_pgp_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.is_keybase_locked">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_keybase_locked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.is_p3skb_locked">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_p3skb_locked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.is_pgp_locked">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_pgp_locked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.make_sig_eng">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>make_sig_eng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.merge_all_subkeys_omitting_revokes">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_all_subkeys_omitting_revokes
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.merge_everything">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_everything
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.merge_pgp_private">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_pgp_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.merge_public_omitting_revokes">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_public_omitting_revokes
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.merge_userids">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_userids
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.pgp_check_not_expired">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>pgp_check_not_expired
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.pgp_full_hash">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>pgp_full_hash
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.set_enc">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>set_enc
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>sign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.sign_pgp">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>sign_pgp
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.simple_unlock">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>simple_unlock
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_keybase">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_keybase
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_p3skb">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_p3skb
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_pgp">
            function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_pgp
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.PgpKeyRing">module kbpgp.PgpKeyRing</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.PgpKeyRing">
            function <span class="apidocSignatureSpan">kbpgp.</span>PgpKeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.PgpKeyRing.prototype">module kbpgp.PgpKeyRing.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.prototype.add_key_manager">
            function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>add_key_manager
            <span class="apidocSignatureSpan">(km)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.prototype.fetch">
            function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>fetch
            <span class="apidocSignatureSpan">(key_ids, ops, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.prototype.find_best_key">
            function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>find_best_key
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.PgpKeyRing.prototype.lookup">
            function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>lookup
            <span class="apidocSignatureSpan">(key_id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.SignatureEngine">module kbpgp.SignatureEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.SignatureEngine">
            function <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.SignatureEngine.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.SignatureEngine.__super__">module kbpgp.SignatureEngine.__super__</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.box">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>box
            <span class="apidocSignatureSpan">(msg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_body">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_body
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_body_and_unverified_payload">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_body_and_unverified_payload
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_km">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_km
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_unverified_payload_from_raw_sig_body">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_unverified_payload_from_raw_sig_body
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.__super__.unbox">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>unbox
            <span class="apidocSignatureSpan">(msb, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.SignatureEngine.prototype">module kbpgp.SignatureEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype._check_result">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>_check_result
            <span class="apidocSignatureSpan">(literals, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.box">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>box
            <span class="apidocSignatureSpan">(msg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.decode">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>decode
            <span class="apidocSignatureSpan">(armored, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_body">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_body
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_km">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_km
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_unverified_payload_from_raw_sig_body
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.SignatureEngine.prototype.unbox">
            function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>unbox
            <span class="apidocSignatureSpan">(msg, cb, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.armor">module kbpgp.armor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message">
            function <span class="apidocSignatureSpan">kbpgp.armor.</span>Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.decode">
            function <span class="apidocSignatureSpan">kbpgp.armor.</span>decode
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.encode">
            function <span class="apidocSignatureSpan">kbpgp.armor.</span>encode
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.mdecode">
            function <span class="apidocSignatureSpan">kbpgp.armor.</span>mdecode
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.armor.Message">module kbpgp.armor.Message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message.Message">
            function <span class="apidocSignatureSpan">kbpgp.armor.</span>Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.armor.Message.prototype">module kbpgp.armor.Message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message.prototype.finish_unframe">
            function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>finish_unframe
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message.prototype.make_clearsign">
            function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>make_clearsign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message.prototype.raw">
            function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>raw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.armor.Message.prototype.unsplit">
            function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>unsplit
            <span class="apidocSignatureSpan">(lines)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym">module kbpgp.asym</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>DSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>ElGamal
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>RSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.get_class">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>get_class
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA">module kbpgp.asym.DSA</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.DSA">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>DSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>alloc
            <span class="apidocSignatureSpan">(klass, _arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.parse">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.parse_sig">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse_sig
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.read_sig_from_buf">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>read_sig_from_buf
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA.Priv.prototype">module kbpgp.asym.DSA.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Priv.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Priv.prototype.</span>sign
            <span class="apidocSignatureSpan">(h, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.Priv.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA.Pub.prototype">module kbpgp.asym.DSA.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.trunc_hash">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>trunc_hash
            <span class="apidocSignatureSpan">(h)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>verify
            <span class="apidocSignatureSpan">(_arg, h, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA.prototype">module kbpgp.asym.DSA.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.good_for_flags">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>good_for_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.pad_and_sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>pad_and_sign
            <span class="apidocSignatureSpan">(data, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.verify_unpad_and_check_hash">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>verify_unpad_and_check_hash
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA.prototype.Priv">module kbpgp.asym.DSA.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Priv.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.DSA.prototype.Pub">module kbpgp.asym.DSA.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Pub.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal">module kbpgp.asym.ElGamal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.ElGamal">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>ElGamal
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>alloc
            <span class="apidocSignatureSpan">(klass, _arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.parse">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.parse_output">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse_output
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal.Priv.prototype">module kbpgp.asym.ElGamal.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(c, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.serialize">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>serialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal.Pub.prototype">module kbpgp.asym.ElGamal.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(m, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype">module kbpgp.asym.ElGamal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.decrypt_and_unpad">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>decrypt_and_unpad
            <span class="apidocSignatureSpan">(ciphertext, params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.export_output">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>export_output
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.good_for_flags">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>good_for_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.max_value">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>max_value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.pad_and_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>pad_and_encrypt
            <span class="apidocSignatureSpan">(data, params, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype.Priv">module kbpgp.asym.ElGamal.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Priv.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype.Pub">module kbpgp.asym.ElGamal.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Pub.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA">module kbpgp.asym.RSA</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.RSA">
            function <span class="apidocSignatureSpan">kbpgp.asym.</span>RSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>alloc
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.generate">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.make">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>make
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.parse">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.parse_output">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_output
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.parse_sig">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_sig
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.subkey_algo">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>subkey_algo
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA.Priv.prototype">module kbpgp.asym.RSA.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(c, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.lambda">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>lambda
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.mod_pow_d_crt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>mod_pow_d_crt
            <span class="apidocSignatureSpan">(x, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.n">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>n
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.phi">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>phi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>sign
            <span class="apidocSignatureSpan">(m, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA.Pub.prototype">module kbpgp.asym.RSA.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(p, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.mod_pow">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>mod_pow
            <span class="apidocSignatureSpan">(x, d, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.validity_check">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>validity_check
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>verify
            <span class="apidocSignatureSpan">(s, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA.prototype">module kbpgp.asym.RSA.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(c, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.decrypt_and_unpad">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>decrypt_and_unpad
            <span class="apidocSignatureSpan">(ciphertext, params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(p, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.export_output">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>export_output
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.max_value">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>max_value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.pad_and_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>pad_and_encrypt
            <span class="apidocSignatureSpan">(data, params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.pad_and_sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>pad_and_sign
            <span class="apidocSignatureSpan">(data, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.sanity_check">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>sanity_check
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>sign
            <span class="apidocSignatureSpan">(m, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.to_openpgp">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>to_openpgp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.validity_check">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>validity_check
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>verify
            <span class="apidocSignatureSpan">(s, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.verify_unpad_and_check_hash">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>verify_unpad_and_check_hash
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA.prototype.Priv">module kbpgp.asym.RSA.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Priv.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.asym.RSA.prototype.Pub">module kbpgp.asym.RSA.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Pub.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.base">module kbpgp.base</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.base.BaseEccKey">
            function <span class="apidocSignatureSpan">kbpgp.base.</span>BaseEccKey
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.base.generate">
            function <span class="apidocSignatureSpan">kbpgp.base.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.baseburner">module kbpgp.baseburner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.baseburner.BaseBurner">
            function <span class="apidocSignatureSpan">kbpgp.baseburner.</span>BaseBurner
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.basekeypair">module kbpgp.basekeypair</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.basekeypair.BaseKey">
            function <span class="apidocSignatureSpan">kbpgp.basekeypair.</span>BaseKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.basekeypair.BaseKeyPair">
            function <span class="apidocSignatureSpan">kbpgp.basekeypair.</span>BaseKeyPair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.bn">module kbpgp.bn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.bn_from_left_n_bits">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>bn_from_left_n_bits
            <span class="apidocSignatureSpan">(raw, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.buffer_shift_right">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>buffer_shift_right
            <span class="apidocSignatureSpan">(buf, nbits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.mpi_from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>mpi_from_buffer
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.mpi_to_padded_octets">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>mpi_to_padded_octets
            <span class="apidocSignatureSpan">(bn, base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.nbi">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.nbits">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbits
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.nbs">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbs
            <span class="apidocSignatureSpan">(s, base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.nbv">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbv
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.toMPI">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>toMPI
            <span class="apidocSignatureSpan">(bn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.bn.BigInteger">module kbpgp.bn.BigInteger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.BigInteger">
            function <span class="apidocSignatureSpan">kbpgp.bn.</span>BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.fromBuffer">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromBuffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.fromByteArrayUnsigned">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromByteArrayUnsigned
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.fromDERInteger">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromDERInteger
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.fromHex">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromHex
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.random_nbit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>random_nbit
            <span class="apidocSignatureSpan">(nbits, rf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.valueOf">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>valueOf
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.bn.BigInteger.prototype">module kbpgp.bn.BigInteger.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.abs">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.add">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>add
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.addTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>addTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.am">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>am
            <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.and">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>and
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.andNot">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>andNot
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitCount">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitLength">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitwiseTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitwiseTo
            <span class="apidocSignatureSpan">(a, op, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.byteLength">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>byteLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.byteValue">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>byteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.changeBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>changeBit
            <span class="apidocSignatureSpan">(n, op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.chunkSize">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>chunkSize
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clamp">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clearBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clearBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.compareTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>compareTo
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.copyTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>copyTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dAddOffset">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dAddOffset
            <span class="apidocSignatureSpan">(n, w)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dMultiply">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dMultiply
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divRemTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divRemTo
            <span class="apidocSignatureSpan">(m, q, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divide">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divide
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divideAndRemainder">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divideAndRemainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dlShiftTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dlShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.drShiftTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>drShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.equals">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>equals
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.exp">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>exp
            <span class="apidocSignatureSpan">(e, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.flipBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>flipBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromBuffer">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromBuffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromInt">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromInt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromNumber">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromNumber
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromRadix">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromRadix
            <span class="apidocSignatureSpan">(s, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromString">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromString
            <span class="apidocSignatureSpan">(s, b, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.gcd">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>gcd
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.getLowestSetBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>getLowestSetBit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.inspect">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.intValue">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>intValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.invDigit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>invDigit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.isEven">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.isProbablePrime">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>isProbablePrime
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.lShiftTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>lShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.max">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>max
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.millerRabin">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>millerRabin
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.min">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>min
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.mod">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>mod
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modInt">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modInverse">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modInverse
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modPow">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modPow
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modPowInt">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modPowInt
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.mpi_byte_length">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>mpi_byte_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiply">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiply
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyLowerTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyLowerTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyUpperTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyUpperTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.negate">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.not">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.or">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>or
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.pow">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>pow
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.rShiftTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>rShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.remainder">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>remainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.setBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>setBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shiftRight">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shortValue">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shortValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.signum">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>signum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.square">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>square
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.squareTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>squareTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.subTo">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>subTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.subtract">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>subtract
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.testBit">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>testBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toBuffer">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toBuffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArray">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toByteArray
            <span class="apidocSignatureSpan">(encode_sign_bit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArrayUnsigned">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toByteArrayUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toDERInteger">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toDERInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toHex">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toHex
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toMPI">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toMPI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toRadix">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toRadix
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toString">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toString
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.to_mpi_buffer">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>to_mpi_buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.to_padded_octets">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>to_padded_octets
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.bn.BigInteger.prototype.xor">
            function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>xor
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>DB</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>DM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>DV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>F1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>F2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>FV</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.buffer">module kbpgp.buffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.buffer.SlicerBuffer">
            function <span class="apidocSignatureSpan">kbpgp.buffer.</span>SlicerBuffer
            <span class="apidocSignatureSpan">(buf, start)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.burner">module kbpgp.burner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burner.Burner">
            function <span class="apidocSignatureSpan">kbpgp.burner.</span>Burner
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burner.burn">
            function <span class="apidocSignatureSpan">kbpgp.burner.</span>burn
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burner.clearsign">
            function <span class="apidocSignatureSpan">kbpgp.burner.</span>clearsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burner.detachsign">
            function <span class="apidocSignatureSpan">kbpgp.burner.</span>detachsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.burner.make_simple_literals">
            function <span class="apidocSignatureSpan">kbpgp.burner.</span>make_simple_literals
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.cast5">module kbpgp.cast5</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.cast5.CAST5">
            function <span class="apidocSignatureSpan">kbpgp.cast5.</span>CAST5
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.cfb">module kbpgp.cfb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.cfb.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.cfb.</span>decrypt
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.cfb.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.cfb.</span>encrypt
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.clearsign">module kbpgp.clearsign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.clearsign_to_sign">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>clearsign_to_sign
            <span class="apidocSignatureSpan">(lines, warnings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.dash_escape">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_escape
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.dash_unescape_line">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_unescape_line
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.dash_unescape_lines">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_unescape_lines
            <span class="apidocSignatureSpan">(lines, warnings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.input_to_cleartext">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.input_to_cleartext_display">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext_display
            <span class="apidocSignatureSpan">(lines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.input_to_cleartext_sign">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext_sign
            <span class="apidocSignatureSpan">(lines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.sign">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>sign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.verify">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>verify
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.clearsign.whitespace_strip">
            function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>whitespace_strip
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.detachsign">module kbpgp.detachsign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.detachsign.sign">
            function <span class="apidocSignatureSpan">kbpgp.detachsign.</span>sign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.detachsign.verify">
            function <span class="apidocSignatureSpan">kbpgp.detachsign.</span>verify
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.dh">module kbpgp.dh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.dh.DH">
            function <span class="apidocSignatureSpan">kbpgp.dh.</span>DH
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.dh.Pair">
            function <span class="apidocSignatureSpan">kbpgp.dh.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.dsa">module kbpgp.dsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.dsa.DSA">
            function <span class="apidocSignatureSpan">kbpgp.dsa.</span>DSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.dsa.Pair">
            function <span class="apidocSignatureSpan">kbpgp.dsa.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc">module kbpgp.ecc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDH
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>EDDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.</span>curves</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH">module kbpgp.ecc.ECDH</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.ECDH">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDH
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>alloc
            <span class="apidocSignatureSpan">(klass, _arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.generate">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.parse">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.parse_output">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse_output
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH.Priv.prototype">module kbpgp.ecc.ECDH.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(c, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.serialize">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>serialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH.Pub.prototype">module kbpgp.ecc.ECDH.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.apply_defaults">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>apply_defaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(m, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.format_params">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>format_params
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.kdf">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>kdf
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.read_params">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>read_params
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>serialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize_params">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>serialize_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype">module kbpgp.ecc.ECDH.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.decrypt_and_unpad">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>decrypt_and_unpad
            <span class="apidocSignatureSpan">(ciphertext, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.export_output">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>export_output
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.max_value">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>max_value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.pad_and_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>pad_and_encrypt
            <span class="apidocSignatureSpan">(data, _arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype.Priv">module kbpgp.ecc.ECDH.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Priv.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype.Pub">module kbpgp.ecc.ECDH.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub._alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>_alloc
            <span class="apidocSignatureSpan">(klass, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA">module kbpgp.ecc.ECDSA</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.ECDSA">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>alloc
            <span class="apidocSignatureSpan">(klass, _arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.generate">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.parse">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.parse_sig">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse_sig
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.read_sig_from_buf">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>read_sig_from_buf
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.subkey_algo">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>subkey_algo
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA.Priv.prototype">module kbpgp.ecc.ECDSA.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Priv.prototype.</span>sign
            <span class="apidocSignatureSpan">(h, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Priv.prototype.</span>ORDER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA.Pub.prototype">module kbpgp.ecc.ECDSA.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.read_params">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>read_params
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.trunc_hash">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>trunc_hash
            <span class="apidocSignatureSpan">(h)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>verify
            <span class="apidocSignatureSpan">(_arg, h, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype">module kbpgp.ecc.ECDSA.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.good_for_flags">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>good_for_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.pad_and_sign">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>pad_and_sign
            <span class="apidocSignatureSpan">(data, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.verify_unpad_and_check_hash">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>verify_unpad_and_check_hash
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype.Priv">module kbpgp.ecc.ECDSA.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Priv.</span>ORDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype.Pub">module kbpgp.ecc.ECDSA.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub._alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>_alloc
            <span class="apidocSignatureSpan">(klass, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA">module kbpgp.ecc.EDDSA</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.EDDSA">
            function <span class="apidocSignatureSpan">kbpgp.ecc.</span>EDDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>alloc
            <span class="apidocSignatureSpan">(klass, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.eddsa_value_from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>eddsa_value_from_buffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.generate">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.parse">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse
            <span class="apidocSignatureSpan">(pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.parse_kb">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse_kb
            <span class="apidocSignatureSpan">(klass, pub_raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.parse_sig">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse_sig
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.read_sig_from_buf">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>read_sig_from_buf
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.subkey_algo">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>subkey_algo
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>__super__</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>klass_name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA.Priv.prototype">module kbpgp.ecc.EDDSA.Priv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.serialize">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>serialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>sign
            <span class="apidocSignatureSpan">(h, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA.Pub.prototype">module kbpgp.ecc.EDDSA.Pub.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.read_params">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>read_params
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.serialize">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>serialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.trunc_hash">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>trunc_hash
            <span class="apidocSignatureSpan">(h)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>verify
            <span class="apidocSignatureSpan">(_arg, payload, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>MPI_LENGTH_HEADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>OID</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype">module kbpgp.ecc.EDDSA.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.good_for_flags">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>good_for_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.pad_and_sign">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>pad_and_sign
            <span class="apidocSignatureSpan">(data, _arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.verify_unpad_and_check_hash">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>verify_unpad_and_check_hash
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype.Priv">module kbpgp.ecc.EDDSA.prototype.Priv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.Priv">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Priv
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv._alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Priv.</span>_alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Priv.</span>alloc
            <span class="apidocSignatureSpan">(raw, pub)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Priv.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype.Pub">module kbpgp.ecc.EDDSA.prototype.Pub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.Pub">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Pub
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub._alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>_alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.alloc">
            function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>alloc
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>MPI_LENGTH_HEADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>OID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.curves">module kbpgp.ecc.curves</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>Curve
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>Curve25519
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.H">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>H
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.alloc_by_name">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_name
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.alloc_by_nbits">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_nbits
            <span class="apidocSignatureSpan">(nbits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.alloc_by_oid">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_oid
            <span class="apidocSignatureSpan">(oid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.brainpool_p256">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p256
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.brainpool_p384">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p384
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.brainpool_p512">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p512
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.cv25519">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>cv25519
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.nist_p256">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p256
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.nist_p384">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p384
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.nist_p521">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p521
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.curves.Curve.prototype">module kbpgp.ecc.curves.Curve.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype._mpi_point_from_slicer_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>_mpi_point_from_slicer_buffer
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.coord_to_mpi_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>coord_to_mpi_buffer
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(x, V)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(R, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.generate">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>generate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mkpoint">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mkpoint
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_bit_size">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_bit_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_byte_size">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_byte_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_bit_size">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_coord_bit_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_byte_size">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_coord_byte_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_from_buffer
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_point_from_buffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_slicer_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_point_from_slicer_buffer
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>point_to_mpi_buffer
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer_compact">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>point_to_mpi_buffer_compact
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.random_scalar">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>random_scalar
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecc.curves.Curve25519.prototype">module kbpgp.ecc.curves.Curve25519.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype._mpi_point_from_slicer_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>_mpi_point_from_slicer_buffer
            <span class="apidocSignatureSpan">(sb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.coord_to_mpi_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>coord_to_mpi_buffer
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(x, V)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(R, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.generate">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>generate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_bit_size">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>mpi_bit_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>mpi_from_buffer
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.nbits">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>nbits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>point_to_mpi_buffer
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer_compact">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>point_to_mpi_buffer_compact
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.random_scalar">
            function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>random_scalar
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecdh">module kbpgp.ecdh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecdh.ECDH">
            function <span class="apidocSignatureSpan">kbpgp.ecdh.</span>ECDH
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecdh.Pair">
            function <span class="apidocSignatureSpan">kbpgp.ecdh.</span>Pair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ecdsa">module kbpgp.ecdsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecdsa.ECDSA">
            function <span class="apidocSignatureSpan">kbpgp.ecdsa.</span>ECDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ecdsa.Pair">
            function <span class="apidocSignatureSpan">kbpgp.ecdsa.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.eddsa">module kbpgp.eddsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.eddsa.EDDSA">
            function <span class="apidocSignatureSpan">kbpgp.eddsa.</span>EDDSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.eddsa.Pair">
            function <span class="apidocSignatureSpan">kbpgp.eddsa.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.elgamal">module kbpgp.elgamal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.elgamal.ElGamal">
            function <span class="apidocSignatureSpan">kbpgp.elgamal.</span>ElGamal
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.elgamal.Pair">
            function <span class="apidocSignatureSpan">kbpgp.elgamal.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.elgamalse">module kbpgp.elgamalse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.elgamalse.ElGamalSignEncrypt">
            function <span class="apidocSignatureSpan">kbpgp.elgamalse.</span>ElGamalSignEncrypt
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.elgamalse.Pair">
            function <span class="apidocSignatureSpan">kbpgp.elgamalse.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.encode">module kbpgp.encode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.encode.pack">
            function <span class="apidocSignatureSpan">kbpgp.encode.</span>pack
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.encode.read_base64">
            function <span class="apidocSignatureSpan">kbpgp.encode.</span>read_base64
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.encode.seal">
            function <span class="apidocSignatureSpan">kbpgp.encode.</span>seal
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.encode.unpack">
            function <span class="apidocSignatureSpan">kbpgp.encode.</span>unpack
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.encode.unseal">
            function <span class="apidocSignatureSpan">kbpgp.encode.</span>unseal
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.errors">module kbpgp.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.RevokedKeyError">
            function <span class="apidocSignatureSpan">kbpgp.errors.</span>RevokedKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.WrongSigningKeyError">
            function <span class="apidocSignatureSpan">kbpgp.errors.</span>WrongSigningKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.errors.</span>OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.errors.</span>REVOKED_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.errors.</span>WRONG_SIGNING_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.errors.</span>code</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.errors.</span>msg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.errors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.errors.RevokedKeyError">module kbpgp.errors.RevokedKeyError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.RevokedKeyError.RevokedKeyError">
            function <span class="apidocSignatureSpan">kbpgp.errors.</span>RevokedKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.RevokedKeyError.super_">
            function <span class="apidocSignatureSpan">kbpgp.errors.RevokedKeyError.</span>super_
            <span class="apidocSignatureSpan">(msg, constructor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.errors.RevokedKeyError.prototype">module kbpgp.errors.RevokedKeyError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.RevokedKeyError.prototype.inspect">
            function <span class="apidocSignatureSpan">kbpgp.errors.RevokedKeyError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.errors.RevokedKeyError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.errors.WrongSigningKeyError">module kbpgp.errors.WrongSigningKeyError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.WrongSigningKeyError">
            function <span class="apidocSignatureSpan">kbpgp.errors.</span>WrongSigningKeyError
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.super_">
            function <span class="apidocSignatureSpan">kbpgp.errors.WrongSigningKeyError.</span>super_
            <span class="apidocSignatureSpan">(msg, constructor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.errors.WrongSigningKeyError.prototype">module kbpgp.errors.WrongSigningKeyError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.prototype.inspect">
            function <span class="apidocSignatureSpan">kbpgp.errors.WrongSigningKeyError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.errors.WrongSigningKeyError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash">module kbpgp.hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>MD5
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>RIPEMD160
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA1
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA224
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA256
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA384
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA512
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.alloc">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>alloc
            <span class="apidocSignatureSpan">(typ)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.alloc_or_throw">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>alloc_or_throw
            <span class="apidocSignatureSpan">(typ)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.hash.</span>streamers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.MD5">module kbpgp.hash.MD5</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.MD5">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>MD5
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.MD5.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.MD5.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.MD5.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.MD5.klass.prototype">module kbpgp.hash.MD5.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.RIPEMD160">module kbpgp.hash.RIPEMD160</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.RIPEMD160">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>RIPEMD160
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.RIPEMD160.klass.prototype">module kbpgp.hash.RIPEMD160.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.get_output_size">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>get_output_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA1">module kbpgp.hash.SHA1</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.SHA1">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA1
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA1.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA1.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.SHA1.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA1.klass.prototype">module kbpgp.hash.SHA1.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA224">module kbpgp.hash.SHA224</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.SHA224">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA224
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA224.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA224.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.SHA224.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA224.klass.prototype">module kbpgp.hash.SHA224.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA256">module kbpgp.hash.SHA256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.SHA256">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA256
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA256.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA256.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.SHA256.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA256.klass.prototype">module kbpgp.hash.SHA256.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.get_output_size">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>get_output_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA384">module kbpgp.hash.SHA384</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.SHA384">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA384
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA384.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA384.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.SHA384.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA384.klass.prototype">module kbpgp.hash.SHA384.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA512">module kbpgp.hash.SHA512</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.SHA512">
            function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA512
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.</span>klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA512.</span>output_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA512.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kbpgp.hash.SHA512.</span>algname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.SHA512.klass.prototype">module kbpgp.hash.SHA512.klass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hash.streamers">module kbpgp.hash.streamers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.MD5">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>MD5
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.RIPEMD160">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>RIPEMD160
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.SHA1">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.SHA224">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA224
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.SHA256">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA256
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.SHA384">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA384
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hash.streamers.SHA512">
            function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA512
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.hilev">module kbpgp.hilev</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hilev.SignatureEngine">
            function <span class="apidocSignatureSpan">kbpgp.hilev.</span>SignatureEngine
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hilev.box">
            function <span class="apidocSignatureSpan">kbpgp.hilev.</span>box
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.hilev.unbox">
            function <span class="apidocSignatureSpan">kbpgp.hilev.</span>unbox
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kb">module kbpgp.kb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>EncKeyManager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.box">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>box
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.decode_sig">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>decode_sig
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.get_sig_body">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>get_sig_body
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.unbox">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>unbox
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.unbox_decode">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>unbox_decode
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kb.EncKeyManager">module kbpgp.kb.EncKeyManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.EncKeyManager">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>EncKeyManager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.generate">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>generate
            <span class="apidocSignatureSpan">(params, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.import_private">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>import_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.import_public">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>import_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kb.EncKeyManager.prototype">module kbpgp.kb.EncKeyManager.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_decrypt">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_decrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_encrypt">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_encrypt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_verify">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_verify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.get_mask">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>get_mask
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.make_sig_eng">
            function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>make_sig_eng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kb.KeyManager">module kbpgp.kb.KeyManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.kb.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.generate">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>generate
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.import_private">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>import_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.import_public">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>import_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kb.KeyManager.prototype">module kbpgp.kb.KeyManager.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.can_verify">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>can_verify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.check_public_eq">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>check_public_eq
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.eq">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>eq
            <span class="apidocSignatureSpan">(km2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_private">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_private
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_public">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_server_half">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_server_half
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.fetch">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>fetch
            <span class="apidocSignatureSpan">(key_ids, flags, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_ekid">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_ekid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_fp2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2_formatted">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_fp2_formatted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_keypair">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_keypair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_mask">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_mask
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_primary_keypair">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_primary_keypair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_type">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kb.KeyManager.prototype.make_sig_eng">
            function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>make_sig_eng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.keyfetch">module kbpgp.keyfetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keyfetch.KeyFetcher">
            function <span class="apidocSignatureSpan">kbpgp.keyfetch.</span>KeyFetcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.keymanager">module kbpgp.keymanager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keymanager.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.keymanager.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.keymanager.</span>opkts</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.keyring">module kbpgp.keyring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keyring.KeyRing">
            function <span class="apidocSignatureSpan">kbpgp.keyring.</span>KeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keyring.PgpKeyRing">
            function <span class="apidocSignatureSpan">kbpgp.keyring.</span>PgpKeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.keywrapper">module kbpgp.keywrapper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keywrapper.Lifespan">
            function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Lifespan
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keywrapper.Primary">
            function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Primary
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.keywrapper.Subkey">
            function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Subkey
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.kmi">module kbpgp.kmi</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kmi.KeyManagerInterface">
            function <span class="apidocSignatureSpan">kbpgp.kmi.</span>KeyManagerInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.kmi.SignatureEngineInterface">
            function <span class="apidocSignatureSpan">kbpgp.kmi.</span>SignatureEngineInterface
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.main">module kbpgp.main</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.ASP">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>ASP
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.Buffer">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.Burner">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>Burner
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.KeyFetcher">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyFetcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.KeyManager">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyManager
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.KeyRing">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.PgpKeyRing">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>PgpKeyRing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.SignatureEngine">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>SignatureEngine
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.box">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>box
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.burn">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>burn
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.clearsign">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>clearsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.detachsign">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>detachsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.make_simple_literals">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>make_simple_literals
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.main.unbox">
            function <span class="apidocSignatureSpan">kbpgp.main.</span>unbox
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>asym</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>base32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>base58</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>base91</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>bn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>const</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>ecc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>kb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>keyring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>nacl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>opkts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>processor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>rand</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>triplesec</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>ukm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.main.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ocfb">module kbpgp.ocfb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ocfb.Decryptor">
            function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>Decryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ocfb.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>decrypt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ocfb.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>encrypt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts">module kbpgp.opkts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>KeyMaterial
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>Signature
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>UserID
            <span class="apidocSignatureSpan">(userid, components)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.KeyMaterial">module kbpgp.opkts.KeyMaterial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.KeyMaterial">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>KeyMaterial
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.parse_private_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.</span>parse_private_key
            <span class="apidocSignatureSpan">(slice, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.parse_public_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.</span>parse_public_key
            <span class="apidocSignatureSpan">(slice, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.KeyMaterial.prototype">module kbpgp.opkts.KeyMaterial.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_primary">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_get_expire_time_on_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_subkey">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_get_expire_time_on_subkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._self_sign_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_self_sign_key
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_primary_with_subkey">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_primary_with_subkey
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_subkey
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey_with_primary">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_subkey_with_primary
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_dummy">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_dummy
            <span class="apidocSignatureSpan">(bufs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_clear">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_private_clear
            <span class="apidocSignatureSpan">(bufs, priv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_enc">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_private_enc
            <span class="apidocSignatureSpan">(bufs, priv, pp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_public">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_public
            <span class="apidocSignatureSpan">(bufs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.add_flags">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>add_flags
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.can_sign">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>can_sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.check_not_expired">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>check_not_expired
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.ekid">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>ekid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.equal">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>equal
            <span class="apidocSignatureSpan">(k2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.export_framed">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>export_framed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.fulfills_flags">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>fulfills_flags
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_all_key_flags">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_all_key_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_expire_time">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_expire_time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_fingerprint">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_fingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_key_id">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_klass">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_klass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_short_key_id">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_short_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_user_attributes">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_signed_user_attributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_userids">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_signed_userids
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_subkey_binding
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding_signature_output">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_subkey_binding_signature_output
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_locked_private">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_locked_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_private">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_secret_key_material">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_secret_key_material
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_unlocked_private">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_unlocked_private
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_duplicate_primary">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_duplicate_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_key_material">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_key_material
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_locked">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_locked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_preferable_to">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_preferable_to
            <span class="apidocSignatureSpan">(k2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_primary">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_revoked">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_revoked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_self_signed">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_self_signed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_signed_subkey_of">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_signed_subkey_of
            <span class="apidocSignatureSpan">(primary, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.mark_revoked">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>mark_revoked
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.merge_private">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>merge_private
            <span class="apidocSignatureSpan">(k2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_body">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>private_body
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_framed">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>private_framed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_body">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>public_body
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_framed">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>public_framed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.push_sig">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>push_sig
            <span class="apidocSignatureSpan">(packetsig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.self_sign_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>self_sign_key
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.set_duplicate_primary">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>set_duplicate_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.sign_subkey">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>sign_subkey
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.to_signature_payload">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>to_signature_payload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.unlock">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>unlock
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.validity_check">
            function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>validity_check
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.Signature">module kbpgp.opkts.Signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.Signature">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>Signature
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.parse">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.</span>parse
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.opkts.Signature.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.Signature.prototype">module kbpgp.opkts.Signature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype._check_key_sig_expiration">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_check_key_sig_expiration
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype._make_subpacket_index">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_make_subpacket_index
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype._verify">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_verify
            <span class="apidocSignatureSpan">(data_packets, cb, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.extract_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>extract_key
            <span class="apidocSignatureSpan">(data_packets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_framed_output">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_framed_output
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_fingerprint">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_issuer_fingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_key_id">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_issuer_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_expires">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_expires
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_flags">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_flags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_id">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_sig_expires">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_sig_expires
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.is_signature">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>is_signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.issuer_matches_key">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>issuer_matches_key
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.prepare_payload">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>prepare_payload
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.time_primary_pair">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>time_primary_pair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.verify">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>verify
            <span class="apidocSignatureSpan">(data_packets, cb, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.when_generated">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>when_generated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.write">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>write
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.Signature.prototype.write_unframed">
            function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>write_unframed
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.UserID">module kbpgp.opkts.UserID</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.UserID">
            function <span class="apidocSignatureSpan">kbpgp.opkts.</span>UserID
            <span class="apidocSignatureSpan">(userid, components)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.make">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.</span>make
            <span class="apidocSignatureSpan">(components)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.parse">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.</span>parse
            <span class="apidocSignatureSpan">(slice)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.opkts.UserID.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.opkts.UserID.prototype">module kbpgp.opkts.UserID.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype._parse">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>_parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.cmp">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>cmp
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>constructor
            <span class="apidocSignatureSpan">(userid, components)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_comment">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_email">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_email
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_framed_signature_output">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_framed_signature_output
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_username">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_username
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.time_primary_pair">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>time_primary_pair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.to_signature_payload">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>to_signature_payload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.to_userid">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>to_userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.utf8">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>utf8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.opkts.UserID.prototype.write">
            function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.pad">module kbpgp.pad</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.ecc_pkcs5_pad_data">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>ecc_pkcs5_pad_data
            <span class="apidocSignatureSpan">(d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.ecc_pkcs5_unpad_data">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>ecc_pkcs5_unpad_data
            <span class="apidocSignatureSpan">(buf, data_len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.eme_pkcs1_decode">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>eme_pkcs1_decode
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.eme_pkcs1_encode">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>eme_pkcs1_encode
            <span class="apidocSignatureSpan">(v, len, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.emsa_pkcs1_decode">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>emsa_pkcs1_decode
            <span class="apidocSignatureSpan">(v, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.pad.emsa_pkcs1_encode">
            function <span class="apidocSignatureSpan">kbpgp.pad.</span>emsa_pkcs1_encode
            <span class="apidocSignatureSpan">(hashed_data, len, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.parser">module kbpgp.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.parser.parse">
            function <span class="apidocSignatureSpan">kbpgp.parser.</span>parse
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.primegen">module kbpgp.primegen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.primegen.fermat2_test">
            function <span class="apidocSignatureSpan">kbpgp.primegen.</span>fermat2_test
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.primegen.miller_rabin">
            function <span class="apidocSignatureSpan">kbpgp.primegen.</span>miller_rabin
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.primegen.naive_is_prime">
            function <span class="apidocSignatureSpan">kbpgp.primegen.</span>naive_is_prime
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.primegen.nbs">
            function <span class="apidocSignatureSpan">kbpgp.primegen.</span>nbs
            <span class="apidocSignatureSpan">(s, base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.primegen.random_prime">
            function <span class="apidocSignatureSpan">kbpgp.primegen.</span>random_prime
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.primegen.</span>small_primes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.processor">module kbpgp.processor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock">
            function <span class="apidocSignatureSpan">kbpgp.processor.</span>KeyBlock
            <span class="apidocSignatureSpan">(packets, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message">
            function <span class="apidocSignatureSpan">kbpgp.processor.</span>Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.do_message">
            function <span class="apidocSignatureSpan">kbpgp.processor.</span>do_message
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.processor.KeyBlock">module kbpgp.processor.KeyBlock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.KeyBlock">
            function <span class="apidocSignatureSpan">kbpgp.processor.</span>KeyBlock
            <span class="apidocSignatureSpan">(packets, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.processor.KeyBlock.prototype">module kbpgp.processor.KeyBlock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_issuer">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_issuer
            <span class="apidocSignatureSpan">(i, packet, primary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_keys">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_primary">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_primary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_subkeys">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_subkeys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._extract_keys">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_extract_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._verify_sigs">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_verify_sigs
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype.process">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>process
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.KeyBlock.prototype.to_obj">
            function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>to_obj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.processor.Message">module kbpgp.processor.Message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.Message">
            function <span class="apidocSignatureSpan">kbpgp.processor.</span>Message
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.processor.Message.prototype">module kbpgp.processor.Message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._decrypt">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_decrypt
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._decrypt_with_session_key">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_decrypt_with_session_key
            <span class="apidocSignatureSpan">(sesskey, edat, pkcs5, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._find_encrypted_data">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_find_encrypted_data
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._frame_signatures">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_frame_signatures
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._get_session_key">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_get_session_key
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._inflate">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_inflate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._parse">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_parse
            <span class="apidocSignatureSpan">(raw, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._process">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_process
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._process_generic">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_process_generic
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._verify">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._verify_clearsign">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_clearsign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._verify_sig">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_sig
            <span class="apidocSignatureSpan">(sig, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype._verify_signature">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_signature
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype.collect_literals">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>collect_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype.parse_and_inflate">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>parse_and_inflate
            <span class="apidocSignatureSpan">(body, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.processor.Message.prototype.parse_and_process">
            function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>parse_and_process
            <span class="apidocSignatureSpan">(msg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.rand">module kbpgp.rand</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rand.MRF">
            function <span class="apidocSignatureSpan">kbpgp.rand.</span>MRF
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rand.SRF">
            function <span class="apidocSignatureSpan">kbpgp.rand.</span>SRF
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.rfc3394">module kbpgp.rfc3394</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rfc3394.unwrap">
            function <span class="apidocSignatureSpan">kbpgp.rfc3394.</span>unwrap
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rfc3394.wrap">
            function <span class="apidocSignatureSpan">kbpgp.rfc3394.</span>wrap
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.rsa">module kbpgp.rsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rsa.Output">
            function <span class="apidocSignatureSpan">kbpgp.rsa.</span>Output
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rsa.Pair">
            function <span class="apidocSignatureSpan">kbpgp.rsa.</span>Pair
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.rsa.RSA">
            function <span class="apidocSignatureSpan">kbpgp.rsa.</span>RSA
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.s2k">module kbpgp.s2k</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.s2k.S2K">
            function <span class="apidocSignatureSpan">kbpgp.s2k.</span>S2K
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.s2k.SecretKeyMaterial">
            function <span class="apidocSignatureSpan">kbpgp.s2k.</span>SecretKeyMaterial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.sigeng">module kbpgp.sigeng</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.sigeng.SignatureEngine">
            function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>SignatureEngine
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.sigeng.decode_sig">
            function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>decode_sig
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.sigeng.get_sig_body">
            function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>get_sig_body
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.symmetric">module kbpgp.symmetric</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.symmetric.checksum2">
            function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>checksum2
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.symmetric.export_key_pgp">
            function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>export_key_pgp
            <span class="apidocSignatureSpan">(algo_id, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.symmetric.get_cipher">
            function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>get_cipher
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.symmetric.import_key_pgp">
            function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>import_key_pgp
            <span class="apidocSignatureSpan">(msg, pkcs5_padding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec">module kbpgp.triplesec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Base
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Decryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Encryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC
            <span class="apidocSignatureSpan">(key, klass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC_SHA256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>WordArray
            <span class="apidocSignatureSpan">(words, sigBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.decrypt">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>decrypt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.encrypt">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>encrypt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.pbkdf2">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>pbkdf2
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.scrypt">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>scrypt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.</span>CURRENT_VERSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>V</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>ciphers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>hmac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>modes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>prng</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Base">module kbpgp.triplesec.Base</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.Base">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Base
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Base.prototype">module kbpgp.triplesec.Base.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype._check_scrubbed">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>_check_scrubbed
            <span class="apidocSignatureSpan">(key, where, ecb, okcb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.clone_derived_keys">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>clone_derived_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.kdf">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>kdf
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_aes">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_aes
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_salsa20">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_salsa20
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_twofish">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_twofish
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.set_key">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>set_key
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Base.prototype.sign">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>sign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Decryptor">module kbpgp.triplesec.Decryptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.Decryptor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Decryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Decryptor.prototype">module kbpgp.triplesec.Decryptor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.generate_keys">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>generate_keys
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_header">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>read_header
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_salt">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>read_salt
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.run">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>run
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.unshift_iv">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>unshift_iv
            <span class="apidocSignatureSpan">(n_bytes, which, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.verify_sig">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>verify_sig
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Encryptor">module kbpgp.triplesec.Encryptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.Encryptor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Encryptor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.Encryptor.prototype">module kbpgp.triplesec.Encryptor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.pick_random_ivs">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>pick_random_ivs
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.resalt">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>resalt
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.run">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>run
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.HMAC">module kbpgp.triplesec.HMAC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.HMAC">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC
            <span class="apidocSignatureSpan">(key, klass)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.</span>outputSize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.HMAC.prototype">module kbpgp.triplesec.HMAC.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.finalize">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>finalize
            <span class="apidocSignatureSpan">(wa)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.get_output_size">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>get_output_size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.reset">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.update">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>update
            <span class="apidocSignatureSpan">(wa)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>outputSize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.HMAC_SHA256">module kbpgp.triplesec.HMAC_SHA256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256.HMAC_SHA256">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC_SHA256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC_SHA256.</span>outputSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC_SHA256.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.HMAC_SHA256.prototype">module kbpgp.triplesec.HMAC_SHA256.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC_SHA256.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.WordArray">module kbpgp.triplesec.WordArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.WordArray">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>WordArray
            <span class="apidocSignatureSpan">(words, sigBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.alloc">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>alloc
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_buffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_buffer_le">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_buffer_le
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_hex">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_hex
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_hex_le">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_hex_le
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_i32a">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_i32a
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_ui8a">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_ui8a
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_utf8">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_utf8
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.from_utf8_le">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_utf8_le
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.WordArray.prototype">module kbpgp.triplesec.WordArray.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.clamp">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>clamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.cmp_ule">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>cmp_ule
            <span class="apidocSignatureSpan">(wa2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.concat">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>concat
            <span class="apidocSignatureSpan">(wordArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.endian_reverse">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>endian_reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.equal">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>equal
            <span class="apidocSignatureSpan">(wa)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.is_scrubbed">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>is_scrubbed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.slice">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>slice
            <span class="apidocSignatureSpan">(low, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.split">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>split
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_hex">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_hex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_ui8a">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_ui8a
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_utf8">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_utf8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.truncate">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>truncate
            <span class="apidocSignatureSpan">(n_bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.unshift">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>unshift
            <span class="apidocSignatureSpan">(n_words)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.xor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>xor
            <span class="apidocSignatureSpan">(wa2, _arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.ciphers">module kbpgp.triplesec.ciphers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>AES
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>Salsa20
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>TwoFish
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.ciphers.AES.prototype">module kbpgp.triplesec.ciphers.AES.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doCryptBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>_doCryptBlock
            <span class="apidocSignatureSpan">(M, offset, keySchedule, SUB_MIX, SBOX)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.decryptBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>decryptBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.encryptBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>encryptBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>ivSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>keySize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.ciphers.Salsa20.prototype">module kbpgp.triplesec.ciphers.Salsa20.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._generateBlockBuffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>_generateBlockBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._reset">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>_reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.getBytes">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>getBytes
            <span class="apidocSignatureSpan">(needed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.ciphers.TwoFish.prototype">module kbpgp.triplesec.ciphers.TwoFish.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.F32">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>F32
            <span class="apidocSignatureSpan">(x, k32)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_0">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Fe32_0
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_3">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Fe32_3
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR1">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>LFSR1
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR2">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>LFSR2
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_X">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Mx_X
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_Y">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Mx_Y
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_MDS_Encode">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>RS_MDS_Encode
            <span class="apidocSignatureSpan">(k0, k1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_rem">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>RS_rem
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.decryptBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>decryptBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.encryptBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>encryptBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.getByte">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>getByte
            <span class="apidocSignatureSpan">(x, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.switchEndianness">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>switchEndianness
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>ivSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>keySize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.hash">module kbpgp.triplesec.hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.MD5">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>MD5
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.RIPEMD160">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>RIPEMD160
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA1">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA224">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA224
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA256">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA256
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA3
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA384">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA384
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA512">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA512
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.hash.SHA3.prototype">module kbpgp.triplesec.hash.SHA3.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doFinalize">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doProcessBlock">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doProcessBlock
            <span class="apidocSignatureSpan">(M, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doReset">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.clone">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.constructor">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.copy_to">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.scrub">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>scrub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>outputLength</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>output_size</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.hmac">module kbpgp.triplesec.hmac</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hmac.HMAC">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>HMAC
            <span class="apidocSignatureSpan">(key, klass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hmac.HMAC_SHA256">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>HMAC_SHA256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hmac.bulk_sign">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>bulk_sign
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.hmac.sign">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>sign
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.prng">module kbpgp.triplesec.prng</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.PRNG">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>PRNG
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.generate">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>generate
            <span class="apidocSignatureSpan">(n, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.native_rng">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>native_rng
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.prng.PRNG.prototype">module kbpgp.triplesec.prng.PRNG.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.gen_seed">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>gen_seed
            <span class="apidocSignatureSpan">(nbits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.generate">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>generate
            <span class="apidocSignatureSpan">(n, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.now_to_buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>now_to_buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.triplesec.util">module kbpgp.triplesec.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.buffer_cmp_ule">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>buffer_cmp_ule
            <span class="apidocSignatureSpan">(b1, b2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.bulk">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>bulk
            <span class="apidocSignatureSpan">(n_input_bytes, _arg, _arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.copy_buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>copy_buffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.default_delay">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>default_delay
            <span class="apidocSignatureSpan">(i, n, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.fixup_uint32">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>fixup_uint32
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.scrub_buffer">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>scrub_buffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.triplesec.util.scrub_vec">
            function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>scrub_vec
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.ukm">module kbpgp.ukm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ukm.decode_sig">
            function <span class="apidocSignatureSpan">kbpgp.ukm.</span>decode_sig
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ukm.get_sig_body">
            function <span class="apidocSignatureSpan">kbpgp.ukm.</span>get_sig_body
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.ukm.import_armored_public">
            function <span class="apidocSignatureSpan">kbpgp.ukm.</span>import_armored_public
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.util">module kbpgp.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.ASP">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>ASP
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.Warnings">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>Warnings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.akatch">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>akatch
            <span class="apidocSignatureSpan">(fn, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.assert_no_nulls">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>assert_no_nulls
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.asyncify">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>asyncify
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.athrow">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>athrow
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.bufeq_fast">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>bufeq_fast
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.bufeq_secure">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>bufeq_secure
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.buffer_to_ui8a">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>buffer_to_ui8a
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.bufferify">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>bufferify
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.bufxor">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>bufxor
            <span class="apidocSignatureSpan">(b1, b2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.calc_checksum">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>calc_checksum
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.encode_length">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>encode_length
            <span class="apidocSignatureSpan">(l, five_byte)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.fingerprint_to_key_id_64">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>fingerprint_to_key_id_64
            <span class="apidocSignatureSpan">(fp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.fit_to_size">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>fit_to_size
            <span class="apidocSignatureSpan">(size, buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.format_fingerprint">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>format_fingerprint
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.format_pgp_fingerprint_2">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>format_pgp_fingerprint_2
            <span class="apidocSignatureSpan">(buf, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.fpeq">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>fpeq
            <span class="apidocSignatureSpan">(fp1, fp2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.genseed">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>genseed
            <span class="apidocSignatureSpan">(_arg, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.json_stringify_sorted">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>json_stringify_sorted
            <span class="apidocSignatureSpan">(o, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.katch">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>katch
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.make_time_packet">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>make_time_packet
            <span class="apidocSignatureSpan">(d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.obj_extract">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>obj_extract
            <span class="apidocSignatureSpan">(o, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.ops_to_keyflags">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>ops_to_keyflags
            <span class="apidocSignatureSpan">(ops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.streq_secure">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>streq_secure
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.strip">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>strip
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.trim">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>trim
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.ui32a_to_ui8a">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>ui32a_to_ui8a
            <span class="apidocSignatureSpan">(v, out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.ui8a_to_ui32a">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>ui8a_to_ui32a
            <span class="apidocSignatureSpan">(v, out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.uint_to_buffer">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>uint_to_buffer
            <span class="apidocSignatureSpan">(nbits, i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.unix_time">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>unix_time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.xxd">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>xxd
            <span class="apidocSignatureSpan">(buf, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kbpgp.util.</span>base64u</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.util.Warnings">module kbpgp.util.Warnings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.Warnings.Warnings">
            function <span class="apidocSignatureSpan">kbpgp.util.</span>Warnings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.util.Warnings.prototype">module kbpgp.util.Warnings.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.Warnings.prototype.push">
            function <span class="apidocSignatureSpan">kbpgp.util.Warnings.prototype.</span>push
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.Warnings.prototype.warnings">
            function <span class="apidocSignatureSpan">kbpgp.util.Warnings.prototype.</span>warnings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.util.base64u">module kbpgp.util.base64u</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.base64u.decode">
            function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>decode
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.base64u.encode">
            function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>encode
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.util.base64u.verify">
            function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>verify
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kbpgp.verifier">module kbpgp.verifier</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kbpgp.verifier.Base">
            function <span class="apidocSignatureSpan">kbpgp.verifier.</span>Base
            <span class="apidocSignatureSpan">(_arg)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp" id="apidoc.module.kbpgp">module kbpgp</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ASP" id="apidoc.element.kbpgp.ASP">
        function <span class="apidocSignatureSpan">kbpgp.</span>ASP
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ASP(_arg) {
  var canceler, delay, progress_hook;
  progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;
  this._delay = delay != null ? delay : 2;
  this._canceler = canceler || (new Canceler());
  this._progress_hook = progress_hook || (function(obj) {});
  this._section = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer" id="apidoc.element.kbpgp.Buffer">
        function <span class="apidocSignatureSpan">kbpgp.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === &#x27;number&#x27;) {
    if (typeof encodingOrOffset === &#x27;string&#x27;) {
      throw new Error(
        &#x27;If encoding is specified then the first argument must be a string&#x27;
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner" id="apidoc.element.kbpgp.Burner">
        function <span class="apidocSignatureSpan">kbpgp.</span>Burner
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Burner(_arg) {
  var asp, encrypt_for, encryption_key, sign_with, signing_key;
  this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key =
_arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;
  Burner.__super__.constructor.call(this, {
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp
  });
  this.packets = [];
  this.opts || (this.opts = {});
  this.signed_payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyFetcher" id="apidoc.element.kbpgp.KeyFetcher">
        function <span class="apidocSignatureSpan">kbpgp.</span>KeyFetcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyFetcher() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager" id="apidoc.element.kbpgp.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  var signed;
  this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public
, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;
  this.pgp = new PgpEngine({
    primary: this.primary,
    subkeys: this.subkeys,
    userids: this.userids,
    user_attributes: this.user_attributes,
    key_manager: this
  });
  this.engines = [this.pgp];
  this._signed = signed != null ? signed : false;
  this.p3skb = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyRing" id="apidoc.element.kbpgp.KeyRing">
        function <span class="apidocSignatureSpan">kbpgp.</span>KeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing" id="apidoc.element.kbpgp.PgpKeyRing">
        function <span class="apidocSignatureSpan">kbpgp.</span>PgpKeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine" id="apidoc.element.kbpgp.SignatureEngine">
        function <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message" id="apidoc.element.kbpgp.armor.Message">
        function <span class="apidocSignatureSpan">kbpgp.</span>armor.Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.body = _arg.body, this.type = _arg.type, this.comment = _arg.comment, this.version = _arg.version, this.pre = _arg.pre, this
.post = _arg.post;
  this.lines = [];
  this.fields = {};
  this.payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA" id="apidoc.element.kbpgp.asym.DSA">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv" id="apidoc.element.kbpgp.asym.DSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub" id="apidoc.element.kbpgp.asym.DSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.DSA.prototype.Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal" id="apidoc.element.kbpgp.asym.ElGamal">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.ElGamal.prototype.Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA" id="apidoc.element.kbpgp.asym.RSA">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv" id="apidoc.element.kbpgp.asym.RSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg
.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub" id="apidoc.element.kbpgp.asym.RSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>asym.RSA.prototype.Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger" id="apidoc.element.kbpgp.bn.BigInteger">
        function <span class="apidocSignatureSpan">kbpgp.</span>bn.BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
	   // bigi has this, so add it in...
	   if (!(this instanceof BigInteger))
	     return new BigInteger(a, b, c)
	   if(a != null)
	     if(&#x22;number&#x22; == typeof a) this.fromNumber(a,b,c);
	     else if(b == null &#x26;&#x26; &#x22;string&#x22; != typeof a) this.fromString(a,256);
	     else this.fromString(a,b);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.box" id="apidoc.element.kbpgp.box">
        function <span class="apidocSignatureSpan">kbpgp.</span>box
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.burn" id="apidoc.element.kbpgp.burn">
        function <span class="apidocSignatureSpan">kbpgp.</span>burn
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">burn = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;burn&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">burn</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return raw = arguments[1];
      };
    })(),
    lineno: 247
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign" id="apidoc.element.kbpgp.clearsign">
        function <span class="apidocSignatureSpan">kbpgp.</span>clearsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearsign = function (_arg, cb) {
  var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, signing_key = _arg.signing_key;
  b = new ClearSigner({
    msg: msg,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      b.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 215
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.detachsign" id="apidoc.element.kbpgp.detachsign">
        function <span class="apidocSignatureSpan">kbpgp.</span>detachsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachsign = function (_arg, cb) {
  var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;
  s = new Signer({
    data: data,
    hash_streamer: hash_streamer,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      s.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 139
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      s.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH" id="apidoc.element.kbpgp.ecc.ECDH">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDH.prototype.Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA" id="apidoc.element.kbpgp.ecc.ECDSA">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.ECDSA.prototype.Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA" id="apidoc.element.kbpgp.ecc.EDDSA">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.prototype.Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.</span>ecc.EDDSA.prototype.Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.key = _arg.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.errors.RevokedKeyError" id="apidoc.element.kbpgp.errors.RevokedKeyError">
        function <span class="apidocSignatureSpan">kbpgp.</span>errors.RevokedKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors.RevokedKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.errors.WrongSigningKeyError" id="apidoc.element.kbpgp.errors.WrongSigningKeyError">
        function <span class="apidocSignatureSpan">kbpgp.</span>errors.WrongSigningKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors.WrongSigningKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5" id="apidoc.element.kbpgp.hash.MD5">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.MD5
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.MD5 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160" id="apidoc.element.kbpgp.hash.RIPEMD160">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.RIPEMD160
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.RIPEMD160 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1" id="apidoc.element.kbpgp.hash.SHA1">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA1
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.SHA1 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224" id="apidoc.element.kbpgp.hash.SHA224">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA224
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.SHA224 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256" id="apidoc.element.kbpgp.hash.SHA256">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA256
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.SHA256 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384" id="apidoc.element.kbpgp.hash.SHA384">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA384
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.SHA384 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512" id="apidoc.element.kbpgp.hash.SHA512">
        function <span class="apidocSignatureSpan">kbpgp.</span>hash.SHA512
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash.SHA512 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager" id="apidoc.element.kbpgp.kb.EncKeyManager">
        function <span class="apidocSignatureSpan">kbpgp.</span>kb.EncKeyManager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncKeyManager() {
  return EncKeyManager.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager" id="apidoc.element.kbpgp.kb.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.</span>kb.KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  this.key = _arg.key, this.server_half = _arg.server_half;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.make_simple_literals" id="apidoc.element.kbpgp.make_simple_literals">
        function <span class="apidocSignatureSpan">kbpgp.</span>make_simple_literals
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_simple_literals = function (msg) {
  return [
    new Literal({
      data: new Buffer(msg),
      format: C.literal_formats.utf8,
      date: unix_time()
    })
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial" id="apidoc.element.kbpgp.opkts.KeyMaterial">
        function <span class="apidocSignatureSpan">kbpgp.</span>opkts.KeyMaterial
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyMaterial(_arg) {
  this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg
.opts, this.flags = _arg.flags;
  this.opts || (this.opts = {});
  this.flags || (this.flags = 0);
  this._is_duplicate_primary = false;
  KeyMaterial.__super__.constructor.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature" id="apidoc.element.kbpgp.opkts.Signature">
        function <span class="apidocSignatureSpan">kbpgp.</span>opkts.Signature
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(_arg) {
  this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class
 = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets
, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version
 = _arg.version;
  if (this.hasher == null) {
    this.hasher = SHA512;
  }
  if (this.hashed_subpackets == null) {
    this.hashed_subpackets = [];
  }
  if (this.unhashed_subpackets == null) {
    this.unhashed_subpackets = [];
  }
  this.subpacket_index = this._make_subpacket_index();
  this._framed_output = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID" id="apidoc.element.kbpgp.opkts.UserID">
        function <span class="apidocSignatureSpan">kbpgp.</span>opkts.UserID
        <span class="apidocSignatureSpan">(userid, components)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserID(userid, components) {
  this.components = components != null ? components : null;
  this.userid = bufferify(userid);
  if (this.compontents == null) {
    this._parse();
  }
  UserID.__super__.constructor.call(this);
  this._time_primary_pair = null;
  this.primary = false;
  this.most_recent_sig = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock" id="apidoc.element.kbpgp.processor.KeyBlock">
        function <span class="apidocSignatureSpan">kbpgp.</span>processor.KeyBlock
        <span class="apidocSignatureSpan">(packets, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyBlock(packets, opts) {
  this.packets = packets;
  this.verified_signatures = [];
  this.subkeys = [];
  this.primary = null;
  this.userids = [];
  this.user_attributes = [];
  this.warnings = new Warnings();
  this.opts = opts || {};
  if (this.opts.strict == null) {
    this.opts.strict = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message" id="apidoc.element.kbpgp.processor.Message">
        function <span class="apidocSignatureSpan">kbpgp.</span>processor.Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.keyfetch = _arg.keyfetch, this.data_fn = _arg.data_fn, this.data = _arg.data, this.strict = _arg.strict, this.now = _arg.
now;
  this.literals = [];
  this.enc_data_packet = null;
  this.warnings = new Warnings();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base" id="apidoc.element.kbpgp.triplesec.Base">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Base
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Base(_arg) {
  var key, version;
  key = _arg.key, version = _arg.version;
  this.version = V[version != null ? version : CURRENT_VERSION];
  if (this.version == null) {
    throw new Error(&#x22;unknown version: &#x22; + version);
  }
  this.set_key(key);
  this.derived_keys = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor" id="apidoc.element.kbpgp.triplesec.Decryptor">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Decryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decryptor(_arg) {
  var enc, key;
  key = _arg.key, enc = _arg.enc;
  Decryptor.__super__.constructor.call(this, {
    key: key
  });
  if (enc != null) {
    this.key = enc.key;
    this.derived_keys = enc.derived_keys;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor" id="apidoc.element.kbpgp.triplesec.Encryptor">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.Encryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encryptor(_arg) {
  var key, rng, version;
  key = _arg.key, rng = _arg.rng, version = _arg.version;
  Encryptor.__super__.constructor.call(this, {
    key: key,
    version: version
  });
  this.rng = rng || prng.generate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC" id="apidoc.element.kbpgp.triplesec.HMAC">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC
        <span class="apidocSignatureSpan">(key, klass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC(key, klass) {
  var i, _i, _ref;
  if (klass == null) {
    klass = SHA512;
  }
  this.key = key.clone();
  this.hasher = new klass();
  this.hasherBlockSize = this.hasher.blockSize;
  this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
  if (this.key.sigBytes &#x3e; this.hasherBlockSizeBytes) {
    this.key = this.hasher.finalize(this.key);
  }
  this.key.clamp();
  this._oKey = this.key.clone();
  this._iKey = this.key.clone();
  for (i = _i = 0, _ref = this.hasherBlockSize; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    this._oKey.words[i] ^= 0x5c5c5c5c;
    this._iKey.words[i] ^= 0x36363636;
  }
  this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256" id="apidoc.element.kbpgp.triplesec.HMAC_SHA256">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.HMAC_SHA256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC_SHA256(key) {
  HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray" id="apidoc.element.kbpgp.triplesec.WordArray">
        function <span class="apidocSignatureSpan">kbpgp.</span>triplesec.WordArray
        <span class="apidocSignatureSpan">(words, sigBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WordArray(words, sigBytes) {
  this.words = words || [];
  this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.unbox" id="apidoc.element.kbpgp.unbox">
        function <span class="apidocSignatureSpan">kbpgp.</span>unbox
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (_arg, cb) {
  var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, now, proc, raw, strict, warnings, ___iced_passed_deferral
, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg
.data, strict = _arg.strict, now = _arg.now;
  literals = null;
  err = msg = warnings = esk = null;
  if (armored != null) {
    _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];
  } else if (raw != null) {
    msg_type || (msg_type = C.message_types.generic);
    msg = {
      body: raw,
      type: msg_type
    };
  } else {
    err = new Error(&#x22;No input to do_message; need either &#x27;armored&#x27; or &#x27;raw&#x27; input&#x22;);
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        if (strict == null) {
          strict = true;
        }
        proc = new Message({
          keyfetch: keyfetch,
          data_fn: data_fn,
          data: data,
          strict: strict,
          now: now
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;
          });
          proc.parse_and_process(msg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 409
          }));
          __iced_deferrals._fulfill();
        })(function() {
          warnings = proc.warnings;
          return __iced_k(esk = proc.encryption_subkey);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals, warnings, esk);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.Warnings" id="apidoc.element.kbpgp.util.Warnings">
        function <span class="apidocSignatureSpan">kbpgp.</span>util.Warnings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Warnings() {
  this._w = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ASP" id="apidoc.module.kbpgp.ASP">module kbpgp.ASP</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ASP.ASP" id="apidoc.element.kbpgp.ASP.ASP">
        function <span class="apidocSignatureSpan">kbpgp.</span>ASP
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ASP(_arg) {
  var canceler, delay, progress_hook;
  progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;
  this._delay = delay != null ? delay : 2;
  this._canceler = canceler || (new Canceler());
  this._progress_hook = progress_hook || (function(obj) {});
  this._section = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ASP.make" id="apidoc.element.kbpgp.ASP.make">
        function <span class="apidocSignatureSpan">kbpgp.ASP.</span>make
        <span class="apidocSignatureSpan">(asp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (asp) {
  return asp || (new ASP({}));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
      }
    };
    _while(__iced_k);
  });
})(this)((function(_this) {
  return function() {
    key = Pair.<span class="apidocCodeKeywordSpan">make</span>({
      p: p,
      q: q,
      e: e,
      phi: phi,
      p1: p1,
      q1: q1,
      lambda: lambda
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ASP.prototype" id="apidoc.module.kbpgp.ASP.prototype">module kbpgp.ASP.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ASP.prototype.canceler" id="apidoc.element.kbpgp.ASP.prototype.canceler">
        function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>canceler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canceler = function () {
  return this._canceler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ASP.prototype.delay" id="apidoc.element.kbpgp.ASP.prototype.delay">
        function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>delay
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (cb) {
  var ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/pgp-utils/src/util.iced&#x22;,
        funcname: &#x22;ASP.delay&#x22;
      });
      setTimeout(__iced_deferrals.defer({
        lineno: 47
      }), _this.delay);
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(_this._canceler.err());
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ASP.prototype.progress" id="apidoc.element.kbpgp.ASP.prototype.progress">
        function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>progress
        <span class="apidocSignatureSpan">(o, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (o, cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  if (this._section) {
    o.section = this._section;
  }
  this._progress_hook(o);
  if (cb != null) {
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/pgp-utils/src/util.iced&#x22;,
          funcname: &#x22;ASP.progress&#x22;
        });
        _this.delay(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 43
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return __iced_k(cb(err));
      };
    })(this));
  } else {
    return __iced_k();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              } else {

(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
  });
  asp.<span class="apidocCodeKeywordSpan">progress</span>({
    what: &#x22;mr&#x22;,
    i: i,
    total: iter,
    p: p
  }, esc(__iced_deferrals.defer({
    lineno: 122
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ASP.prototype.progress_hook" id="apidoc.element.kbpgp.ASP.prototype.progress_hook">
        function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>progress_hook
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress_hook = function () {
  return this._progress_hook;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ASP.prototype.section" id="apidoc.element.kbpgp.ASP.prototype.section">
        function <span class="apidocSignatureSpan">kbpgp.ASP.prototype.</span>section
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">section = function (s) {
  this._section = s;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              (function(__iced_k) {
__iced_deferrals = new iced.Deferrals(__iced_k, {
  parent: ___iced_passed_deferral,
  filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
  funcname: &#x22;Pair.generate&#x22;
});
random_prime({
  asp: asp.<span class="apidocCodeKeywordSpan">section</span>(&#x27;p&#x27;),
  e: e,
  nbits: nbits,
  iters: iters
}, esc(__iced_deferrals.defer({
  assign_fn: (function() {
    return function() {
      return p = arguments[0];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.Buffer" id="apidoc.module.kbpgp.Buffer">module kbpgp.Buffer</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.Buffer" id="apidoc.element.kbpgp.Buffer.Buffer">
        function <span class="apidocSignatureSpan">kbpgp.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === &#x27;number&#x27;) {
    if (typeof encodingOrOffset === &#x27;string&#x27;) {
      throw new Error(
        &#x27;If encoding is specified then the first argument must be a string&#x27;
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.alloc" id="apidoc.element.kbpgp.Buffer.alloc">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>alloc
        <span class="apidocSignatureSpan">(size, fill, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (size, fill, encoding) {
  assertSize(size);
  if (size &#x3e; 0 &#x26;&#x26; fill !== undefined) {
    // Since we are filling anyway, don&#x27;t zero fill initially.
    // Only pay attention to encoding if it&#x27;s a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    if (typeof encoding !== &#x27;string&#x27;)
      encoding = undefined;
    return createUnsafeBuffer(size).fill(fill, encoding);
  }
  return new FastBuffer(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.allocUnsafe" id="apidoc.element.kbpgp.Buffer.allocUnsafe">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>allocUnsafe
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocUnsafe = function (size) {
  assertSize(size);
  return allocate(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.allocUnsafeSlow" id="apidoc.element.kbpgp.Buffer.allocUnsafeSlow">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>allocUnsafeSlow
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocUnsafeSlow = function (size) {
  assertSize(size);
  return createUnsafeBuffer(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.byteLength" id="apidoc.element.kbpgp.Buffer.byteLength">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>byteLength
        <span class="apidocSignatureSpan">(string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function byteLength(string, encoding) {
  if (typeof string !== &#x27;string&#x27;) {
    if (ArrayBuffer.isView(string) || isArrayBuffer(string) ||
        isSharedArrayBuffer(string)) {
      return string.byteLength;
    }

    string = &#x27;&#x27; + string;
  }

  var len = string.length;
  if (len === 0)
    return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case &#x27;ascii&#x27;:
      case &#x27;latin1&#x27;:
      case &#x27;binary&#x27;:
        return len;

      case &#x27;utf8&#x27;:
      case &#x27;utf-8&#x27;:
      case undefined:
        return binding.byteLengthUtf8(string);

      case &#x27;ucs2&#x27;:
      case &#x27;ucs-2&#x27;:
      case &#x27;utf16le&#x27;:
      case &#x27;utf-16le&#x27;:
        return len * 2;

      case &#x27;hex&#x27;:
        return len &#x3e;&#x3e;&#x3e; 1;

      case &#x27;base64&#x27;:
        return base64ByteLength(string, len);

      default:
        // The C++ binding defaulted to UTF8, we should too.
        if (loweredCase)
          return binding.byteLengthUtf8(string);

        encoding = (&#x27;&#x27; + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fta = new Avg();

fermat2_test = function(n) {
  var Bl, bl, i, ret, t, _i;
  t = nbv(1);
  bl = n.bitLength();
  bl--;
  Bl = n.<span class="apidocCodeKeywordSpan">byteLength</span>();
  for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
    t = t.square();
    if (t.byteLength() &#x3e; Bl) {
      t = t.mod(n);
    }
    if (n.testBit(i)) {
      t = t.shiftLeft(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.compare" id="apidoc.element.kbpgp.Buffer.compare">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(a, b) {
  if (!(a instanceof Buffer) ||
      !(b instanceof Buffer)) {
    throw new TypeError(&#x27;Arguments must be Buffers&#x27;);
  }

  if (a === b) {
    return 0;
  }

  return binding.compare(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.concat" id="apidoc.element.kbpgp.Buffer.concat">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>concat
        <span class="apidocSignatureSpan">(list, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (list, length) {
  var i;
  if (!Array.isArray(list))
    throw new TypeError(&#x27;&#x22;list&#x22; argument must be an Array of Buffers&#x27;);

  if (list.length === 0)
    return new FastBuffer();

  if (length === undefined) {
    length = 0;
    for (i = 0; i &#x3c; list.length; i++)
      length += list[i].length;
  } else {
    length = length &#x3e;&#x3e;&#x3e; 0;
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i &#x3c; list.length; i++) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf))
      throw new TypeError(&#x27;&#x22;list&#x22; argument must be an Array of Buffers&#x27;);
    buf.copy(buffer, pos);
    pos += buf.length;
  }

  // Note: `length` is always equal to `buffer.length` at this point
  if (pos &#x3c; length) {
    // Zero-fill the remaining bytes if the specified `length` was more than
    // the actual total length, i.e. if we have some remaining allocated bytes
    // there were not initialized.
    buffer.fill(0, pos, length);
  }

  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return [null, new klass(d), orig_len - raw.length];
  }
};

BaseKey.prototype.serialize = function() {
  var e;
  return Buffer.<span class="apidocCodeKeywordSpan">concat</span>((function() {
    var _i, _len, _ref1, _results;
    _ref1 = this.ORDER;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
      e = _ref1[_i];
      _results.push(this[e].to_mpi_buffer());
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.from" id="apidoc.element.kbpgp.Buffer.from">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>from
        <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (value, encodingOrOffset, length) {
  if (typeof value === &#x27;number&#x27;)
    throw new TypeError(&#x27;&#x22;value&#x22; argument must not be a number&#x27;);

  if (isArrayBuffer(value) || isSharedArrayBuffer(value))
    return fromArrayBuffer(value, encodingOrOffset, length);

  if (typeof value === &#x27;string&#x27;)
    return fromString(value, encodingOrOffset);

  return fromObject(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.isBuffer" id="apidoc.element.kbpgp.Buffer.isBuffer">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>isBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBuffer(b) {
  return b instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
err = null;
if (Buffer.<span class="apidocCodeKeywordSpan">isBuffer</span>(sig)) {
  _ref1 = klass.read_sig_from_buf(sig), err = _ref1[0], sig = _ref1[1];
}
hash || (hash = hasher(data));
(function(_this) {
  return (function(__iced_k) {
    if (sig.length !== 2) {
      return __iced_k(err = new Error(&#x22;Need an [r,s] pair for a DSA-style signature&#x22;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.isEncoding" id="apidoc.element.kbpgp.Buffer.isEncoding">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.</span>isEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEncoding = function (encoding) {
  return typeof encoding === &#x27;string&#x27; &#x26;&#x26;
         typeof internalUtil.normalizeEncoding(encoding) === &#x27;string&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.Buffer.prototype" id="apidoc.module.kbpgp.Buffer.prototype">module kbpgp.Buffer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.asciiSlice" id="apidoc.element.kbpgp.Buffer.prototype.asciiSlice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>asciiSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asciiSlice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.asciiWrite" id="apidoc.element.kbpgp.Buffer.prototype.asciiWrite">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>asciiWrite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asciiWrite() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.base64Slice" id="apidoc.element.kbpgp.Buffer.prototype.base64Slice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>base64Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.base64Write" id="apidoc.element.kbpgp.Buffer.prototype.base64Write">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>base64Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.compare" id="apidoc.element.kbpgp.Buffer.prototype.compare">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>compare
        <span class="apidocSignatureSpan">(target, start, end, thisStart, thisEnd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(target, start, end, thisStart, thisEnd) {

  if (!(target instanceof Buffer))
    throw new TypeError(&#x27;Argument must be a Buffer&#x27;);
  if (arguments.length === 1)
    return compare_(this, target);

  if (start === undefined)
    start = 0;
  else if (start &#x3c; 0)
    throw new RangeError(&#x27;out of range index&#x27;);
  else
    start &#x3e;&#x3e;&#x3e;= 0;

  if (end === undefined)
    end = target.length;
  else if (end &#x3e; target.length)
    throw new RangeError(&#x27;out of range index&#x27;);
  else
    end &#x3e;&#x3e;&#x3e;= 0;

  if (thisStart === undefined)
    thisStart = 0;
  else if (thisStart &#x3c; 0)
    throw new RangeError(&#x27;out of range index&#x27;);
  else
    thisStart &#x3e;&#x3e;&#x3e;= 0;

  if (thisEnd === undefined)
    thisEnd = this.length;
  else if (thisEnd &#x3e; this.length)
    throw new RangeError(&#x27;out of range index&#x27;);
  else
    thisEnd &#x3e;&#x3e;&#x3e;= 0;

  if (thisStart &#x3e;= thisEnd)
    return (start &#x3e;= end ? 0 : -1);
  else if (start &#x3e;= end)
    return 1;

  return compareOffset(this, target, start, thisStart, end, thisEnd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.copy" id="apidoc.element.kbpgp.Buffer.prototype.copy">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copy() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})();

lifespan_from_keywrapper_and_time = function(_arg) {
  var key_wrapper, ret, time;
  key_wrapper = _arg.key_wrapper, time = _arg.time;
  ret = key_wrapper.lifespan;
  if (time != null) {
    ret = ret.<span class="apidocCodeKeywordSpan">copy</span>();
    ret.generated = time;
  }
  return ret;
};

PgpEngine = (function(_super) {
  __extends(PgpEngine, _super);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.equals" id="apidoc.element.kbpgp.Buffer.prototype.equals">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>equals
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(b) {
  if (!(b instanceof Buffer))
    throw new TypeError(&#x27;Argument must be a Buffer&#x27;);

  if (this === b)
    return true;

  return binding.compare(this, b) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.<span class="apidocCodeKeywordSpan">equals</span>(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
  return cb(err);
};

return Pub;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.fill" id="apidoc.element.kbpgp.Buffer.prototype.fill">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>fill
        <span class="apidocSignatureSpan">(val, start, end, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === &#x27;string&#x27;) {
    if (typeof start === &#x27;string&#x27;) {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === &#x27;string&#x27;) {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined &#x26;&#x26; typeof encoding !== &#x27;string&#x27;) {
      throw new TypeError(&#x27;encoding must be a string&#x27;);
    }
    var normalizedEncoding = internalUtil.normalizeEncoding(encoding);
    if (normalizedEncoding === undefined) {
      throw new TypeError(&#x27;Unknown encoding: &#x27; + encoding);
    }

    if (val.length === 0) {
      // Previously, if val === &#x27;&#x27;, the Buffer would not fill,
      // which is rather surprising.
      val = 0;
    } else if (val.length === 1) {
      var code = val.charCodeAt(0);
      if ((normalizedEncoding === &#x27;utf8&#x27; &#x26;&#x26; code &#x3c; 128) ||
          normalizedEncoding === &#x27;latin1&#x27;) {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === &#x27;number&#x27;) {
    val = val &#x26; 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start &#x3c; 0 || end &#x3e; this.length)
    throw new RangeError(&#x27;Out of range index&#x27;);

  if (end &#x3c;= start)
    return this;

  start = start &#x3e;&#x3e;&#x3e; 0;
  end = end === undefined ? this.length : end &#x3e;&#x3e;&#x3e; 0;

  binding.fill(this, val, start, end, encoding);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.hexSlice" id="apidoc.element.kbpgp.Buffer.prototype.hexSlice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>hexSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexSlice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.hexWrite" id="apidoc.element.kbpgp.Buffer.prototype.hexWrite">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>hexWrite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexWrite() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.includes" id="apidoc.element.kbpgp.Buffer.prototype.includes">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>includes
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.indexOf" id="apidoc.element.kbpgp.Buffer.prototype.indexOf">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.inspect" id="apidoc.element.kbpgp.Buffer.prototype.inspect">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inspect() {
  var str = &#x27;&#x27;;
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length &#x3e; 0) {
    str = this.toString(&#x27;hex&#x27;, 0, max).match(/.{2}/g).join(&#x27; &#x27;);
    if (this.length &#x3e; max)
      str += &#x27; ... &#x27;;
  }
  return &#x27;&#x3c;&#x27; + this.constructor.name + &#x27; &#x27; + str + &#x27;&#x3e;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.lastIndexOf" id="apidoc.element.kbpgp.Buffer.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.latin1Slice" id="apidoc.element.kbpgp.Buffer.prototype.latin1Slice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>latin1Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function latin1Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.latin1Write" id="apidoc.element.kbpgp.Buffer.prototype.latin1Write">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>latin1Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function latin1Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readDoubleBE" id="apidoc.element.kbpgp.Buffer.prototype.readDoubleBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readDoubleBE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDoubleBE(offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleBE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readDoubleLE" id="apidoc.element.kbpgp.Buffer.prototype.readDoubleLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readDoubleLE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDoubleLE(offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleLE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readFloatBE" id="apidoc.element.kbpgp.Buffer.prototype.readFloatBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readFloatBE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloatBE(offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatBE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readFloatLE" id="apidoc.element.kbpgp.Buffer.prototype.readFloatLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readFloatLE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloatLE(offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatLE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readInt16BE" id="apidoc.element.kbpgp.Buffer.prototype.readInt16BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt16BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt16BE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] &#x3c;&#x3c; 8);
  return (val &#x26; 0x8000) ? val | 0xFFFF0000 : val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readInt16LE" id="apidoc.element.kbpgp.Buffer.prototype.readInt16LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt16LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt16LE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] &#x3c;&#x3c; 8);
  return (val &#x26; 0x8000) ? val | 0xFFFF0000 : val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readInt32BE" id="apidoc.element.kbpgp.Buffer.prototype.readInt32BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt32BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32BE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset] &#x3c;&#x3c; 24) |
      (this[offset + 1] &#x3c;&#x3c; 16) |
      (this[offset + 2] &#x3c;&#x3c; 8) |
      (this[offset + 3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readInt32LE" id="apidoc.element.kbpgp.Buffer.prototype.readInt32LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt32LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32LE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset]) |
      (this[offset + 1] &#x3c;&#x3c; 8) |
      (this[offset + 2] &#x3c;&#x3c; 16) |
      (this[offset + 3] &#x3c;&#x3c; 24);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readInt8" id="apidoc.element.kbpgp.Buffer.prototype.readInt8">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readInt8
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt8 = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  var val = this[offset];
  return !(val &#x26; 0x80) ? val : (0xff - val + 1) * -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readIntBE" id="apidoc.element.kbpgp.Buffer.prototype.readIntBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readIntBE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIntBE = function (offset, byteLength, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i &#x3e; 0 &#x26;&#x26; (mul *= 0x100))
    val += this[offset + --i] * mul;
  mul *= 0x80;

  if (val &#x3e;= mul)
    val -= Math.pow(2, 8 * byteLength);

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readIntLE" id="apidoc.element.kbpgp.Buffer.prototype.readIntLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readIntLE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIntLE = function (offset, byteLength, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i &#x3c; byteLength &#x26;&#x26; (mul *= 0x100))
    val += this[offset + i] * mul;
  mul *= 0x80;

  if (val &#x3e;= mul)
    val -= Math.pow(2, 8 * byteLength);

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUInt16BE" id="apidoc.element.kbpgp.Buffer.prototype.readUInt16BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt16BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt16BE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return (this[offset] &#x3c;&#x3c; 8) | this[offset + 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  exports.emsa_pkcs1_decode = emsa_pkcs1_decode = function(v, hasher) {
var err, h, header, i, ret;
err = ret = null;
i = 0;
if (v.length &#x3c; 2) {
  err = new Error(&#x22;signature was way too short: &#x3c; 2 bytes&#x22;);
} else {
  if (v.<span class="apidocCodeKeywordSpan">readUInt16BE</span>(0) !== 0x0001) {
    err = new Error(&#x22;Sig verify error: Didn&#x27;t get two-byte header 0x00 0x01&#x22;);
  } else {
    i = 2;
    while (i &#x3c; v.length &#x26;&#x26; (v.readUInt8(i) === 0xff)) {
      i++;
    }
    if (i &#x3e;= v.length || v.readUInt8(i) !== 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUInt16LE" id="apidoc.element.kbpgp.Buffer.prototype.readUInt16LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt16LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt16LE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] &#x3c;&#x3c; 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUInt32BE" id="apidoc.element.kbpgp.Buffer.prototype.readUInt32BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt32BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt32BE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] &#x3c;&#x3c; 16) |
      (this[offset + 2] &#x3c;&#x3c; 8) |
      this[offset + 3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.i += 2;
  this.check();
  return ret;
};

SlicerBuffer.prototype.read_uint32 = function() {
  var ret;
  ret = this.buf.<span class="apidocCodeKeywordSpan">readUInt32BE</span>(this.i);
  this.i += 4;
  this.check();
  return ret;
};

SlicerBuffer.prototype.read_buffer_at_most = function(l) {
  return this.read_buffer(Math.min(l, this.rem()));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUInt32LE" id="apidoc.element.kbpgp.Buffer.prototype.readUInt32LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt32LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt32LE = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] &#x3c;&#x3c; 8) |
      (this[offset + 2] &#x3c;&#x3c; 16)) +
      (this[offset + 3] * 0x1000000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUInt8" id="apidoc.element.kbpgp.Buffer.prototype.readUInt8">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUInt8
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt8 = function (offset, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (v.length &#x3c; 2) {
  err = new Error(&#x22;signature was way too short: &#x3c; 2 bytes&#x22;);
} else {
  if (v.readUInt16BE(0) !== 0x0001) {
    err = new Error(&#x22;Sig verify error: Didn&#x27;t get two-byte header 0x00 0x01&#x22;);
  } else {
    i = 2;
    while (i &#x3c; v.length &#x26;&#x26; (v.<span class="apidocCodeKeywordSpan">readUInt8</span>(i) === 0xff)) {
      i++;
    }
    if (i &#x3e;= v.length || v.readUInt8(i) !== 0) {
      err = new Error(&#x22;Sig verify error: Missed the 0x0 separator&#x22;);
    } else {
      i++;
      header = hash_headers[hasher.algname];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUIntBE" id="apidoc.element.kbpgp.Buffer.prototype.readUIntBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUIntBE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUIntBE = function (offset, byteLength, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength &#x3e; 0 &#x26;&#x26; (mul *= 0x100))
    val += this[offset + --byteLength] * mul;

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.readUIntLE" id="apidoc.element.kbpgp.Buffer.prototype.readUIntLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>readUIntLE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUIntLE = function (offset, byteLength, noAssert) {
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i &#x3c; byteLength &#x26;&#x26; (mul *= 0x100))
    val += this[offset + i] * mul;

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.slice" id="apidoc.element.kbpgp.Buffer.prototype.slice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>slice
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slice(start, end) {
  const srcLength = this.length;
  start = adjustOffset(start, srcLength);
  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;
  const newLength = end &#x3e; start ? end - start : 0;
  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _j, _results;
  _results = [];
  for (i = _j = 0; 0 &#x3c;= start ? _j &#x3c; start : _j &#x3e; start; i = 0 &#x3c;= start ? ++_j : --_j) {
    _results.push(0);
  }
  return _results;
})());
_ref1 = str.<span class="apidocCodeKeywordSpan">slice</span>(start);
for (i = _j = _ref1.length - 1; _j &#x3e;= 0; i = _j += -1) {
  c = _ref1[i];
  if ((char_index = this.lookup[c]) == null) {
    throw new Error(&#x27;Value passed is not a valid BaseX string.&#x27;);
  }
  num = num.add(base.multiply(nbv(char_index)));
  base = base.multiply(this.basebn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.swap16" id="apidoc.element.kbpgp.Buffer.prototype.swap16">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap16() {
  // For Buffer.length &#x3c; 128, it&#x27;s generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 2 !== 0)
    throw new RangeError(&#x27;Buffer size must be a multiple of 16-bits&#x27;);
  if (len &#x3c; 128) {
    for (var i = 0; i &#x3c; len; i += 2)
      swap(this, i, i + 1);
    return this;
  }
  return swap16n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.swap32" id="apidoc.element.kbpgp.Buffer.prototype.swap32">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap32() {
  // For Buffer.length &#x3c; 192, it&#x27;s generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 4 !== 0)
    throw new RangeError(&#x27;Buffer size must be a multiple of 32-bits&#x27;);
  if (len &#x3c; 192) {
    for (var i = 0; i &#x3c; len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  }
  return swap32n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.swap64" id="apidoc.element.kbpgp.Buffer.prototype.swap64">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>swap64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap64() {
  // For Buffer.length &#x3c; 192, it&#x27;s generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 8 !== 0)
    throw new RangeError(&#x27;Buffer size must be a multiple of 64-bits&#x27;);
  if (len &#x3c; 192) {
    for (var i = 0; i &#x3c; len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  }
  return swap64n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.toJSON" id="apidoc.element.kbpgp.Buffer.prototype.toJSON">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this.length) {
    const data = [];
    for (var i = 0; i &#x3c; this.length; ++i)
      data[i] = this[i];
    return { type: &#x27;Buffer&#x27;, data };
  } else {
    return { type: &#x27;Buffer&#x27;, data: [] };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.toString" id="apidoc.element.kbpgp.Buffer.prototype.toString">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  let result;
  if (arguments.length === 0) {
    result = this.utf8Slice(0, this.length);
  } else {
    result = slowToString.apply(this, arguments);
  }
  if (result === undefined)
    throw new Error(&#x27;&#x22;toString()&#x22; failed&#x27;);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  ClearSigner = (function() {
function ClearSigner(_arg) {
  this.msg = _arg.msg, this.signing_key = _arg.signing_key;
}

ClearSigner.prototype._fix_msg = function(cb) {
  this._cleartext = input_to_cleartext(this.msg.<span class="apidocCodeKeywordSpan">toString</span>(&#x27;utf8&#x27;));
  return cb(null);
};

ClearSigner.prototype._sign_msg = function(cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.ucs2Slice" id="apidoc.element.kbpgp.Buffer.prototype.ucs2Slice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>ucs2Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ucs2Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.ucs2Write" id="apidoc.element.kbpgp.Buffer.prototype.ucs2Write">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>ucs2Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ucs2Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.utf8Slice" id="apidoc.element.kbpgp.Buffer.prototype.utf8Slice">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>utf8Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.utf8Write" id="apidoc.element.kbpgp.Buffer.prototype.utf8Write">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>utf8Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.write" id="apidoc.element.kbpgp.Buffer.prototype.write">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>write
        <span class="apidocSignatureSpan">(string, offset, length, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (string, offset, length, encoding) {
  // Buffer#write(string);
  if (offset === undefined) {
    encoding = &#x27;utf8&#x27;;
    length = this.length;
    offset = 0;

  // Buffer#write(string, encoding)
  } else if (length === undefined &#x26;&#x26; typeof offset === &#x27;string&#x27;) {
    encoding = offset;
    length = this.length;
    offset = 0;

  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset &#x3e;&#x3e;&#x3e; 0;
    if (isFinite(length)) {
      length = length &#x3e;&#x3e;&#x3e; 0;
      if (encoding === undefined)
        encoding = &#x27;utf8&#x27;;
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    // if someone is still calling the obsolete form of write(), tell them.
    // we don&#x27;t want eg buf.write(&#x22;foo&#x22;, &#x22;utf8&#x22;, 10) to silently turn into
    // buf.write(&#x22;foo&#x22;, &#x22;utf8&#x22;), so we can&#x27;t ignore extra args
    throw new Error(&#x27;Buffer.write(string, encoding, offset[, length]) &#x27; +
                    &#x27;is no longer supported&#x27;);
  }

  var remaining = this.length - offset;
  if (length === undefined || length &#x3e; remaining)
    length = remaining;

  if (string.length &#x3e; 0 &#x26;&#x26; (length &#x3c; 0 || offset &#x3c; 0))
    throw new RangeError(&#x27;Attempt to write outside buffer bounds&#x27;);

  if (!encoding)
    encoding = &#x27;utf8&#x27;;

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case &#x27;hex&#x27;:
        return this.hexWrite(string, offset, length);

      case &#x27;utf8&#x27;:
      case &#x27;utf-8&#x27;:
        return this.utf8Write(string, offset, length);

      case &#x27;ascii&#x27;:
        return this.asciiWrite(string, offset, length);

      case &#x27;latin1&#x27;:
      case &#x27;binary&#x27;:
        return this.latin1Write(string, offset, length);

      case &#x27;base64&#x27;:
        // Warning: maxLength not taken into account in base64Write
        return this.base64Write(string, offset, length);

      case &#x27;ucs2&#x27;:
      case &#x27;ucs-2&#x27;:
      case &#x27;utf16le&#x27;:
      case &#x27;utf-16le&#x27;:
        return this.ucs2Write(string, offset, length);

      default:
        if (loweredCase)
          throw new TypeError(&#x27;Unknown encoding: &#x27; + encoding);
        encoding = (&#x27;&#x27; + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sp.push(l.to_signature_payload());
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._frame_literals&#x22;
  });
  l.<span class="apidocCodeKeywordSpan">write</span>(esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return p = arguments[0];
      };
    })(),
    lineno: 51
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeDoubleBE" id="apidoc.element.kbpgp.Buffer.prototype.writeDoubleBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeDoubleBE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDoubleBE(val, offset, noAssert) {
  val = +val;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    binding.writeDoubleBE(this, val, offset);
  else
    binding.writeDoubleBE(this, val, offset, true);
  return offset + 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeDoubleLE" id="apidoc.element.kbpgp.Buffer.prototype.writeDoubleLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeDoubleLE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDoubleLE(val, offset, noAssert) {
  val = +val;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    binding.writeDoubleLE(this, val, offset);
  else
    binding.writeDoubleLE(this, val, offset, true);
  return offset + 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeFloatBE" id="apidoc.element.kbpgp.Buffer.prototype.writeFloatBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeFloatBE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloatBE(val, offset, noAssert) {
  val = +val;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    binding.writeFloatBE(this, val, offset);
  else
    binding.writeFloatBE(this, val, offset, true);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeFloatLE" id="apidoc.element.kbpgp.Buffer.prototype.writeFloatLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeFloatLE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloatLE(val, offset, noAssert) {
  val = +val;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    binding.writeFloatLE(this, val, offset);
  else
    binding.writeFloatLE(this, val, offset, true);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeInt16BE" id="apidoc.element.kbpgp.Buffer.prototype.writeInt16BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt16BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt16BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset + 1] = value;
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeInt16LE" id="apidoc.element.kbpgp.Buffer.prototype.writeInt16LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt16LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt16LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value;
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 8);
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeInt32BE" id="apidoc.element.kbpgp.Buffer.prototype.writeInt32BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt32BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = (value &#x3e;&#x3e;&#x3e; 24);
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 16);
  this[offset + 2] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset + 3] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeInt32LE" id="apidoc.element.kbpgp.Buffer.prototype.writeInt32LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt32LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value;
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset + 2] = (value &#x3e;&#x3e;&#x3e; 16);
  this[offset + 3] = (value &#x3e;&#x3e;&#x3e; 24);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeInt8" id="apidoc.element.kbpgp.Buffer.prototype.writeInt8">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeInt8
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt8 = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80);
  this[offset] = value;
  return offset + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeIntBE" id="apidoc.element.kbpgp.Buffer.prototype.writeIntBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeIntBE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIntBE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value;
  while (--i &#x3e;= 0 &#x26;&#x26; (mul *= 0x100)) {
    if (value &#x3c; 0 &#x26;&#x26; sub === 0 &#x26;&#x26; this[offset + i + 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) &#x3e;&#x3e; 0) - sub;
  }

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeIntLE" id="apidoc.element.kbpgp.Buffer.prototype.writeIntLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeIntLE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIntLE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value;
  while (++i &#x3c; byteLength &#x26;&#x26; (mul *= 0x100)) {
    if (value &#x3c; 0 &#x26;&#x26; sub === 0 &#x26;&#x26; this[offset + i - 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) &#x3e;&#x3e; 0) - sub;
  }

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt16BE" id="apidoc.element.kbpgp.Buffer.prototype.writeUInt16BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt16BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt16BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset + 1] = value;
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt16LE" id="apidoc.element.kbpgp.Buffer.prototype.writeUInt16LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt16LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt16LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value;
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 8);
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt32BE" id="apidoc.element.kbpgp.Buffer.prototype.writeUInt32BE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt32BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt32BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = (value &#x3e;&#x3e;&#x3e; 24);
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 16);
  this[offset + 2] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset + 3] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt32LE" id="apidoc.element.kbpgp.Buffer.prototype.writeUInt32LE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt32LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt32LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = (value &#x3e;&#x3e;&#x3e; 24);
  this[offset + 2] = (value &#x3e;&#x3e;&#x3e; 16);
  this[offset + 1] = (value &#x3e;&#x3e;&#x3e; 8);
  this[offset] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUInt8" id="apidoc.element.kbpgp.Buffer.prototype.writeUInt8">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUInt8
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt8 = function (value, offset, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value;
  return offset + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUIntBE" id="apidoc.element.kbpgp.Buffer.prototype.writeUIntBE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUIntBE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUIntBE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value;
  while (--i &#x3e;= 0 &#x26;&#x26; (mul *= 0x100))
    this[offset + i] = (value / mul) &#x3e;&#x3e;&#x3e; 0;

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Buffer.prototype.writeUIntLE" id="apidoc.element.kbpgp.Buffer.prototype.writeUIntLE">
        function <span class="apidocSignatureSpan">kbpgp.Buffer.prototype.</span>writeUIntLE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUIntLE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &#x3e;&#x3e;&#x3e; 0;
  byteLength = byteLength &#x3e;&#x3e;&#x3e; 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value;
  while (++i &#x3c; byteLength &#x26;&#x26; (mul *= 0x100))
    this[offset + i] = (value / mul) &#x3e;&#x3e;&#x3e; 0;

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.Burner" id="apidoc.module.kbpgp.Burner">module kbpgp.Burner</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.Burner.Burner" id="apidoc.element.kbpgp.Burner.Burner">
        function <span class="apidocSignatureSpan">kbpgp.</span>Burner
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Burner(_arg) {
  var asp, encrypt_for, encryption_key, sign_with, signing_key;
  this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key =
_arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;
  Burner.__super__.constructor.call(this, {
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp
  });
  this.packets = [];
  this.opts || (this.opts = {});
  this.signed_payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.Burner.__super__" id="apidoc.module.kbpgp.Burner.__super__">module kbpgp.Burner.__super__</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.Burner.__super__._assert_one" id="apidoc.element.kbpgp.Burner.__super__._assert_one">
        function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_assert_one
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_assert_one = function (cb) {
  var err;
  err = null;
  if (!(this.signing_key != null) &#x26;&#x26; !(this.encryption_keys != null)) {
    err = new Error(&#x22;need either an encryption or signing key, or both&#x22;);
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
      funcname: &#x22;BaseBurner._find_keys&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_assert_one</span>(esc(__iced_deferrals.defer({
      lineno: 19
    })));
    __iced_deferrals._fulfill();
  })(function() {
    return cb(null);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.__super__._find_encryption_key" id="apidoc.element.kbpgp.Burner.__super__._find_encryption_key">
        function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_encryption_key
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find_encryption_key = function (cb) {
  var arrayize, count_true, err, f, i, k, _i, _len, _ref;
  err = null;
  count_true = function() {
    var e, i, v, _i, _len;
    v = 1 &#x3c;= arguments.length ? __slice.call(arguments, 0) : [];
    i = 0;
    for (_i = 0, _len = v.length; _i &#x3c; _len; _i++) {
      e = v[_i];
      if (e) {
        i++;
      }
    }
    return i;
  };
  arrayize = function(e) {
    if (e == null) {
      return [];
    } else if (typeof e === &#x27;object&#x27; &#x26;&#x26; Array.isArray(e)) {
      return e;
    } else {
      return [e];
    }
  };
  if (count_true(this.encrypt_for != null, this.encryption_key != null, this.encryption_keys != null) &#x3e; 1) {
    err = new Error(&#x22;specify only one of `encrypt_for`, `encryption_keys` and `encryption_key`&#x22;);
  } else if (this.encrypt_for != null) {
    this.encryption_keys = [];
    _ref = (this.encrypt_for = arrayize(this.encrypt_for));
    for (i = _i = 0, _len = _ref.length; _i &#x3c; _len; i = ++_i) {
      f = _ref[i];
      if ((k = f.find_crypt_pgp_key()) != null) {
        this.encryption_keys.push(k);
      } else {
        err = new Error(&#x22;cannot encrypt with the given KeyManager (i=&#x22; + i + &#x22;)&#x22;);
        break;
      }
    }
  } else if (this.encryption_key != null) {
    this.encryption_keys = [this.encryption_key];
  } else if (this.encryption_keys != null) {
    this.encryption_keys = arrayize(this.encryption_keys);
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
    funcname: &#x22;BaseBurner._find_keys&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_find_encryption_key</span>(esc(__iced_deferrals.defer({
    lineno: 18
  })));
  __iced_deferrals._fulfill();
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.__super__._find_keys" id="apidoc.element.kbpgp.Burner.__super__._find_keys">
        function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_keys
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find_keys = function (cb) {
  var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;find_keys&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
        funcname: &#x22;BaseBurner._find_keys&#x22;
      });
      _this._find_signing_key(esc(__iced_deferrals.defer({
        lineno: 17
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
          funcname: &#x22;BaseBurner._find_keys&#x22;
        });
        _this._find_encryption_key(esc(__iced_deferrals.defer({
          lineno: 18
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
            funcname: &#x22;BaseBurner._find_keys&#x22;
          });
          _this._assert_one(esc(__iced_deferrals.defer({
            lineno: 19
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner.burn&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_find_keys</span>(esc(__iced_deferrals.defer({
      lineno: 181
    })));
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    (function(__iced_k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.__super__._find_signing_key" id="apidoc.element.kbpgp.Burner.__super__._find_signing_key">
        function <span class="apidocSignatureSpan">kbpgp.Burner.__super__.</span>_find_signing_key
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find_signing_key = function (cb) {
  var err;
  err = null;
  if ((this.sign_with != null) &#x26;&#x26; (this.signing_key != null)) {
    err = new Error(&#x22;specify either `sign_with` or `signing_key` but not both&#x22;);
  } else if ((this.sign_with != null) &#x26;&#x26; ((this.signing_key = this.sign_with.find_signing_pgp_key()) == null)) {
    err = new Error(&#x22;cannot sign with the given KeyManager&#x22;);
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced&#x22;,
      funcname: &#x22;BaseBurner._find_keys&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_find_signing_key</span>(esc(__iced_deferrals.defer({
      lineno: 17
    })));
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    (function(__iced_k) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.Burner.prototype" id="apidoc.module.kbpgp.Burner.prototype">module kbpgp.Burner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._compress" id="apidoc.element.kbpgp.Burner.prototype._compress">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_compress
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compress = function (cb) {
  var esc, inflated, opkt, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_compress&#x22;);
  inflated = this.collect_packets();
  pkt = new Compressed({
    algo: C.compression.zlib,
    inflated: inflated
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._compress&#x22;
      });
      _this.asp.progress({
        what: &#x27;compress&#x27;,
        i: 0,
        total: 1
      }, esc(__iced_deferrals.defer({
        lineno: 94
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner._compress&#x22;
        });
        pkt.write(esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return opkt = arguments[0];
            };
          })(),
          lineno: 95
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
            funcname: &#x22;Burner._compress&#x22;
          });
          _this.asp.progress({
            what: &#x27;compress&#x27;,
            i: 1,
            total: 1
          }, esc(__iced_deferrals.defer({
            lineno: 96
          })));
          __iced_deferrals._fulfill();
        })(function() {
          _this.packets.push(opkt);
          return cb(null);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            })(function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner.burn&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_compress</span>(esc(__iced_deferrals.defer({
    lineno: 185
  })));
  __iced_deferrals._fulfill();
})(function() {
  (function(__iced_k) {
    if (_this.encryption_keys != null) {
      (function(__iced_k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._encrypt" id="apidoc.element.kbpgp.Burner.prototype._encrypt">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_encrypt = function (cb) {
  var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_encrypt&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._encrypt&#x22;
      });
      _this._make_session_key(esc(__iced_deferrals.defer({
        lineno: 168
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner._encrypt&#x22;
        });
        _this._encrypt_session_key(esc(__iced_deferrals.defer({
          lineno: 169
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
            funcname: &#x22;Burner._encrypt&#x22;
          });
          _this._encrypt_payload(esc(__iced_deferrals.defer({
            lineno: 170
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (_this.encryption_keys != null) {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner.burn&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_encrypt</span>(esc(__iced_deferrals.defer({
      lineno: 187
    })));
    __iced_deferrals._fulfill();
  })(__iced_k);
} else {
  return __iced_k();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._encrypt_payload" id="apidoc.element.kbpgp.Burner.prototype._encrypt_payload">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_payload
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_encrypt_payload = function (cb) {
  var asp, esc, pkt, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_encrypt_payload&#x22;);
  plaintext = this.collect_packets();
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._encrypt_payload&#x22;
      });
      SRF().random_bytes(_this._cipher.blockSize, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return prefixrandom = arguments[0];
          };
        })(),
        lineno: 155
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      pkt = new SEIPD({});
      asp = _this.asp.section(&#x27;encrypt payload&#x27;);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner._encrypt_payload&#x22;
        });
        pkt.encrypt({
          cipher: _this._cipher,
          plaintext: plaintext,
          prefixrandom: prefixrandom,
          asp: asp
        }, esc(__iced_deferrals.defer({
          lineno: 158
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
            funcname: &#x22;Burner._encrypt_payload&#x22;
          });
          pkt.write(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return pkt = arguments[0];
              };
            })(),
            lineno: 159
          })));
          __iced_deferrals._fulfill();
        })(function() {
          scrub_buffer(plaintext);
          _this.packets = _this._pkesks.concat([pkt]);
          return cb(null);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner._encrypt&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_encrypt_payload</span>(esc(__iced_deferrals.defer({
      lineno: 170
    })));
    __iced_deferrals._fulfill();
  })(function() {
    return cb(null);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._encrypt_session_key" id="apidoc.element.kbpgp.Burner.prototype._encrypt_session_key">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_session_key
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_encrypt_session_key = function (cb) {
  var esc, k, pkesk, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;_encrypt_session_key&#x22;);
  this._pkesks = [];
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref3, _results, _while;
      _ref3 = _this.encryption_keys;
      _len = _ref3.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          k = _ref3[_i];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
              funcname: &#x22;Burner._encrypt_session_key&#x22;
            });
            _this._encrypt_session_key_once(k, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return pkesk = arguments[0];
                };
              })(),
              lineno: 146
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(_this._pkesks.push(pkesk));
          });
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(null);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._encrypt&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_encrypt_session_key</span>(esc(__iced_deferrals.defer({
    lineno: 169
  })));
  __iced_deferrals._fulfill();
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._encrypt_session_key_once" id="apidoc.element.kbpgp.Burner.prototype._encrypt_session_key_once">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_encrypt_session_key_once
        <span class="apidocSignatureSpan">(encryption_key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_encrypt_session_key_once = function (encryption_key, cb) {
  var ekey, esc, fingerprint, key_id, payload, pkesk, pkt, pub_k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;_encrypt_session_key_once&#x22;);
  payload = export_key_pgp(this._cipher_algo, this._session_key);
  pub_k = encryption_key.key;
  fingerprint = encryption_key.get_fingerprint();
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._encrypt_session_key_once&#x22;
      });
      _this.asp.progress({
        what: &#x27;session key encrypt&#x27;,
        i: 0,
        total: 1
      }, esc(__iced_deferrals.defer({
        lineno: 122
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner._encrypt_session_key_once&#x22;
        });
        pub_k.pad_and_encrypt(payload, {
          fingerprint: fingerprint
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ekey = arguments[0];
            };
          })(),
          lineno: 123
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
            funcname: &#x22;Burner._encrypt_session_key_once&#x22;
          });
          _this.asp.progress({
            what: &#x27;session key encrypt&#x27;,
            i: 1,
            total: 1
          }, esc(__iced_deferrals.defer({
            lineno: 124
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if (_this.opts.hide) {
              key_id = dummy_key_id;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
                  funcname: &#x22;Burner._encrypt_session_key_once&#x22;
                });
                _this.asp.progress({
                  what: &#x27;hide encryption&#x27;,
                  i: 0,
                  total: 1
                }, esc(__iced_deferrals.defer({
                  lineno: 127
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  var _ref3, _ref4;
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
                    funcname: &#x22;Burner._encrypt_session_key_once&#x22;
                  });
                  ekey.hide({
                    max: (_ref3 = _this.opts.hide) != null ? _ref3.max : void 0,
                    slosh: (_ref4 = _this.opts.hide) != null ? _ref4.slosh : void 0,
                    key: pub_k
                  }, esc(__iced_deferrals.defer({
                    lineno: 128
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
                      funcname: &#x22;Burner._encrypt_session_key_once&#x22;
                    });
                    _this.asp.progress({
                      what: &#x27;hide encryption&#x27;, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
k = _ref3[_i];
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._encrypt_session_key&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_encrypt_session_key_once</span>(k, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return pkesk = arguments[0];
      };
    })(),
    lineno: 146
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._frame_literals" id="apidoc.element.kbpgp.Burner.prototype._frame_literals">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_frame_literals
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_frame_literals = function (cb) {
  var esc, l, p, sp, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_frame_literals&#x22;);
  sp = [];
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref3, _results, _while;
      _ref3 = _this.literals;
      _len = _ref3.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          l = _ref3[_i];
          sp.push(l.to_signature_payload());
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
              funcname: &#x22;Burner._frame_literals&#x22;
            });
            l.write(esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return p = arguments[0];
                };
              })(),
              lineno: 51
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(_this.packets.push(p));
          });
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      _this.signed_payload = Buffer.concat(sp);
      return cb(null);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner.burn&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_frame_literals</span>(esc(__iced_deferrals.defer({
    lineno: 182
  })));
  __iced_deferrals._fulfill();
})(function() {
  (function(__iced_k) {
    if (_this.signing_key != null) {
      (function(__iced_k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._make_session_key" id="apidoc.element.kbpgp.Burner.prototype._make_session_key">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_make_session_key
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_make_session_key = function (cb) {
  var ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  this._cipher_algo = C.symmetric_key_algorithms.AES256;
  this._cipher_info = get_cipher(this._cipher_algo);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._make_session_key&#x22;
      });
      SRF().random_bytes(_this._cipher_info.key_size, __iced_deferrals.defer({
        assign_fn: (function(__slot_1) {
          return function() {
            return __slot_1._session_key = arguments[0];
          };
        })(_this),
        lineno: 105
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      _this._cipher = new _this._cipher_info.klass(WordArray.from_buffer(_this._session_key));
      return cb(null);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner._encrypt&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_make_session_key</span>(esc(__iced_deferrals.defer({
      lineno: 168
    })));
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    (function(__iced_k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype._sign" id="apidoc.element.kbpgp.Burner.prototype._sign">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>_sign
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sign = function (cb) {
  var esc, fp, ops, ops_framed, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_sign&#x27;&#x22;);
  ops = new OnePassSignature({
    sig_type: C.sig_types.binary_doc,
    hasher: SHA512,
    sig_klass: this.signing_key.get_klass(),
    key_id: this.signing_key.get_key_id(),
    is_final: 1
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner._sign&#x22;
      });
      ops.write(esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return ops_framed = arguments[0];
          };
        })(),
        lineno: 67
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      sig = new Signature({
        type: C.sig_types.binary_doc,
        key: _this.signing_key.key,
        hashed_subpackets: [new CreationTime(unix_time())],
        unhashed_subpackets: [new Issuer(_this.signing_key.get_key_id())]
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner._sign&#x22;
        });
        _this.asp.progress({
          what: &#x27;sign&#x27;,
          i: 0,
          total: 1
        }, esc(__iced_deferrals.defer({
          lineno: 74
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
            funcname: &#x22;Burner._sign&#x22;
          });
          sig.write(_this.signed_payload, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return fp = arguments[0];
              };
            })(),
            lineno: 75
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
              funcname: &#x22;Burner._sign&#x22;
            });
            _this.asp.progress({
              what: &#x27;sign&#x27;,
              i: 1,
              total: 1
            }, esc(__iced_deferrals.defer({
              lineno: 76
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this.packets.unshift(ops_framed);
            _this.packets.push(fp);
            return cb(null);
          });
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (_this.signing_key != null) {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner.burn&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_sign</span>(esc(__iced_deferrals.defer({
      lineno: 184
    })));
    __iced_deferrals._fulfill();
  })(__iced_k);
} else {
  return __iced_k();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype.burn" id="apidoc.element.kbpgp.Burner.prototype.burn">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>burn
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">burn = function (cb) {
  var esc, output, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::burn&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;Burner.burn&#x22;
      });
      _this._find_keys(esc(__iced_deferrals.defer({
        lineno: 181
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
          funcname: &#x22;Burner.burn&#x22;
        });
        _this._frame_literals(esc(__iced_deferrals.defer({
          lineno: 182
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (_this.signing_key != null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
                funcname: &#x22;Burner.burn&#x22;
              });
              _this._sign(esc(__iced_deferrals.defer({
                lineno: 184
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
              funcname: &#x22;Burner.burn&#x22;
            });
            _this._compress(esc(__iced_deferrals.defer({
              lineno: 185
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (_this.encryption_keys != null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
                    funcname: &#x22;Burner.burn&#x22;
                  });
                  _this._encrypt(esc(__iced_deferrals.defer({
                    lineno: 187
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              output = Buffer.concat(_this.packets);
              return cb(null, output);
            });
          });
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;burn&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">burn</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return raw = arguments[1];
      };
    })(),
    lineno: 247
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype.collect_packets" id="apidoc.element.kbpgp.Burner.prototype.collect_packets">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>collect_packets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collect_packets = function () {
  var ret;
  ret = Buffer.concat(this.packets);
  this.packets = [];
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Burner.prototype._compress = function(cb) {
  var esc, inflated, opkt, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Burner::_compress&#x22;);
  inflated = this.<span class="apidocCodeKeywordSpan">collect_packets</span>();
  pkt = new Compressed({
    algo: C.compression.zlib,
    inflated: inflated
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype.constructor" id="apidoc.element.kbpgp.Burner.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Burner(_arg) {
  var asp, encrypt_for, encryption_key, sign_with, signing_key;
  this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key =
_arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;
  Burner.__super__.constructor.call(this, {
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp
  });
  this.packets = [];
  this.opts || (this.opts = {});
  this.signed_payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.Burner.prototype.scrub" id="apidoc.element.kbpgp.Burner.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.Burner.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.KeyFetcher" id="apidoc.module.kbpgp.KeyFetcher">module kbpgp.KeyFetcher</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.KeyFetcher.KeyFetcher" id="apidoc.element.kbpgp.KeyFetcher.KeyFetcher">
        function <span class="apidocSignatureSpan">kbpgp.</span>KeyFetcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyFetcher() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.KeyFetcher.prototype" id="apidoc.module.kbpgp.KeyFetcher.prototype">module kbpgp.KeyFetcher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.KeyFetcher.prototype.fetch" id="apidoc.element.kbpgp.KeyFetcher.prototype.fetch">
        function <span class="apidocSignatureSpan">kbpgp.KeyFetcher.prototype.</span>fetch
        <span class="apidocSignatureSpan">(ids, ops, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (ids, ops, cb) {
  return cb(new Error(&#x22;not implemented&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    obj.userid.most_recent_sig = obj.pair[0];
    ret.push(obj.userid);
  }
  return ret;
};

KeyManager.prototype.fetch = function(key_ids, flags, cb) {
  return this.pgp.<span class="apidocCodeKeywordSpan">fetch</span>(key_ids, flags, cb);
};

KeyManager.prototype.find_pgp_key = function(key_id) {
  return this.pgp.find_key(key_id);
};

KeyManager.prototype.find_pgp_key_material = function(key_id) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.KeyManager" id="apidoc.module.kbpgp.KeyManager">module kbpgp.KeyManager</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.KeyManager" id="apidoc.element.kbpgp.KeyManager.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  var signed;
  this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public
, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;
  this.pgp = new PgpEngine({
    primary: this.primary,
    subkeys: this.subkeys,
    userids: this.userids,
    user_attributes: this.user_attributes,
    key_manager: this
  });
  this.engines = [this.pgp];
  this._signed = signed != null ? signed : false;
  this.p3skb = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager._wrap_pgp" id="apidoc.element.kbpgp.KeyManager._wrap_pgp">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>_wrap_pgp
        <span class="apidocSignatureSpan">(klass, kmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_wrap_pgp = function (klass, kmp) {
  var _ref5;
  return new klass({
    key: kmp.key,
    lifespan: new Lifespan({
      generated: kmp.timestamp,
      expire_in: (_ref5 = kmp.get_expire_time()) != null ? _ref5.expire_in : void 0
    }),
    _pgp: kmp
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return __iced_k();
    }
  });
})(this)((function(_this) {
  return function() {
    if (err == null) {
      bundle = new KeyManager({
        primary: KeyManager.<span class="apidocCodeKeywordSpan">_wrap_pgp</span>(Primary, kb.primary),
        subkeys: (function() {
          var _i, _len, _ref6, _results;
          _ref6 = kb.subkeys;
          _results = [];
          for (_i = 0, _len = _ref6.length; _i &#x3c; _len; _i++) {
            k = _ref6[_i];
            _results.push(KeyManager._wrap_pgp(Subkey, k));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.generate" id="apidoc.element.kbpgp.KeyManager.generate">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var F, KEY_FLAGS_PRIMARY, KEY_FLAGS_STD, asp, bundle, curve_name, ecc, err, esc, expire_in, flags, gen, generated, i, nbits, nsubs
, primary, primary_flags, s, sub_flags, subkey, subkeys, subkeys_out, u, userid, userids, ___iced_passed_deferral, __iced_deferrals
, __iced_k, _i, _len;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  asp = _arg.asp, userid = _arg.userid, userids = _arg.userids, primary = _arg.primary, subkeys = _arg.subkeys, ecc = _arg.ecc,
sub_flags = _arg.sub_flags, nsubs = _arg.nsubs, primary_flags = _arg.primary_flags, nbits = _arg.nbits, expire_in = _arg.expire_in
, generated = _arg.generated, curve_name = _arg.curve_name;
  asp = ASP.make(asp);
  F = C.key_flags;
  KEY_FLAGS_STD = F.sign_data | F.encrypt_comm | F.encrypt_storage | F.auth;
  KEY_FLAGS_PRIMARY = KEY_FLAGS_STD | F.certify_keys;
  primary || (primary = {});
  primary.flags || (primary.flags = primary_flags || KEY_FLAGS_PRIMARY);
  primary.expire_in || (primary.expire_in = (expire_in != null ? expire_in.primary : void 0) || K.key_defaults.primary.expire_in
);
  primary.algo || (primary.algo = (ecc ? ECDSA : RSA));
  primary.nbits || (primary.nbits = nbits || K.key_defaults.primary.nbits[primary.algo.klass_name]);
  if (curve_name) {
    primary.curve_name = curve_name;
  }
  if ((nsubs != null) &#x26;&#x26; (sub_flags == null)) {
    sub_flags = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 &#x3c;= nsubs ? _i &#x3c; nsubs : _i &#x3e; nsubs; i = 0 &#x3c;= nsubs ? ++_i : --_i) {
        _results.push(KEY_FLAGS_STD);
      }
      return _results;
    })();
  }
  subkeys || (subkeys = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sub_flags.length; _i &#x3c; _len; _i++) {
      flags = sub_flags[_i];
      _results.push({
        flags: flags
      });
    }
    return _results;
  })());
  for (_i = 0, _len = subkeys.length; _i &#x3c; _len; _i++) {
    subkey = subkeys[_i];
    subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);
    subkey.flags || (subkey.flags = KEY_FLAGS_STD);
    subkey.algo || (subkey.algo = primary.algo.subkey_algo(subkey.flags));
    subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);
  }
  generated || (generated = unix_time());
  esc = make_esc(cb, &#x22;KeyManager::generate&#x22;);
  if (userid != null) {
    userids = [userid];
  }
  (function(_this) {
    return (function(__iced_k) {
      if ((userids != null) &#x26;&#x26; Array.isArray(userids)) {
        return __iced_k(userids = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = userids.length; _j &#x3c; _len1; _j++) {
            u = userids[_j];
            _results.push(new opkts.UserID(u));
          }
          return _results;
        })());
      } else {
        err = new Error(&#x22;Need either &#x27;userid&#x27; or &#x27;userids&#x27; specified as an array&#x22;);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.generate&#x22;
          });
          athrow(err, esc(__iced_deferrals.defer({
            lineno: 459
          })));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      gen = function(_arg1, cb) {
        var err, key, klass, lifespan, my_generated, params, primary, section, wrapper, ___iced_passed_deferral1, __iced_deferrals
, __iced_k;
        __iced_k = __iced_k_noop;
        ___iced_passed_deferral1 = iced.findDeferral(arguments);
        klass = _arg1.klass, section = _arg1.section, params = _arg1.params, primary = _arg1.primary;
        asp.section(section);
        (function(_this) {
          return (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral1,
              filename: &#x22;/home ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.generate_ecc" id="apidoc.element.kbpgp.KeyManager.generate_ecc">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate_ecc
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate_ecc = function (_arg, cb) {
  var F, asp, generated, primary, subkeys, userid, userids;
  asp = _arg.asp, userid = _arg.userid, userids = _arg.userids, generated = _arg.generated;
  F = C.key_flags;
  primary = {
    flags: F.certify_keys,
    nbits: 384,
    algo: ECDSA
  };
  subkeys = [
    {
      flags: F.encrypt_storage | F.encrypt_comm,
      nbits: 256
    }, {
      flags: F.sign_data | F.auth,
      nbits: 256
    }
  ];
  return KeyManager.generate({
    asp: asp,
    userid: userid,
    userids: userids,
    primary: primary,
    subkeys: subkeys,
    generated: generated
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.generate_rsa" id="apidoc.element.kbpgp.KeyManager.generate_rsa">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>generate_rsa
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate_rsa = function (_arg, cb) {
  var F, asp, primary, subkeys, userid, userids;
  asp = _arg.asp, userid = _arg.userid, userids = _arg.userids;
  F = C.key_flags;
  primary = {
    flags: F.certify_keys,
    nbits: 4096
  };
  subkeys = [
    {
      flags: F.encrypt_storage | F.encrypt_comm,
      nbits: 2048
    }, {
      flags: F.sign_data | F.auth,
      nbits: 2048
    }
  ];
  return KeyManager.generate({
    asp: asp,
    userid: userid,
    userids: userids,
    primary: primary,
    subkeys: subkeys
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.import_from_armored_pgp" id="apidoc.element.kbpgp.KeyManager.import_from_armored_pgp">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_armored_pgp
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_from_armored_pgp = function (_arg, cb) {
  var armored, asp, binary, err, msg, opts, packets, raw, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5
, _ref6;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, binary = _arg.binary, asp = _arg.asp, opts = _arg.opts;
  msg = binary;
  err = null;
  if (msg == null) {
    raw || (raw = armored);
    asp = ASP.make(asp);
    warnings = null;
    ret = null;
    _ref5 = decode(raw), err = _ref5[0], msg = _ref5[1];
    if (err == null) {
      if (!((_ref6 = msg.type) === C.message_types.public_key || _ref6 === C.message_types.private_key)) {
        err = new Error(&#x22;Wanted a public or private key; got: &#x22; + msg.type);
      }
    }
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.import_from_armored_pgp&#x22;
          });
          KeyManager.import_from_pgp_message({
            msg: msg,
            asp: asp,
            opts: opts
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                ret = arguments[1];
                warnings = arguments[2];
                return packets = arguments[3];
              };
            })(),
            lineno: 551
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (!(err != null)) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
              funcname: &#x22;KeyManager.import_from_armored_pgp&#x22;
            });
            ret.simple_unlock({}, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 557
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, ret, warnings, packets);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.merge_pgp_private&#x22;
  });
  KeyManager.<span class="apidocCodeKeywordSpan">import_from_armored_pgp</span>({
    armored: armored,
    raw: raw,
    asp: asp
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return b2 = arguments[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.import_from_p3skb" id="apidoc.element.kbpgp.KeyManager.import_from_p3skb">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_p3skb
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_from_p3skb = function (_arg, cb) {
  var armored, asp, err, km, msg, p3skb, raw, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  raw = _arg.raw, armored = _arg.armored, asp = _arg.asp;
  armored || (armored = raw);
  asp = ASP.make(asp);
  km = null;
  warnings = null;
  _ref5 = katch(function() {
    return P3SKB.alloc(unseal(read_base64(armored)));
  }), err = _ref5[0], p3skb = _ref5[1];
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        msg = new Message({
          body: p3skb.pub,
          type: C.message_types.public_key
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.import_from_p3skb&#x22;
          });
          KeyManager.import_from_pgp_message({
            msg: msg,
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                km = arguments[1];
                return warnings = arguments[2];
              };
            })(),
            lineno: 584
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(km != null ? km.p3skb = p3skb : void 0);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, km, warnings);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.import_from_pgp_message" id="apidoc.element.kbpgp.KeyManager.import_from_pgp_message">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.</span>import_from_pgp_message
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_from_pgp_message = function (_arg, cb) {
  var asp, bundle, err, k, kb, msg, opts, packets, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, asp = _arg.asp, opts = _arg.opts;
  asp = ASP.make(asp);
  bundle = null;
  warnings = null;
  if (typeof err === &#x22;undefined&#x22; || err === null) {
    _ref5 = parse(msg.body), err = _ref5[0], packets = _ref5[1];
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        kb = new KeyBlock(packets, opts);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.import_from_pgp_message&#x22;
          });
          kb.process(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 621
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(warnings = kb.warnings);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      if (err == null) {
        bundle = new KeyManager({
          primary: KeyManager._wrap_pgp(Primary, kb.primary),
          subkeys: (function() {
            var _i, _len, _ref6, _results;
            _ref6 = kb.subkeys;
            _results = [];
            for (_i = 0, _len = _ref6.length; _i &#x3c; _len; _i++) {
              k = _ref6[_i];
              _results.push(KeyManager._wrap_pgp(Subkey, k));
            }
            return _results;
          })(),
          user_attributes: kb.user_attributes,
          userids: kb.userids,
          signed: true
        });
        if (bundle.has_pgp_private()) {
          bundle.armored_pgp_private = msg.raw();
        } else {
          bundle.armored_pgp_public = msg.raw();
        }
      }
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
              funcname: &#x22;KeyManager.import_from_pgp_message&#x22;
            });
            bundle.check_pgp_validity(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 639
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, bundle, warnings, packets);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.import_from_armored_pgp&#x22;
  });
  KeyManager.<span class="apidocCodeKeywordSpan">import_from_pgp_message</span>({
    msg: msg,
    asp: asp,
    opts: opts
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.KeyManager.__super__" id="apidoc.module.kbpgp.KeyManager.__super__">module kbpgp.KeyManager.__super__</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.can_decrypt" id="apidoc.element.kbpgp.KeyManager.__super__.can_decrypt">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_decrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_decrypt = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.can_sign()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_decrypt</span>()) {
    return false;
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.can_encrypt" id="apidoc.element.kbpgp.KeyManager.__super__.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.can_sign" id="apidoc.element.kbpgp.KeyManager.__super__.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.can_verify" id="apidoc.element.kbpgp.KeyManager.__super__.can_verify">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>can_verify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_verify = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.check_public_eq" id="apidoc.element.kbpgp.KeyManager.__super__.check_public_eq">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>check_public_eq
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_public_eq = function (km2) {
  return this.EUI;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.constructor" id="apidoc.element.kbpgp.KeyManager.__super__.constructor">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManagerInterface() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.export_pgp_private" id="apidoc.element.kbpgp.KeyManager.__super__.export_pgp_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_pgp_private
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_private = function (opts, cb) {
  return cb(null, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.export_pgp_public" id="apidoc.element.kbpgp.KeyManager.__super__.export_pgp_public">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_pgp_public
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_public = function (opts, cb) {
  return cb(null, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.export_public&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">export_pgp_public</span>({
    asp: asp,
    regen: regen
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return msg = arguments[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.export_private" id="apidoc.element.kbpgp.KeyManager.__super__.export_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_private = function (_arg, cb) {
  var asp, p3skb, passphrase;
  asp = _arg.asp, passphrase = _arg.passphrase, p3skb = _arg.p3skb;
  return cb(EUI);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.export_public" id="apidoc.element.kbpgp.KeyManager.__super__.export_public">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>export_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_public = function (_arg, cb) {
  var asp, regen;
  asp = _arg.asp, regen = _arg.regen;
  return cb(EUI, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_ids" id="apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_ids">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_all_pgp_key_ids
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_all_pgp_key_ids = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_materials" id="apidoc.element.kbpgp.KeyManager.__super__.get_all_pgp_key_materials">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_all_pgp_key_materials
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_all_pgp_key_materials = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_ekid" id="apidoc.element.kbpgp.KeyManager.__super__.get_ekid">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_ekid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_ekid = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_pgp_fingerprint_str = function() {
  var _ref5;
  return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString(&#x27;hex&#x27;) : void 0;
};

KeyManager.prototype.get_ekid = function() {
  return this.pgp.<span class="apidocCodeKeywordSpan">get_ekid</span>();
};

KeyManager.prototype.clear_pgp_internal_sigs = function() {
  return this.pgp.clear_psc();
};

KeyManager.prototype.get_all_pgp_key_ids = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_fp2" id="apidoc.element.kbpgp.KeyManager.__super__.get_fp2">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_fp2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2 = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_fp2 = function() {
  return this.get_pgp_fingerprint();
};

KeyManager.prototype.get_fp2_formatted = function(opts) {
  var p;
  if ((p = this.<span class="apidocCodeKeywordSpan">get_fp2</span>()) != null) {
    return format_pgp_fingerprint_2(p, opts);
  } else {
    return null;
  }
};

KeyManager.prototype.get_type = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_fp2_formatted" id="apidoc.element.kbpgp.KeyManager.__super__.get_fp2_formatted">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_fp2_formatted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2_formatted = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_pgp_fingerprint" id="apidoc.element.kbpgp.KeyManager.__super__.get_pgp_fingerprint">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_pgp_fingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_pgp_fingerprint = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_pgp_fingerprint = function() {
  return this.pgp.get_fingerprint();
};

KeyManager.prototype.get_pgp_fingerprint_str = function() {
  var _ref5;
  return (_ref5 = this.<span class="apidocCodeKeywordSpan">get_pgp_fingerprint</span>()) != null ? _ref5.toString(&#x27;hex&#x27
;) : void 0;
};

KeyManager.prototype.get_ekid = function() {
  return this.pgp.get_ekid();
};

KeyManager.prototype.clear_pgp_internal_sigs = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_primary_keypair" id="apidoc.element.kbpgp.KeyManager.__super__.get_primary_keypair">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_primary_keypair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_primary_keypair = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_type" id="apidoc.element.kbpgp.KeyManager.__super__.get_type">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_userids" id="apidoc.element.kbpgp.KeyManager.__super__.get_userids">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_userids
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_userids = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.get_userids_mark_primary" id="apidoc.element.kbpgp.KeyManager.__super__.get_userids_mark_primary">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>get_userids_mark_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_userids_mark_primary = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
existing_utf8_strings = {};
_ref5 = this.userids;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
  existing_userid = _ref5[_i];
  existing_utf8_strings[existing_userid.utf8()] = true;
}
_ref6 = km2.<span class="apidocCodeKeywordSpan">get_userids_mark_primary</span>();
_results = [];
for (_j = 0, _len1 = _ref6.length; _j &#x3c; _len1; _j++) {
  candidate_userid = _ref6[_j];
  if (!(candidate_userid.utf8() in existing_utf8_strings)) {
    _results.push(this.userids.push(candidate_userid));
  } else {
    _results.push(void 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.make_sig_eng" id="apidoc.element.kbpgp.KeyManager.__super__.make_sig_eng">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>make_sig_eng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_sig_eng = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.__super__.pgp_full_hash" id="apidoc.element.kbpgp.KeyManager.__super__.pgp_full_hash">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.__super__.</span>pgp_full_hash
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pgp_full_hash = function (opts, cb) {
  return cb(null, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.KeyManager.prototype" id="apidoc.module.kbpgp.KeyManager.prototype">module kbpgp.KeyManager.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype._apply_to_engines" id="apidoc.element.kbpgp.KeyManager.prototype._apply_to_engines">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>_apply_to_engines
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_apply_to_engines = function (_arg, cb) {
  var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  args = _arg.args, meth = _arg.meth;
  err = null;
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref5, _results, _while;
      _ref5 = _this.engines;
      _len = _ref5.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          e = _ref5[_i];
          if (!err) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
                funcname: &#x22;KeyManager._apply_to_engines&#x22;
              });
              meth.call(e, args, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 902
              }));
              __iced_deferrals._fulfill();
            })(_next);
          } else {
            return _continue();
          }
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype._assert_signed" id="apidoc.element.kbpgp.KeyManager.prototype._assert_signed">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>_assert_signed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_assert_signed = function () {
  if (this._signed) {
    return null;
  } else {
    return new Error(&#x22;need to sign before export&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
tsenc = _arg.tsenc, asp = _arg.asp, passphrase_generation = _arg.passphrase_generation;
asp = ASP.make(asp);
err = ret = null;
(function(_this) {
  return (function(__iced_k) {
    if ((err = _this.<span class="apidocCodeKeywordSpan">_assert_signed</span>()) == null) {
      p3skb = _this.pgp.export_to_p3skb();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
          funcname: &#x22;KeyManager.export_private_to_server&#x22;
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.can_decrypt" id="apidoc.element.kbpgp.KeyManager.prototype.can_decrypt">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_decrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_decrypt = function () {
  return this.find_crypt_pgp_key(true) != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.can_sign()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_decrypt</span>()) {
    return false;
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.can_encrypt" id="apidoc.element.kbpgp.KeyManager.prototype.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return this.find_crypt_pgp_key(false) != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.can_sign" id="apidoc.element.kbpgp.KeyManager.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return this.find_signing_pgp_key() != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.can_verify" id="apidoc.element.kbpgp.KeyManager.prototype.can_verify">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>can_verify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_verify = function () {
  return this.find_verifying_pgp_key() != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.check_pgp_public_eq" id="apidoc.element.kbpgp.KeyManager.prototype.check_pgp_public_eq">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>check_pgp_public_eq
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_pgp_public_eq = function (km2) {
  return this.pgp.check_eq(km2.pgp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.check_pgp_validity" id="apidoc.element.kbpgp.KeyManager.prototype.check_pgp_validity">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>check_pgp_validity
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_pgp_validity = function (cb) {
  return this.pgp.validity_check(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.import_from_pgp_message&#x22;
  });
  bundle.<span class="apidocCodeKeywordSpan">check_pgp_validity</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
    })(),
    lineno: 639
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.clear_pgp_internal_sigs" id="apidoc.element.kbpgp.KeyManager.prototype.clear_pgp_internal_sigs">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>clear_pgp_internal_sigs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear_pgp_internal_sigs = function () {
  return this.pgp.clear_psc();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.constructor" id="apidoc.element.kbpgp.KeyManager.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  var signed;
  this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public
, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;
  this.pgp = new PgpEngine({
    primary: this.primary,
    subkeys: this.subkeys,
    userids: this.userids,
    user_attributes: this.user_attributes,
    key_manager: this
  });
  this.engines = [this.pgp];
  this._signed = signed != null ? signed : false;
  this.p3skb = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_keys_to_keyring" id="apidoc.element.kbpgp.KeyManager.prototype.export_pgp_keys_to_keyring">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_keys_to_keyring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_keys_to_keyring = function () {
  return this.pgp.export_keys_to_keyring(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private" id="apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_private = function () {
  var args;
  args = 1 &#x3c;= arguments.length ? __slice.call(arguments, 0) : [];
  return this.export_pgp_private_to_client.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private_to_client" id="apidoc.element.kbpgp.KeyManager.prototype.export_pgp_private_to_client">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_private_to_client
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_private_to_client = function (_arg, cb) {
  var err, msg, passphrase, regen;
  passphrase = _arg.passphrase, regen = _arg.regen;
  err = null;
  if (passphrase != null) {
    passphrase = bufferify(passphrase);
  }
  if (regen || ((msg = this.armored_pgp_private) == null)) {
    if ((err = this._assert_signed()) == null) {
      this.armored_pgp_private = msg = this.pgp.export_keys({
        &#x22;private&#x22;: true,
        passphrase: passphrase
      });
    }
  }
  return cb(err, msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.export_private&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">export_pgp_private_to_client</span>({
    passphrase: passphrase,
    asp: asp,
    regen: regen
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_pgp_public" id="apidoc.element.kbpgp.KeyManager.prototype.export_pgp_public">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_pgp_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_pgp_public = function (_arg, cb) {
  var err, msg, regen;
  regen = _arg.regen;
  err = null;
  if (regen || ((msg = this.armored_pgp_public) == null)) {
    if ((err = this._assert_signed()) == null) {
      this.armored_pgp_public = msg = this.pgp.export_keys({
        &#x22;private&#x22;: false
      });
    }
  }
  return cb(err, msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.export_public&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">export_pgp_public</span>({
    asp: asp,
    regen: regen
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return msg = arguments[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_private" id="apidoc.element.kbpgp.KeyManager.prototype.export_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_private = function (_arg, cb) {
  var asp, err, p3skb, passphrase, passphrase_generation, regen, res, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  passphrase = _arg.passphrase, p3skb = _arg.p3skb, asp = _arg.asp, regen = _arg.regen, passphrase_generation = _arg.passphrase_generation
;
  (function(_this) {
    return (function(__iced_k) {
      if (p3skb) {
        tsenc = new Encryptor({
          key: bufferify(passphrase)
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.export_private&#x22;
          });
          _this.export_private_to_server({
            tsenc: tsenc,
            asp: asp,
            passphrase_generation: passphrase_generation
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return res = arguments[1];
              };
            })(),
            lineno: 743
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.export_private&#x22;
          });
          _this.export_pgp_private_to_client({
            passphrase: passphrase,
            asp: asp,
            regen: regen
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return res = arguments[1];
              };
            })(),
            lineno: 745
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, res);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_private_to_server" id="apidoc.element.kbpgp.KeyManager.prototype.export_private_to_server">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_private_to_server
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_private_to_server = function (_arg, cb) {
  var asp, err, p3skb, passphrase_generation, ret, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  tsenc = _arg.tsenc, asp = _arg.asp, passphrase_generation = _arg.passphrase_generation;
  asp = ASP.make(asp);
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      if ((err = _this._assert_signed()) == null) {
        p3skb = _this.pgp.export_to_p3skb();
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.export_private_to_server&#x22;
          });
          p3skb.lock({
            tsenc: tsenc,
            asp: asp,
            passphrase_generation: passphrase_generation
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 701
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      if (err == null) {
        ret = p3skb.frame_packet_armored({
          dohash: true
        });
      }
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.export_private&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">export_private_to_server</span>({
    tsenc: tsenc,
    asp: asp,
    passphrase_generation: passphrase_generation
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.export_public" id="apidoc.element.kbpgp.KeyManager.prototype.export_public">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>export_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_public = function (_arg, cb) {
  var asp, err, msg, regen, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  _ref5 = _arg != null ? _arg : {}, asp = _ref5.asp, regen = _ref5.regen;
  if (cb == null) {
    cb = null;
  }
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.export_public&#x22;
      });
      _this.export_pgp_public({
        asp: asp,
        regen: regen
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return msg = arguments[1];
          };
        })(),
        lineno: 735
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, msg);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.fetch" id="apidoc.element.kbpgp.KeyManager.prototype.fetch">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>fetch
        <span class="apidocSignatureSpan">(key_ids, flags, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (key_ids, flags, cb) {
  return this.pgp.fetch(key_ids, flags, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    obj.userid.most_recent_sig = obj.pair[0];
    ret.push(obj.userid);
  }
  return ret;
};

KeyManager.prototype.fetch = function(key_ids, flags, cb) {
  return this.pgp.<span class="apidocCodeKeywordSpan">fetch</span>(key_ids, flags, cb);
};

KeyManager.prototype.find_pgp_key = function(key_id) {
  return this.pgp.find_key(key_id);
};

KeyManager.prototype.find_pgp_key_material = function(key_id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_best_pgp_key" id="apidoc.element.kbpgp.KeyManager.prototype.find_best_pgp_key">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_best_pgp_key
        <span class="apidocSignatureSpan">(flags, need_priv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_best_pgp_key = function (flags, need_priv) {
  return this.pgp.find_best_key(flags, need_priv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

KeyManager.prototype.find_best_pgp_key = function(flags, need_priv) {
  return this.pgp.find_best_key(flags, need_priv);
};

KeyManager.prototype.find_signing_pgp_key = function() {
  return this.<span class="apidocCodeKeywordSpan">find_best_pgp_key</span>(C.key_flags.sign_data, true);
};

KeyManager.prototype.find_verifying_pgp_key = function() {
  return this.find_best_pgp_key(C.key_flags.sign_data, false);
};

KeyManager.prototype.find_crypt_pgp_key = function(need_priv) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_crypt_pgp_key" id="apidoc.element.kbpgp.KeyManager.prototype.find_crypt_pgp_key">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_crypt_pgp_key
        <span class="apidocSignatureSpan">(need_priv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_crypt_pgp_key = function (need_priv) {
  if (need_priv == null) {
    need_priv = false;
  }
  return this.find_best_pgp_key(C.key_flags.encrypt_comm, need_priv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (count_true(this.encrypt_for != null, this.encryption_key != null, this.encryption_keys != null) &#x3e; 1) {
  err = new Error(&#x22;specify only one of `encrypt_for`, `encryption_keys` and `encryption_key`&#x22;);
} else if (this.encrypt_for != null) {
  this.encryption_keys = [];
  _ref = (this.encrypt_for = arrayize(this.encrypt_for));
  for (i = _i = 0, _len = _ref.length; _i &#x3c; _len; i = ++_i) {
    f = _ref[i];
    if ((k = f.<span class="apidocCodeKeywordSpan">find_crypt_pgp_key</span>()) != null) {
      this.encryption_keys.push(k);
    } else {
      err = new Error(&#x22;cannot encrypt with the given KeyManager (i=&#x22; + i + &#x22;)&#x22;);
      break;
    }
  }
} else if (this.encryption_key != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key" id="apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_pgp_key
        <span class="apidocSignatureSpan">(key_id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_pgp_key = function (key_id) {
  return this.pgp.find_key(key_id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
SignatureEngine.prototype._check_result = function(literals, cb) {
  var b, err, l, n, payload, sw, _ref;
  err = payload = null;
  if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {
    err = new Error(&#x22;Expected only one pgp literal; got &#x22; + n);
  } else if ((sw = (_ref = l.get_data_signer()) != null ? _ref.sig : void 0) == null) {
    err = new Error(&#x22;Expected a signature on the payload message&#x22;);
  } else if ((this.km.<span class="apidocCodeKeywordSpan">find_pgp_key</span>((b = sw.get_key_id()))) == null) {
    err = new Error(&#x22;Failed sanity check; didn&#x27;t have a key for &#x27;&#x22; + (b.toString(&#x27;hex&#x27;)) + &#x22;&#
x27;&#x22;);
  } else {
    payload = l.data;
  }
  return cb(err, payload);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key_material" id="apidoc.element.kbpgp.KeyManager.prototype.find_pgp_key_material">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_pgp_key_material
        <span class="apidocSignatureSpan">(key_id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_pgp_key_material = function (key_id) {
  return this.pgp.find_key_material(key_id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      lineno: 28
    }));
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    if (typeof err === &#x22;undefined&#x22; || err === null) {
      keymat = km.<span class="apidocCodeKeywordSpan">find_pgp_key_material</span>(key_id);
      _this._sig.key = keymat.key;
      _this._sig.key_manager = km;
      _this._sig.subkey_material = keymat;
    }
    return cb(err);
  };
})(this));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_signing_pgp_key" id="apidoc.element.kbpgp.KeyManager.prototype.find_signing_pgp_key">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_signing_pgp_key
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_signing_pgp_key = function () {
  return this.find_best_pgp_key(C.key_flags.sign_data, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseBurner.prototype._find_signing_key = function(cb) {
  var err;
  err = null;
  if ((this.sign_with != null) &#x26;&#x26; (this.signing_key != null)) {
    err = new Error(&#x22;specify either `sign_with` or `signing_key` but not both&#x22;);
  } else if ((this.sign_with != null) &#x26;&#x26; ((this.signing_key = this.sign_with.<span class="apidocCodeKeywordSpan">find_signing_pgp_key
</span>()) == null)) {
    err = new Error(&#x22;cannot sign with the given KeyManager&#x22;);
  }
  return cb(err);
};

BaseBurner.prototype._find_encryption_key = function(cb) {
  var arrayize, count_true, err, f, i, k, _i, _len, _ref;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.find_verifying_pgp_key" id="apidoc.element.kbpgp.KeyManager.prototype.find_verifying_pgp_key">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>find_verifying_pgp_key
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_verifying_pgp_key = function () {
  return this.find_best_pgp_key(C.key_flags.sign_data, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (need_priv == null) {
    need_priv = false;
  }
  return this.find_best_pgp_key(C.key_flags.encrypt_comm, need_priv);
};

KeyManager.prototype.can_verify = function() {
  return this.<span class="apidocCodeKeywordSpan">find_verifying_pgp_key</span>() != null;
};

KeyManager.prototype.can_sign = function() {
  return this.find_signing_pgp_key() != null;
};

KeyManager.prototype.can_encrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_ids" id="apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_ids">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_all_pgp_key_ids
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_all_pgp_key_ids = function () {
  return this.pgp.get_all_key_ids();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_materials" id="apidoc.element.kbpgp.KeyManager.prototype.get_all_pgp_key_materials">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_all_pgp_key_materials
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_all_pgp_key_materials = function () {
  return this.pgp.get_all_key_materials();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_ekid" id="apidoc.element.kbpgp.KeyManager.prototype.get_ekid">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_ekid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_ekid = function () {
  return this.pgp.get_ekid();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_pgp_fingerprint_str = function() {
  var _ref5;
  return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString(&#x27;hex&#x27;) : void 0;
};

KeyManager.prototype.get_ekid = function() {
  return this.pgp.<span class="apidocCodeKeywordSpan">get_ekid</span>();
};

KeyManager.prototype.clear_pgp_internal_sigs = function() {
  return this.pgp.clear_psc();
};

KeyManager.prototype.get_all_pgp_key_ids = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_ekid_b64_str" id="apidoc.element.kbpgp.KeyManager.prototype.get_ekid_b64_str">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_ekid_b64_str
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_ekid_b64_str = function () {
  var k;
  if ((k = this.get_ekid()) != null) {
    return base64u.encode(k);
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_fp2" id="apidoc.element.kbpgp.KeyManager.prototype.get_fp2">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_fp2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2 = function () {
  return this.get_pgp_fingerprint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_fp2 = function() {
  return this.get_pgp_fingerprint();
};

KeyManager.prototype.get_fp2_formatted = function(opts) {
  var p;
  if ((p = this.<span class="apidocCodeKeywordSpan">get_fp2</span>()) != null) {
    return format_pgp_fingerprint_2(p, opts);
  } else {
    return null;
  }
};

KeyManager.prototype.get_type = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_fp2_formatted" id="apidoc.element.kbpgp.KeyManager.prototype.get_fp2_formatted">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_fp2_formatted
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2_formatted = function (opts) {
  var p;
  if ((p = this.get_fp2()) != null) {
    return format_pgp_fingerprint_2(p, opts);
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint" id="apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_fingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_pgp_fingerprint = function () {
  return this.pgp.get_fingerprint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_pgp_fingerprint = function() {
  return this.pgp.get_fingerprint();
};

KeyManager.prototype.get_pgp_fingerprint_str = function() {
  var _ref5;
  return (_ref5 = this.<span class="apidocCodeKeywordSpan">get_pgp_fingerprint</span>()) != null ? _ref5.toString(&#x27;hex&#x27
;) : void 0;
};

KeyManager.prototype.get_ekid = function() {
  return this.pgp.get_ekid();
};

KeyManager.prototype.clear_pgp_internal_sigs = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint_str" id="apidoc.element.kbpgp.KeyManager.prototype.get_pgp_fingerprint_str">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_fingerprint_str
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_pgp_fingerprint_str = function () {
  var _ref5;
  return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString(&#x27;hex&#x27;) : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_key_id" id="apidoc.element.kbpgp.KeyManager.prototype.get_pgp_key_id">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_pgp_key_id = function () {
  return this.pgp.get_key_id();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_pgp_short_key_id" id="apidoc.element.kbpgp.KeyManager.prototype.get_pgp_short_key_id">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_pgp_short_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_pgp_short_key_id = function () {
  return this.pgp.get_short_key_id();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_primary_keypair" id="apidoc.element.kbpgp.KeyManager.prototype.get_primary_keypair">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_primary_keypair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_primary_keypair = function () {
  return this.primary.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_type" id="apidoc.element.kbpgp.KeyManager.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return &#x22;pgp&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_userids" id="apidoc.element.kbpgp.KeyManager.prototype.get_userids">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_userids
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_userids = function () {
  return this.userids;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.get_userids_mark_primary" id="apidoc.element.kbpgp.KeyManager.prototype.get_userids_mark_primary">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>get_userids_mark_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_userids_mark_primary = function () {
  var do_insert, i, k, max, max_s, mymax, obj, pair, prev, primary_time, ret, s, tab, userid, _i, _len, _ref5;
  max = null;
  max_s = null;
  tab = {};
  mymax = function(a, b) {
    if ((a == null) &#x26;&#x26; (b == null)) {
      return null;
    } else if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    } else if (a &#x3e; b) {
      return a;
    } else {
      return b;
    }
  };
  _ref5 = this.userids;
  for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
    userid = _ref5[i];
    if (!(userid != null)) {
      continue;
    }
    s = userid.utf8();
    pair = userid.time_primary_pair();
    obj = {
      userid: userid,
      pair: pair,
      i: i
    };
    do_insert = false;
    if ((prev = tab[s]) != null) {
      primary_time = mymax(prev.pair[1], pair[1]);
      if (!(prev.pair[0] != null) || (pair[0] &#x26;&#x26; prev.pair[0] &#x3c; pair[0])) {
        do_insert = true;
      }
    } else {
      primary_time = pair[1];
      do_insert = true;
    }
    if (do_insert) {
      tab[s] = obj;
    }
    if ((primary_time != null) &#x26;&#x26; ((max == null) || max &#x3c; primary_time)) {
      max_s = s;
      max = primary_time;
    }
  }
  if (max_s != null) {
    tab[max_s].userid.primary = true;
  }
  ret = [];
  for (k in tab) {
    obj = tab[k];
    obj.userid.most_recent_sig = obj.pair[0];
    ret.push(obj.userid);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
existing_utf8_strings = {};
_ref5 = this.userids;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
  existing_userid = _ref5[_i];
  existing_utf8_strings[existing_userid.utf8()] = true;
}
_ref6 = km2.<span class="apidocCodeKeywordSpan">get_userids_mark_primary</span>();
_results = [];
for (_j = 0, _len1 = _ref6.length; _j &#x3c; _len1; _j++) {
  candidate_userid = _ref6[_j];
  if (!(candidate_userid.utf8() in existing_utf8_strings)) {
    _results.push(this.userids.push(candidate_userid));
  } else {
    _results.push(void 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.has_keybase_private" id="apidoc.element.kbpgp.KeyManager.prototype.has_keybase_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_keybase_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_keybase_private = function () {
  return this.keybase.has_private();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.has_p3skb_private" id="apidoc.element.kbpgp.KeyManager.prototype.has_p3skb_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_p3skb_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_p3skb_private = function () {
  var _ref5;
  return (_ref5 = this.p3skb) != null ? _ref5.has_private() : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.has_pgp_private" id="apidoc.element.kbpgp.KeyManager.prototype.has_pgp_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>has_pgp_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_pgp_private = function () {
  return this.pgp.has_private();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    KeyManager.prototype.simple_unlock = function(opts, cb) {
var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
err = null;
(function(_this) {
  return (function(__iced_k) {
    if (_this.<span class="apidocCodeKeywordSpan">has_pgp_private</span>() &#x26;&#x26; !_this.is_pgp_locked()) {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
          funcname: &#x22;KeyManager.simple_unlock&#x22;
        });
        _this.unlock_pgp({}, __iced_deferrals.defer({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.is_keybase_locked" id="apidoc.element.kbpgp.KeyManager.prototype.is_keybase_locked">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_keybase_locked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_keybase_locked = function () {
  return this.keybase.is_locked();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.is_p3skb_locked" id="apidoc.element.kbpgp.KeyManager.prototype.is_p3skb_locked">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_p3skb_locked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_p3skb_locked = function () {
  var _ref5;
  return (_ref5 = this.p3skb) != null ? _ref5.is_locked() : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.is_pgp_locked" id="apidoc.element.kbpgp.KeyManager.prototype.is_pgp_locked">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>is_pgp_locked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_pgp_locked = function () {
  return this.pgp.is_locked();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    KeyManager.prototype.simple_unlock = function(opts, cb) {
var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
err = null;
(function(_this) {
  return (function(__iced_k) {
    if (_this.has_pgp_private() &#x26;&#x26; !_this.<span class="apidocCodeKeywordSpan">is_pgp_locked</span>()) {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
          funcname: &#x22;KeyManager.simple_unlock&#x22;
        });
        _this.unlock_pgp({}, __iced_deferrals.defer({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.make_sig_eng" id="apidoc.element.kbpgp.KeyManager.prototype.make_sig_eng">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>make_sig_eng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_sig_eng = function () {
  return new SignatureEngine({
    km: this
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.merge_all_subkeys_omitting_revokes" id="apidoc.element.kbpgp.KeyManager.prototype.merge_all_subkeys_omitting_revokes">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_all_subkeys_omitting_revokes
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_all_subkeys_omitting_revokes = function (km2) {
  if ((this.pgp != null) &#x26;&#x26; (km2.pgp != null)) {
    return this.pgp.merge_all_subkeys_omitting_revokes(km2.pgp);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._index[ekid] = k;
    return this.subkeys.push(k);
  }
};

Engine.prototype.merge_public_omitting_revokes = function(pgpeng2) {
  this.primary.overwrite_with_omitting_revokes(pgpeng2.primary);
  return this.<span class="apidocCodeKeywordSpan">merge_all_subkeys_omitting_revokes</span>(pgpeng2);
};

Engine.prototype.merge_all_subkeys_omitting_revokes = function(pgpeng2) {
  var subkey, _i, _len, _ref5, _results;
  _ref5 = pgpeng2.subkeys;
  _results = [];
  for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.merge_everything" id="apidoc.element.kbpgp.KeyManager.prototype.merge_everything">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_everything
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_everything = function (km2) {
  this.merge_public_omitting_revokes(km2);
  return this.merge_userids(km2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.merge_pgp_private" id="apidoc.element.kbpgp.KeyManager.prototype.merge_pgp_private">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_pgp_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_pgp_private = function (_arg, cb) {
  var armored, asp, b2, err, esc, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, asp = _arg.asp;
  asp = ASP.make(asp);
  esc = make_esc(cb, &#x22;merge_pgp_private&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.merge_pgp_private&#x22;
      });
      KeyManager.import_from_armored_pgp({
        armored: armored,
        raw: raw,
        asp: asp
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return b2 = arguments[0];
          };
        })(),
        lineno: 650
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      err = _this.pgp.merge_private(b2.pgp);
      (function(__iced_k) {
        if (err != null) {
          return __iced_k();
        } else {
          (function(__iced_k) {
            if (!_this.has_pgp_private()) {
              return __iced_k(err = new Error(&#x22;no private key material found after merge&#x22;));
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
                  funcname: &#x22;KeyManager.merge_pgp_private&#x22;
                });
                _this.simple_unlock({}, esc(__iced_deferrals.defer({
                  lineno: 657
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            }
          })(__iced_k);
        }
      })(function() {
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.merge_public_omitting_revokes" id="apidoc.element.kbpgp.KeyManager.prototype.merge_public_omitting_revokes">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_public_omitting_revokes
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_public_omitting_revokes = function (km2) {
  if ((this.pgp != null) &#x26;&#x26; (km2.pgp != null)) {
    return this.pgp.merge_public_omitting_revokes(km2.pgp);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    subkey_material: subkey_material,
    now: now
  });
};

KeyManager.prototype.merge_public_omitting_revokes = function(km2) {
  if ((this.pgp != null) &#x26;&#x26; (km2.pgp != null)) {
    return this.pgp.<span class="apidocCodeKeywordSpan">merge_public_omitting_revokes</span>(km2.pgp);
  }
};

KeyManager.prototype.merge_userids = function(km2) {
  var candidate_userid, existing_userid, existing_utf8_strings, _i, _j, _len, _len1, _ref5, _ref6, _results;
  if ((this.pgp == null) || (km2.pgp == null)) {
    return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.merge_userids" id="apidoc.element.kbpgp.KeyManager.prototype.merge_userids">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>merge_userids
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_userids = function (km2) {
  var candidate_userid, existing_userid, existing_utf8_strings, _i, _j, _len, _len1, _ref5, _ref6, _results;
  if ((this.pgp == null) || (km2.pgp == null)) {
    return;
  }
  existing_utf8_strings = {};
  _ref5 = this.userids;
  for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
    existing_userid = _ref5[_i];
    existing_utf8_strings[existing_userid.utf8()] = true;
  }
  _ref6 = km2.get_userids_mark_primary();
  _results = [];
  for (_j = 0, _len1 = _ref6.length; _j &#x3c; _len1; _j++) {
    candidate_userid = _ref6[_j];
    if (!(candidate_userid.utf8() in existing_utf8_strings)) {
      _results.push(this.userids.push(candidate_userid));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    return _results;
  };

  KeyManager.prototype.merge_everything = function(km2) {
    this.merge_public_omitting_revokes(km2);
    return this.<span class="apidocCodeKeywordSpan">merge_userids</span>(km2);
  };

  return KeyManager;

})(KeyManagerInterface);

exports.KeyManager = KeyManager;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.pgp_check_not_expired" id="apidoc.element.kbpgp.KeyManager.prototype.pgp_check_not_expired">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>pgp_check_not_expired
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pgp_check_not_expired = function (_arg) {
  var now, subkey_material;
  subkey_material = _arg.subkey_material, now = _arg.now;
  return this.pgp.check_not_expired({
    subkey_material: subkey_material,
    now: now
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.pgp_full_hash" id="apidoc.element.kbpgp.KeyManager.prototype.pgp_full_hash">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>pgp_full_hash
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pgp_full_hash = function (opts, cb) {
  var armored, esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;get_pgp_full_hash&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.pgp_full_hash&#x22;
      });
      _this.export_pgp_public(opts, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return armored = arguments[0];
          };
        })(),
        lineno: 752
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, (new SHA256(new Buffer(armored.trim()))).toString(&#x22;hex&#x22;));
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.set_enc" id="apidoc.element.kbpgp.KeyManager.prototype.set_enc">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>set_enc
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set_enc = function (e) {
  return this.tsenc = e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.sign" id="apidoc.element.kbpgp.KeyManager.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>sign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (_arg, cb) {
  var asp, err, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  asp = _arg.asp, time = _arg.time;
  asp = ASP.make(asp);
  asp.section(&#x22;sign&#x22;);
  asp.progress({
    what: &#x22;sign PGP&#x22;,
    total: 1,
    i: 0
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.sign&#x22;
      });
      _this.sign_pgp({
        asp: asp,
        time: time
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 765
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      asp.progress({
        what: &#x22;sign PGP&#x22;,
        total: 1,
        i: 1
      });
      if (typeof err === &#x22;undefined&#x22; || err === null) {
        _this._signed = true;
      }
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.sign_pgp" id="apidoc.element.kbpgp.KeyManager.prototype.sign_pgp">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>sign_pgp
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign_pgp = function (_arg, cb) {
  var asp, time;
  asp = _arg.asp, time = _arg.time;
  return this.pgp.sign({
    asp: asp,
    time: time
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.sign&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">sign_pgp</span>({
    asp: asp,
    time: time
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.simple_unlock" id="apidoc.element.kbpgp.KeyManager.prototype.simple_unlock">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>simple_unlock
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simple_unlock = function (opts, cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  (function(_this) {
    return (function(__iced_k) {
      if (_this.has_pgp_private() &#x26;&#x26; !_this.is_pgp_locked()) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
            funcname: &#x22;KeyManager.simple_unlock&#x22;
          });
          _this.unlock_pgp({}, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 569
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (!(err != null)) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.import_from_armored_pgp&#x22;
  });
  ret.<span class="apidocCodeKeywordSpan">simple_unlock</span>({}, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
    })(),
    lineno: 557
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_keybase" id="apidoc.element.kbpgp.KeyManager.prototype.unlock_keybase">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_keybase
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock_keybase = function (_arg, cb) {
  var asp, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  tsenc = _arg.tsenc, asp = _arg.asp;
  asp = ASP.make(asp);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.unlock_keybase&#x22;
      });
      _this.keybase.unlock_keys({
        tsenc: tsenc,
        asp: asp
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 688
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_p3skb" id="apidoc.element.kbpgp.KeyManager.prototype.unlock_p3skb">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_p3skb
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock_p3skb = function (_arg, cb) {
  var asp, err, km, msg, passphrase, passphrase_generation, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  asp = _arg.asp, tsenc = _arg.tsenc, passphrase = _arg.passphrase, passphrase_generation = _arg.passphrase_generation;
  asp = ASP.make(asp);
  if ((tsenc == null) &#x26;&#x26; (passphrase != null)) {
    tsenc = new Encryptor({
      key: bufferify(passphrase)
    });
  }
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.unlock_p3skb&#x22;
      });
      _this.p3skb.unlock({
        tsenc: tsenc,
        asp: asp,
        passphrase_generation: passphrase_generation
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 594
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          msg = new Message({
            body: _this.p3skb.priv.data,
            type: C.message_types.private_key
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
              funcname: &#x22;KeyManager.unlock_p3skb&#x22;
            });
            KeyManager.import_from_pgp_message({
              msg: msg,
              asp: asp
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return km = arguments[1];
                };
              })(),
              lineno: 597
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (typeof err === &#x22;undefined&#x22; || err === null) {
          err = _this.pgp.merge_private(km.pgp);
        }
        (function(__iced_k) {
          if (err == null) {
            passphrase = new Buffer([]);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
                funcname: &#x22;KeyManager.unlock_p3skb&#x22;
              });
              _this.unlock_pgp({
                passphrase: passphrase
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 606
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.KeyManager.prototype.unlock_pgp" id="apidoc.element.kbpgp.KeyManager.prototype.unlock_pgp">
        function <span class="apidocSignatureSpan">kbpgp.KeyManager.prototype.</span>unlock_pgp
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock_pgp = function (_arg, cb) {
  var err, passphrase, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  passphrase = _arg.passphrase;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
        funcname: &#x22;KeyManager.unlock_pgp&#x22;
      });
      _this.pgp.unlock_keys({
        passphrase: passphrase
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 670
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          if (_this.has_pgp_private() &#x26;&#x26; !_this.is_pgp_locked()) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.simple_unlock&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">unlock_pgp</span>({}, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
    })(),
    lineno: 569
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.PgpKeyRing" id="apidoc.module.kbpgp.PgpKeyRing">module kbpgp.PgpKeyRing</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.PgpKeyRing" id="apidoc.element.kbpgp.PgpKeyRing.PgpKeyRing">
        function <span class="apidocSignatureSpan">kbpgp.</span>PgpKeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.PgpKeyRing.prototype" id="apidoc.module.kbpgp.PgpKeyRing.prototype">module kbpgp.PgpKeyRing.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.prototype.add_key_manager" id="apidoc.element.kbpgp.PgpKeyRing.prototype.add_key_manager">
        function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>add_key_manager
        <span class="apidocSignatureSpan">(km)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_key_manager = function (km) {
  var k, keys, kid, _i, _len, _results;
  keys = km.export_pgp_keys_to_keyring();
  _results = [];
  for (_i = 0, _len = keys.length; _i &#x3c; _len; _i++) {
    k = keys[_i];
    kid = hexkid(k.key_material.get_key_id());
    this._keys[kid] = k;
    _results.push(this._kms[kid] = km);
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.prototype.constructor" id="apidoc.element.kbpgp.PgpKeyRing.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.prototype.fetch" id="apidoc.element.kbpgp.PgpKeyRing.prototype.fetch">
        function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>fetch
        <span class="apidocSignatureSpan">(key_ids, ops, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (key_ids, ops, cb) {
  var err, hex_key_ids, i, id, k, key_material, km, obj, ret_i, _i, _len, _ref;
  key_material = err = obj = null;
  hex_key_ids = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = key_ids.length; _i &#x3c; _len; _i++) {
      k = key_ids[_i];
      _results.push(hexkid(k));
    }
    return _results;
  })();
  km = null;
  for (i = _i = 0, _len = hex_key_ids.length; _i &#x3c; _len; i = ++_i) {
    id = hex_key_ids[i];
    k = this._keys[id];
    if (k != null ? (_ref = k.key) != null ? _ref.can_perform(ops) : void 0 : void 0) {
      ret_i = i;
      km = this._kms[id];
      break;
    }
  }
  if (km == null) {
    err = new Error(&#x22;key not found: &#x22; + (JSON.stringify(hex_key_ids)));
  }
  if (km) {
    return km.fetch(key_ids, ops, cb);
  } else {
    return cb(err, km, ret_i);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    obj.userid.most_recent_sig = obj.pair[0];
    ret.push(obj.userid);
  }
  return ret;
};

KeyManager.prototype.fetch = function(key_ids, flags, cb) {
  return this.pgp.<span class="apidocCodeKeywordSpan">fetch</span>(key_ids, flags, cb);
};

KeyManager.prototype.find_pgp_key = function(key_id) {
  return this.pgp.find_key(key_id);
};

KeyManager.prototype.find_pgp_key_material = function(key_id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.prototype.find_best_key" id="apidoc.element.kbpgp.PgpKeyRing.prototype.find_best_key">
        function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>find_best_key
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find_best_key = function (_arg, cb) {
  var err, flags, key, key_id, kid, km;
  key_id = _arg.key_id, flags = _arg.flags;
  if ((km = this._kms[(kid = hexkid(key_id))]) == null) {
    err = new Error(&#x22;Could not find key for fingerprint &#x22; + kid);
  } else if ((key = km.find_best_pgp_key(flags)) == null) {
    err = new Error(&#x22;no matching key for flags: &#x22; + flags);
  }
  return cb(err, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

KeyManager.prototype.find_pgp_key_material = function(key_id) {
  return this.pgp.find_key_material(key_id);
};

KeyManager.prototype.find_best_pgp_key = function(flags, need_priv) {
  return this.pgp.<span class="apidocCodeKeywordSpan">find_best_key</span>(flags, need_priv);
};

KeyManager.prototype.find_signing_pgp_key = function() {
  return this.find_best_pgp_key(C.key_flags.sign_data, true);
};

KeyManager.prototype.find_verifying_pgp_key = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.PgpKeyRing.prototype.lookup" id="apidoc.element.kbpgp.PgpKeyRing.prototype.lookup">
        function <span class="apidocSignatureSpan">kbpgp.PgpKeyRing.prototype.</span>lookup
        <span class="apidocSignatureSpan">(key_id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (key_id) {
  return this._keys[hexkid(key_id)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.SignatureEngine" id="apidoc.module.kbpgp.SignatureEngine">module kbpgp.SignatureEngine</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.SignatureEngine" id="apidoc.element.kbpgp.SignatureEngine.SignatureEngine">
        function <span class="apidocSignatureSpan">kbpgp.</span>SignatureEngine
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.SignatureEngine.__super__" id="apidoc.module.kbpgp.SignatureEngine.__super__">module kbpgp.SignatureEngine.__super__</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.box" id="apidoc.element.kbpgp.SignatureEngine.__super__.box">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>box
        <span class="apidocSignatureSpan">(msg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (msg, cb) {
  return cb(EUI);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_body" id="apidoc.element.kbpgp.SignatureEngine.__super__.get_body">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_body
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_body = function (_arg, cb) {
  var armored;
  armored = _arg.armored;
  return cb(EUI);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
    funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">get_body</span>({
    armored: armored
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return body = arguments[0];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_body_and_unverified_payload" id="apidoc.element.kbpgp.SignatureEngine.__super__.get_body_and_unverified_payload">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_body_and_unverified_payload
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_body_and_unverified_payload = function (_arg, cb) {
  var armored, body, esc, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored;
  esc = make_esc(cb, &#x22;get_body_and_unverified_payload&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
        funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
      });
      _this.get_body({
        armored: armored
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return body = arguments[0];
          };
        })(),
        lineno: 96
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
          funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
        });
        _this.get_unverified_payload_from_raw_sig_body({
          body: body
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return payload = arguments[0];
            };
          })(),
          lineno: 97
        })));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(null, body, payload);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_km" id="apidoc.element.kbpgp.SignatureEngine.__super__.get_km">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_km
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_km = function () {
  return this.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.get_unverified_payload_from_raw_sig_body" id="apidoc.element.kbpgp.SignatureEngine.__super__.get_unverified_payload_from_raw_sig_body">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>get_unverified_payload_from_raw_sig_body
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_unverified_payload_from_raw_sig_body = function (_arg, cb) {
  var body;
  body = _arg.body;
  return cb(EUI);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
    funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">get_unverified_payload_from_raw_sig_body</span>({
    body: body
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return payload = arguments[0];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.__super__.unbox" id="apidoc.element.kbpgp.SignatureEngine.__super__.unbox">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.__super__.</span>unbox
        <span class="apidocSignatureSpan">(msb, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (msb, cb) {
  return cb(EUI);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.SignatureEngine.prototype" id="apidoc.module.kbpgp.SignatureEngine.prototype">module kbpgp.SignatureEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype._check_result" id="apidoc.element.kbpgp.SignatureEngine.prototype._check_result">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>_check_result
        <span class="apidocSignatureSpan">(literals, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_result = function (literals, cb) {
  var b, err, l, n, payload, sw, _ref;
  err = payload = null;
  if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {
    err = new Error(&#x22;Expected only one pgp literal; got &#x22; + n);
  } else if ((sw = (_ref = l.get_data_signer()) != null ? _ref.sig : void 0) == null) {
    err = new Error(&#x22;Expected a signature on the payload message&#x22;);
  } else if ((this.km.find_pgp_key((b = sw.get_key_id()))) == null) {
    err = new Error(&#x22;Failed sanity check; didn&#x27;t have a key for &#x27;&#x22; + (b.toString(&#x27;hex&#x27;)) + &#x22;&#x27;&#x22;);
  } else {
    payload = l.data;
  }
  return cb(err, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          })(function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.unbox&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">_check_result</span>(literals, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return payload = arguments[0];
      };
    })(),
    lineno: 77
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.box" id="apidoc.element.kbpgp.SignatureEngine.prototype.box">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>box
        <span class="apidocSignatureSpan">(msg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (msg, cb) {
  var err, out, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  out = {
    type: &#x22;pgp&#x22;
  };
  (function(_this) {
    return (function(__iced_k) {
      if ((signing_key = _this.km.find_signing_pgp_key()) != null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
            funcname: &#x22;SignatureEngine.box&#x22;
          });
          burn({
            msg: msg,
            signing_key: signing_key
          }, __iced_deferrals.defer({
            assign_fn: (function(__slot_1, __slot_2) {
              return function() {
                err = arguments[0];
                __slot_1.pgp = arguments[1];
                return __slot_2.raw = arguments[2];
              };
            })(out, out),
            lineno: 37
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(typeof err === &#x22;undefined&#x22; || err === null ? out.armored = out.pgp : void 0);
        });
      } else {
        return __iced_k(err = new Error(&#x22;No signing key found&#x22;));
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, out);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.constructor" id="apidoc.element.kbpgp.SignatureEngine.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.decode" id="apidoc.element.kbpgp.SignatureEngine.prototype.decode">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>decode
        <span class="apidocSignatureSpan">(armored, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (armored, cb) {
  var err, msg, _ref;
  _ref = decode_sig({
    armored: armored
  }), err = _ref[0], msg = _ref[1];
  return cb(err, msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          if (typeof msg === &#x27;string&#x27;) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.unbox&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">decode</span>(msg, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return msg = arguments[0];
      };
    })(),
    lineno: 72
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_body" id="apidoc.element.kbpgp.SignatureEngine.prototype.get_body">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_body
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_body = function (args, cb) {
  var err, res, _ref;
  _ref = get_sig_body(args), err = _ref[0], res = _ref[1];
  return cb(err, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
    funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">get_body</span>({
    armored: armored
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return body = arguments[0];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_km" id="apidoc.element.kbpgp.SignatureEngine.prototype.get_km">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_km
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_km = function () {
  return this.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body" id="apidoc.element.kbpgp.SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>get_unverified_payload_from_raw_sig_body
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_unverified_payload_from_raw_sig_body = function (_arg, cb) {
  var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  body = _arg.body;
  esc = make_esc(cb, &#x22;get_payload_from_raw_sig_body&#x22;);
  payload = null;
  m = new processor.Message({});
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
        funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
      });
      m.parse_and_inflate(body, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return literals = arguments[0];
          };
        })(),
        lineno: 48
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {
        err = new Error(&#x22;Got &#x22; + n + &#x22; literals; only wanted 1&#x22;);
      } else {
        payload = l.data;
      }
      return cb(err, payload);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/kmi.iced&#x22;,
    funcname: &#x22;SignatureEngineInterface.get_body_and_unverified_payload&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">get_unverified_payload_from_raw_sig_body</span>({
    body: body
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return payload = arguments[0];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.SignatureEngine.prototype.unbox" id="apidoc.element.kbpgp.SignatureEngine.prototype.unbox">
        function <span class="apidocSignatureSpan">kbpgp.SignatureEngine.prototype.</span>unbox
        <span class="apidocSignatureSpan">(msg, cb, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (msg, cb, opts) {
  var eng, esc, literals, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  if (opts == null) {
    opts = {};
  }
  esc = make_esc(cb, &#x22;SignatureEngine::unbox&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      if (typeof msg === &#x27;string&#x27;) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
            funcname: &#x22;SignatureEngine.unbox&#x22;
          });
          _this.decode(msg, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return msg = arguments[0];
              };
            })(),
            lineno: 72
          })));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      opts.keyfetch = _this.km;
      opts.strict = true;
      eng = new processor.Message(opts);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
          funcname: &#x22;SignatureEngine.unbox&#x22;
        });
        eng.parse_and_process({
          body: msg.body
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return literals = arguments[0];
            };
          })(),
          lineno: 76
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
            funcname: &#x22;SignatureEngine.unbox&#x22;
          });
          _this._check_result(literals, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return payload = arguments[0];
              };
            })(),
            lineno: 77
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null, payload, msg.body);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.armor" id="apidoc.module.kbpgp.armor">module kbpgp.armor</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message" id="apidoc.element.kbpgp.armor.Message">
        function <span class="apidocSignatureSpan">kbpgp.armor.</span>Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.body = _arg.body, this.type = _arg.type, this.comment = _arg.comment, this.version = _arg.version, this.pre = _arg.pre, this
.post = _arg.post;
  this.lines = [];
  this.fields = {};
  this.payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {
var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
body = _arg.body;
esc = make_esc(cb, &#x22;get_payload_from_raw_sig_body&#x22;);
payload = null;
m = new processor.<span class="apidocCodeKeywordSpan">Message</span>({});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
      funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.decode" id="apidoc.element.kbpgp.armor.decode">
        function <span class="apidocSignatureSpan">kbpgp.armor.</span>decode
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (data) {
  return katch(function() {
    return (new Parser(data)).parse();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          if (typeof msg === &#x27;string&#x27;) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.unbox&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">decode</span>(msg, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return msg = arguments[0];
      };
    })(),
    lineno: 72
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.encode" id="apidoc.element.kbpgp.armor.encode">
        function <span class="apidocSignatureSpan">kbpgp.armor.</span>encode
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (type, data) {
  var mt;
  mt = C.openpgp.message_types;
  type = (function() {
    switch (type) {
      case mt.public_key:
        return &#x22;PUBLIC KEY BLOCK&#x22;;
      case mt.private_key:
        return &#x22;PRIVATE KEY BLOCK&#x22;;
      case mt.signature:
        return &#x22;SIGNATURE&#x22;;
      case mt.generic:
        return &#x22;MESSAGE&#x22;;
      default:
        throw new Error(&#x22;Cannot encode tag type &#x22; + type);
    }
  })();
  return armor.encode(Ch, type, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
KeyManager.prototype.get_all_pgp_key_ids = function() {
  return this.pgp.get_all_key_ids();
};

KeyManager.prototype.get_ekid_b64_str = function() {
  var k;
  if ((k = this.get_ekid()) != null) {
    return base64u.<span class="apidocCodeKeywordSpan">encode</span>(k);
  } else {
    return null;
  }
};

KeyManager.prototype.get_fp2 = function() {
  return this.get_pgp_fingerprint();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.mdecode" id="apidoc.element.kbpgp.armor.mdecode">
        function <span class="apidocSignatureSpan">kbpgp.armor.</span>mdecode
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mdecode = function (data) {
  return katch(function() {
    return (new Parser(data)).mparse();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.armor.Message" id="apidoc.module.kbpgp.armor.Message">module kbpgp.armor.Message</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message.Message" id="apidoc.element.kbpgp.armor.Message.Message">
        function <span class="apidocSignatureSpan">kbpgp.armor.</span>Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.body = _arg.body, this.type = _arg.type, this.comment = _arg.comment, this.version = _arg.version, this.pre = _arg.pre, this
.post = _arg.post;
  this.lines = [];
  this.fields = {};
  this.payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {
var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
body = _arg.body;
esc = make_esc(cb, &#x22;get_payload_from_raw_sig_body&#x22;);
payload = null;
m = new processor.<span class="apidocCodeKeywordSpan">Message</span>({});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
      funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.armor.Message.prototype" id="apidoc.module.kbpgp.armor.Message.prototype">module kbpgp.armor.Message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message.prototype.finish_unframe" id="apidoc.element.kbpgp.armor.Message.prototype.finish_unframe">
        function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>finish_unframe
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finish_unframe = function (_arg) {
  var post, pre;
  pre = _arg.pre, post = _arg.post;
  this.pre = this.unsplit(pre);
  this.post = this.unsplit(post);
  if (this.clearsign != null) {
    return this.clearsign.body = this.unsplit(this.clearsign.lines);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message.prototype.make_clearsign" id="apidoc.element.kbpgp.armor.Message.prototype.make_clearsign">
        function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>make_clearsign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_clearsign = function () {
  return this.clearsign = {
    headers: {},
    lines: [],
    body: null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message.prototype.raw" id="apidoc.element.kbpgp.armor.Message.prototype.raw">
        function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>raw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raw = function () {
  return this.unsplit(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return _results;
    })(),
    user_attributes: kb.user_attributes,
    userids: kb.userids,
    signed: true
  });
  if (bundle.has_pgp_private()) {
    bundle.armored_pgp_private = msg.<span class="apidocCodeKeywordSpan">raw</span>();
  } else {
    bundle.armored_pgp_public = msg.raw();
  }
}
(function(__iced_k) {
  if (err == null) {
    (function(__iced_k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.armor.Message.prototype.unsplit" id="apidoc.element.kbpgp.armor.Message.prototype.unsplit">
        function <span class="apidocSignatureSpan">kbpgp.armor.Message.prototype.</span>unsplit
        <span class="apidocSignatureSpan">(lines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsplit = function (lines) {
  return lines.join(&#x22;\n&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym" id="apidoc.module.kbpgp.asym">module kbpgp.asym</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA" id="apidoc.element.kbpgp.asym.DSA">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>DSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal" id="apidoc.element.kbpgp.asym.ElGamal">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>ElGamal
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA" id="apidoc.element.kbpgp.asym.RSA">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>RSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.get_class" id="apidoc.element.kbpgp.asym.get_class">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>get_class
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_class = function (n) {
  switch (n) {
    case C.RSA:
    case C.RSA_ENCRYPT_ONLY:
    case C.RSA_SIGN_ONLY:
      return RSA;
    case C.ELGAMAL:
      return ElGamal;
    case C.DSA:
      return DSA;
    case C.ECDSA:
      return ECDSA;
    case C.ECDH:
      return ECDH;
    case C.EDDSA:
      return EDDSA;
    default:
      throw new Error(&#x22;unknown public key system: &#x22; + n);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA" id="apidoc.module.kbpgp.asym.DSA">module kbpgp.asym.DSA</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.DSA" id="apidoc.element.kbpgp.asym.DSA.DSA">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>DSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Priv" id="apidoc.element.kbpgp.asym.DSA.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Pub" id="apidoc.element.kbpgp.asym.DSA.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.alloc" id="apidoc.element.kbpgp.asym.DSA.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>alloc
        <span class="apidocSignatureSpan">(klass, _arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (klass, _arg) {
  var err, priv, pub, _ref1, _ref2;
  pub = _arg.pub, priv = _arg.priv;
  _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];
  if ((err == null) &#x26;&#x26; (priv != null)) {
    _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];
  }
  if (err != null) {
    return [err, null];
  } else {
    return [
      null, new klass({
        priv: priv,
        pub: pub
      })
    ];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.parse" id="apidoc.element.kbpgp.asym.DSA.parse">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  return BaseKeyPair.parse(Pair, pub_raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.parse_kb" id="apidoc.element.kbpgp.asym.DSA.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.parse_sig" id="apidoc.element.kbpgp.asym.DSA.parse_sig">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>parse_sig
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_sig = function (slice) {
  var buf, err, n, ret, _ref4;
  buf = slice.peek_rest_to_buffer();
  _ref4 = Pair.read_sig_from_buf(buf), err = _ref4[0], ret = _ref4[1], n = _ref4[2];
  if (err != null) {
    throw err;
  }
  slice.advance(n);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.read_sig_from_buf" id="apidoc.element.kbpgp.asym.DSA.read_sig_from_buf">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.</span>read_sig_from_buf
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_sig_from_buf = function (buf) {
  var err, n, o, order, orig_len, ret, x;
  orig_len = buf.length;
  order = [&#x27;r&#x27;, &#x27;s&#x27;];
  err = null;
  ret = (function() {
    var _i, _len, _ref4, _results;
    _results = [];
    for (_i = 0, _len = order.length; _i &#x3c; _len; _i++) {
      o = order[_i];
      if (!(err == null)) {
        continue;
      }
      _ref4 = bn.mpi_from_buffer(buf), err = _ref4[0], x = _ref4[1], buf = _ref4[2];
      _results.push(x);
    }
    return _results;
  })();
  n = orig_len - buf.length;
  return [err, ret, n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
err = null;
if (Buffer.isBuffer(sig)) {
  _ref1 = klass.<span class="apidocCodeKeywordSpan">read_sig_from_buf</span>(sig), err = _ref1[0], sig = _ref1[1];
}
hash || (hash = hasher(data));
(function(_this) {
  return (function(__iced_k) {
    if (sig.length !== 2) {
      return __iced_k(err = new Error(&#x22;Need an [r,s] pair for a DSA-style signature&#x22;));
    } else {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA.Priv.prototype" id="apidoc.module.kbpgp.asym.DSA.Priv.prototype">module kbpgp.asym.DSA.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Priv.prototype.constructor" id="apidoc.element.kbpgp.asym.DSA.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Priv.prototype.sign" id="apidoc.element.kbpgp.asym.DSA.Priv.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Priv.prototype.</span>sign
        <span class="apidocSignatureSpan">(h, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (h, cb) {
  var err, g, hi, k, p, q, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  _ref4 = this.pub, p = _ref4.p, q = _ref4.q, g = _ref4.g;
  hi = this.pub.trunc_hash(h);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
        funcname: &#x22;Priv.sign&#x22;
      });
      SRF().random_zn(q.subtract(bn.nbv(2)), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return k = arguments[0];
          };
        })(),
        lineno: 76
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      k = k.add(bn.BigInteger.ONE);
      r = g.modPow(k, p).mod(q);
      s = (k.modInverse(q).multiply(hi.add(_this.x.multiply(r)))).mod(q);
      return cb([r, s]);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA.Pub.prototype" id="apidoc.module.kbpgp.asym.DSA.Pub.prototype">module kbpgp.asym.DSA.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.constructor" id="apidoc.element.kbpgp.asym.DSA.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.nbits" id="apidoc.element.kbpgp.asym.DSA.Pub.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  var _ref4;
  return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.trunc_hash" id="apidoc.element.kbpgp.asym.DSA.Pub.prototype.trunc_hash">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>trunc_hash
        <span class="apidocSignatureSpan">(h)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc_hash = function (h) {
  return bn.bn_from_left_n_bits(h, this.q.bitLength());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;
};

Pub.prototype.verify = function(_arg, h, cb) {
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.<span class="apidocCodeKeywordSpan">trunc_hash</span>(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.Pub.prototype.verify" id="apidoc.element.kbpgp.asym.DSA.Pub.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.Pub.prototype.</span>verify
        <span class="apidocSignatureSpan">(_arg, h, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (_arg, h, cb) {
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA.prototype" id="apidoc.module.kbpgp.asym.DSA.prototype">module kbpgp.asym.DSA.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv" id="apidoc.element.kbpgp.asym.DSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub" id="apidoc.element.kbpgp.asym.DSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.can_encrypt" id="apidoc.element.kbpgp.asym.DSA.prototype.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.constructor" id="apidoc.element.kbpgp.asym.DSA.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.fulfills_flags" id="apidoc.element.kbpgp.asym.DSA.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var good_for;
  good_for = this.good_for_flags();
  return (flags &#x26; good_for) === flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.get_type" id="apidoc.element.kbpgp.asym.DSA.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.good_for_flags" id="apidoc.element.kbpgp.asym.DSA.prototype.good_for_flags">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>good_for_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">good_for_flags = function () {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
  var good_for;
  good_for = this.<span class="apidocCodeKeywordSpan">good_for_flags</span>();
  return (flags &#x26; good_for) === flags;
};

Pair.prototype.good_for_flags = function() {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.pad_and_sign" id="apidoc.element.kbpgp.asym.DSA.prototype.pad_and_sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>pad_and_sign
        <span class="apidocSignatureSpan">(data, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_sign = function (data, _arg, cb) {
  var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hasher = _arg.hasher;
  hasher || (hasher = SHA512);
  h = hasher(data);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
        funcname: &#x22;Pair.pad_and_sign&#x22;
      });
      _this.priv.sign(h, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return sig = arguments[0];
          };
        })(),
        lineno: 128
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, Buffer.concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = sig.length; _i &#x3c; _len; _i++) {
          s = sig[_i];
          _results.push(s.to_mpi_buffer());
        }
        return _results;
      })()));
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.verify_unpad_and_check_hash" id="apidoc.element.kbpgp.asym.DSA.prototype.verify_unpad_and_check_hash">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>verify_unpad_and_check_hash
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify_unpad_and_check_hash = function (_arg, cb) {
  var data, hash, hasher, sig;
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;
  return this._dsa_verify_update_and_check_hash({
    sig: sig,
    data: data,
    hasher: hasher,
    hash: hash,
    klass: Pair
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA.prototype.Priv" id="apidoc.module.kbpgp.asym.DSA.prototype.Priv">module kbpgp.asym.DSA.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv.Priv" id="apidoc.element.kbpgp.asym.DSA.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Priv.alloc" id="apidoc.element.kbpgp.asym.DSA.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  return BaseKey.alloc(Priv, raw, {
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.DSA.prototype.Pub" id="apidoc.module.kbpgp.asym.DSA.prototype.Pub">module kbpgp.asym.DSA.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub.Pub" id="apidoc.element.kbpgp.asym.DSA.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.DSA.prototype.Pub.alloc" id="apidoc.element.kbpgp.asym.DSA.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.DSA.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  return BaseKey.alloc(Pub, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal" id="apidoc.module.kbpgp.asym.ElGamal">module kbpgp.asym.ElGamal</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.ElGamal" id="apidoc.element.kbpgp.asym.ElGamal.ElGamal">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>ElGamal
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Priv" id="apidoc.element.kbpgp.asym.ElGamal.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Pub" id="apidoc.element.kbpgp.asym.ElGamal.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.alloc" id="apidoc.element.kbpgp.asym.ElGamal.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>alloc
        <span class="apidocSignatureSpan">(klass, _arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (klass, _arg) {
  var err, priv, pub, _ref1, _ref2;
  pub = _arg.pub, priv = _arg.priv;
  _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];
  if ((err == null) &#x26;&#x26; (priv != null)) {
    _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];
  }
  if (err != null) {
    return [err, null];
  } else {
    return [
      null, new klass({
        priv: priv,
        pub: pub
      })
    ];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.parse" id="apidoc.element.kbpgp.asym.ElGamal.parse">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  var ret;
  ret = BaseKeyPair.parse(Pair, pub_raw);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.parse_kb" id="apidoc.element.kbpgp.asym.ElGamal.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.parse_output" id="apidoc.element.kbpgp.asym.ElGamal.parse_output">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.</span>parse_output
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_output = function (buf) {
  return Output.parse(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal.Priv.prototype" id="apidoc.module.kbpgp.asym.ElGamal.Priv.prototype">module kbpgp.asym.ElGamal.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.constructor" id="apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.decrypt" id="apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(c, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (c, cb) {
  var p, ret;
  p = this.pub.p;
  ret = c[0].modPow(this.x, p).modInverse(p).multiply(c[1]).mod(p);
  return cb(null, ret);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.serialize" id="apidoc.element.kbpgp.asym.ElGamal.Priv.prototype.serialize">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Priv.prototype.</span>serialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function () {
  return this.x.to_mpi_buffer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}

BaseKeyPair.prototype.serialize = function() {
  return this.pub.<span class="apidocCodeKeywordSpan">serialize</span>();
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal.Pub.prototype" id="apidoc.module.kbpgp.asym.ElGamal.Pub.prototype">module kbpgp.asym.ElGamal.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.constructor" id="apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.encrypt" id="apidoc.element.kbpgp.asym.ElGamal.Pub.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.Pub.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(m, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (m, cb) {
  var c, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
        funcname: &#x22;Pub.encrypt&#x22;
      });
      SRF().random_zn(_this.p.subtract(bn.nbv(2)), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return k = arguments[0];
          };
        })(),
        lineno: 35
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      k = k.add(bn.BigInteger.ONE);
      c = [_this.g.modPow(k, _this.p), _this.y.modPow(k, _this.p).multiply(m).mod(_this.p)];
      return cb(c);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype" id="apidoc.module.kbpgp.asym.ElGamal.prototype">module kbpgp.asym.ElGamal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.can_sign" id="apidoc.element.kbpgp.asym.ElGamal.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.constructor" id="apidoc.element.kbpgp.asym.ElGamal.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.decrypt_and_unpad" id="apidoc.element.kbpgp.asym.ElGamal.prototype.decrypt_and_unpad">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>decrypt_and_unpad
        <span class="apidocSignatureSpan">(ciphertext, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt_and_unpad = function (ciphertext, params, cb) {
  var b, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
        funcname: &#x22;Pair.decrypt_and_unpad&#x22;
      });
      _this.priv.decrypt(ciphertext.c(), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return m = arguments[1];
          };
        })(),
        lineno: 122
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _ref4;
      if (err == null) {
        b = m.to_padded_octets(_this.pub.p);
        _ref4 = eme_pkcs1_decode(b), err = _ref4[0], ret = _ref4[1];
      }
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.export_output" id="apidoc.element.kbpgp.asym.ElGamal.prototype.export_output">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>export_output
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_output = function (args) {
  return new Output(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return c_mpis = arguments[0];
          };
        })(),
        lineno: 114
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return __iced_k(ret = _this.<span class="apidocCodeKeywordSpan">export_output</span>({
        c_mpis: c_mpis
      }));
    });
  } else {
    return __iced_k();
  }
})(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.fulfills_flags" id="apidoc.element.kbpgp.asym.ElGamal.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var good_for;
  good_for = this.good_for_flags();
  return (flags &#x26; good_for) === flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.get_type" id="apidoc.element.kbpgp.asym.ElGamal.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.good_for_flags" id="apidoc.element.kbpgp.asym.ElGamal.prototype.good_for_flags">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>good_for_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">good_for_flags = function () {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
  var good_for;
  good_for = this.<span class="apidocCodeKeywordSpan">good_for_flags</span>();
  return (flags &#x26; good_for) === flags;
};

Pair.prototype.good_for_flags = function() {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.max_value" id="apidoc.element.kbpgp.asym.ElGamal.prototype.max_value">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>max_value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max_value = function () {
  return this.pub.p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.read_priv = function(raw_priv) {
  var err, _ref1;
  _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];
  return err;
};

BaseKeyPair.prototype.find = function(i) {
  return i.mod(this.<span class="apidocCodeKeywordSpan">max_value</span>());
};

BaseKeyPair.prototype.hide = function(_arg, cb) {
  var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  i = _arg.i, max = _arg.max, slosh = _arg.slosh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.pad_and_encrypt" id="apidoc.element.kbpgp.asym.ElGamal.prototype.pad_and_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>pad_and_encrypt
        <span class="apidocSignatureSpan">(data, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_encrypt = function (data, params, cb) {
  var c_mpis, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
        funcname: &#x22;Pair.pad_and_encrypt&#x22;
      });
      eme_pkcs1_encode(data, _this.pub.p.mpi_byte_length(), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return m = arguments[1];
          };
        })(),
        lineno: 112
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
              funcname: &#x22;Pair.pad_and_encrypt&#x22;
            });
            _this.pub.encrypt(m, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return c_mpis = arguments[0];
                };
              })(),
              lineno: 114
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(ret = _this.export_output({
              c_mpis: c_mpis
            }));
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, ret);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._encrypt_session_key_once&#x22;
  });
  pub_k.<span class="apidocCodeKeywordSpan">pad_and_encrypt</span>(payload, {
    fingerprint: fingerprint
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return ekey = arguments[0];
      };
    })(),
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype.Priv" id="apidoc.module.kbpgp.asym.ElGamal.prototype.Priv">module kbpgp.asym.ElGamal.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.Priv" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.alloc" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  return BaseKey.alloc(Priv, raw, {
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.ElGamal.prototype.Pub" id="apidoc.module.kbpgp.asym.ElGamal.prototype.Pub">module kbpgp.asym.ElGamal.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.Pub" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.alloc" id="apidoc.element.kbpgp.asym.ElGamal.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.ElGamal.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  return BaseKey.alloc(Pub, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA" id="apidoc.module.kbpgp.asym.RSA">module kbpgp.asym.RSA</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.RSA" id="apidoc.element.kbpgp.asym.RSA.RSA">
        function <span class="apidocSignatureSpan">kbpgp.asym.</span>RSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv" id="apidoc.element.kbpgp.asym.RSA.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg
.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub" id="apidoc.element.kbpgp.asym.RSA.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.alloc" id="apidoc.element.kbpgp.asym.RSA.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>alloc
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  return BaseKeyPair.alloc({
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.generate" id="apidoc.element.kbpgp.asym.RSA.generate">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var asp, e, e_orig, esc, go, iters, key, lambda, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;
  e || (e = (1 &#x3c;&#x3c; 16) + 1);
  e_orig = e;
  nbits || (nbits = 4096);
  iters || (iters = 10);
  asp || (asp = new ASP({}));
  e = nbv(e_orig);
  esc = make_esc(cb, &#x22;generate_rsa_keypair&#x22;);
  go = true;
  nbits &#x3e;&#x3e;= 1;
  (function(_this) {
    return (function(__iced_k) {
      var _while;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!go) {
          return _break();
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
              funcname: &#x22;Pair.generate&#x22;
            });
            random_prime({
              asp: asp.section(&#x27;p&#x27;),
              e: e,
              nbits: nbits,
              iters: iters
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return p = arguments[0];
                };
              })(),
              lineno: 363
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
                funcname: &#x22;Pair.generate&#x22;
              });
              asp.progress({
                what: &#x22;found&#x22;,
                p: p
              }, esc(__iced_deferrals.defer({
                lineno: 364
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
                  funcname: &#x22;Pair.generate&#x22;
                });
                random_prime({
                  asp: asp.section(&#x27;q&#x27;),
                  e: e,
                  nbits: nbits,
                  iters: iters
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return q = arguments[0];
                    };
                  })(),
                  lineno: 365
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
                    funcname: &#x22;Pair.generate&#x22;
                  });
                  asp.progress({
                    what: &#x22;found&#x22;,
                    q: q
                  }, esc(__iced_deferrals.defer({
                    lineno: 366
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  var _ref5;
                  if (p.compareTo(q) &#x3c;= 0) {
                    _ref5 = [q, p], p = _ref5[0], q = _ref5[1];
                  }
                  q1 = q.subtract(BigInteger.ONE);
                  p1 = p.subtract(BigInteger.ONE);
                  phi = p1.multiply(q1);
                  lambda = phi.divide(q1.gcd(p1));
                  return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === &#x22;function&#x22; ? progress_hook
({
                    what: &#x22;unlucky_phi&#x22;
                  }) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.make" id="apidoc.element.kbpgp.asym.RSA.make">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>make
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (_arg) {
  var d, dmp1, dmq1, e, lambda, n, p, p1, phi, priv, pub, q, q1, u;
  p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1, lambda = _arg.lambda;
  n = p.multiply(q);
  d = e.modInverse(lambda);
  dmp1 = d.mod(p1);
  dmq1 = d.mod(q1);
  u = p.modInverse(q);
  pub = new Pub({
    n: n,
    e: e
  });
  priv = new Priv({
    p: p,
    q: q,
    d: d,
    dmp1: dmp1,
    dmq1: dmq1,
    u: u,
    pub: pub
  });
  return new Pair({
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
      }
    };
    _while(__iced_k);
  });
})(this)((function(_this) {
  return function() {
    key = Pair.<span class="apidocCodeKeywordSpan">make</span>({
      p: p,
      q: q,
      e: e,
      phi: phi,
      p1: p1,
      q1: q1,
      lambda: lambda
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.parse" id="apidoc.element.kbpgp.asym.RSA.parse">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  return BaseKeyPair.parse(Pair, pub_raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.parse_kb" id="apidoc.element.kbpgp.asym.RSA.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.parse_output" id="apidoc.element.kbpgp.asym.RSA.parse_output">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_output
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_output = function (buf) {
  return Output.parse(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.parse_sig" id="apidoc.element.kbpgp.asym.RSA.parse_sig">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>parse_sig
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_sig = function (slice) {
  var err, n, raw, ret, _ref5;
  _ref5 = bn.mpi_from_buffer(slice.peek_rest_to_buffer()), err = _ref5[0], ret = _ref5[1], raw = _ref5[2], n = _ref5[3];
  if (err != null) {
    throw err;
  }
  slice.advance(n);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.subkey_algo" id="apidoc.element.kbpgp.asym.RSA.subkey_algo">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.</span>subkey_algo
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subkey_algo = function (flags) {
  return Pair;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return _results;
})());
for (_i = 0, _len = subkeys.length; _i &#x3c; _len; _i++) {
  subkey = subkeys[_i];
  subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);
  subkey.flags || (subkey.flags = KEY_FLAGS_STD);
  subkey.algo || (subkey.algo = primary.algo.<span class="apidocCodeKeywordSpan">subkey_algo</span>(subkey.flags));
  subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);
}
generated || (generated = unix_time());
esc = make_esc(cb, &#x22;KeyManager::generate&#x22;);
if (userid != null) {
  userids = [userid];
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA.Priv.prototype" id="apidoc.module.kbpgp.asym.RSA.Priv.prototype">module kbpgp.asym.RSA.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.constructor" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg
.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.decrypt" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(c, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (c, cb) {
  var x, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Priv.decrypt&#x22;
      });
      _this.mod_pow_d_crt(c, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return x = arguments[0];
          };
        })(),
        lineno: 22
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, x);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.lambda" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.lambda">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>lambda
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lambda = function () {
  return this.phi.divide(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger.ONE)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.mod_pow_d_crt" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.mod_pow_d_crt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>mod_pow_d_crt
        <span class="apidocSignatureSpan">(x, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod_pow_d_crt = function (x, cb) {
  var n, r, r_e, r_inv, x_1, xp, xq, y, y_0, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  if (this.dP == null) {
    this.dP = this.d.mod(this.p.subtract(BigInteger.ONE));
  }
  if (this.dQ == null) {
    this.dQ = this.d.mod(this.q.subtract(BigInteger.ONE));
  }
  if (this.qInv == null) {
    this.qInv = this.q.modInverse(this.p);
  }

<span class="apidocCodeCommentSpan">  /* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat&#x27;s Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we&#x27;ll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner&#x27;s algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp &#x3e; xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod&#x27;ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, &#x22;cryptographic blinding&#x22;
    should be used (*Not yet implemented*). This requires simply
    generating a random number r between 0 and n-1 and its inverse
    and multiplying x by r^e before calculating y and then multiplying
    y by r^-1 afterwards.
   */
</span>  n = this.pub.n;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Priv.mod_pow_d_crt&#x22;
      });
      SRF().random_zn(n, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return r = arguments[0];
          };
        })(),
        lineno: 141
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
    funcname: &#x22;Priv.decrypt&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">mod_pow_d_crt</span>(c, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return x = arguments[0];
      };
    })(),
    lineno: 22
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.n" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.n">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>n
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n = function () {
  return this.p.multiply(this.q);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Pair;
};

Pair.prototype.sanity_check = function(cb) {
  var err, x0, x1, x2, y0, y1, y2, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = this.priv.<span class="apidocCodeKeywordSpan">n</span>().compareTo(this.pub.n) === 0 ? null : new Error(&#x22;pq != n&#x22
;);
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        x0 = MRF().random_zn(_this.pub.n);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.phi" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.phi">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>phi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">phi = function () {
  return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Priv.prototype.sign" id="apidoc.element.kbpgp.asym.RSA.Priv.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Priv.prototype.</span>sign
        <span class="apidocSignatureSpan">(m, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (m, cb) {
  return this.mod_pow_d_crt(m, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA.Pub.prototype" id="apidoc.module.kbpgp.asym.RSA.Pub.prototype">module kbpgp.asym.RSA.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.constructor" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.encrypt" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(p, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (p, cb) {
  return this.mod_pow(p, this.e, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.mod_pow" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.mod_pow">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>mod_pow
        <span class="apidocSignatureSpan">(x, d, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod_pow = function (x, d, cb) {
  return cb(x.modPow(d, this.n));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pub.prototype.ORDER = Pub.ORDER;

function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}

Pub.prototype.encrypt = function(p, cb) {
  return this.<span class="apidocCodeKeywordSpan">mod_pow</span>(p, this.e, cb);
};

Pub.prototype.verify = function(s, cb) {
  return this.mod_pow(s, this.e, cb);
};

Pub.prototype.nbits = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.nbits" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  var _ref5;
  return (_ref5 = this.n) != null ? _ref5.bitLength() : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.validity_check" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.validity_check">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>validity_check
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validity_check = function (cb) {
  var err;
  err = !this.n.gcd(this.e).equals(BigInteger.ONE) ? new Error(&#x22;gcd(n,e) != 1&#x22;) : !this.n.mod(nbv(2)).equals(BigInteger.ONE) ? new
 Error(&#x22;n % 2 != 1&#x22;) : this.e.compareTo(BigInteger.ONE) &#x3c;= 0 ? new Error(&#x22;e &#x3c;= 1&#x22;) : this.e.bitLength() &#x3e; 32 ? new Error(&#x22;e=&#x22; +
this.e + &#x22; &#x3e; 2^32&#x22;) : null;
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return function() {
      return cb(err, ret);
    };
  })(this));
};

BaseKeyPair.prototype.validity_check = function(cb) {
  return this.pub.<span class="apidocCodeKeywordSpan">validity_check</span>(cb);
};

BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
  var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.Pub.prototype.verify" id="apidoc.element.kbpgp.asym.RSA.Pub.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.Pub.prototype.</span>verify
        <span class="apidocSignatureSpan">(s, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (s, cb) {
  return this.mod_pow(s, this.e, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA.prototype" id="apidoc.module.kbpgp.asym.RSA.prototype">module kbpgp.asym.RSA.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv" id="apidoc.element.kbpgp.asym.RSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg
.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub" id="apidoc.element.kbpgp.asym.RSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.constructor" id="apidoc.element.kbpgp.asym.RSA.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.decrypt" id="apidoc.element.kbpgp.asym.RSA.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(c, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (c, cb) {
  return this.priv.decrypt(c, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.decrypt_and_unpad" id="apidoc.element.kbpgp.asym.RSA.prototype.decrypt_and_unpad">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>decrypt_and_unpad
        <span class="apidocSignatureSpan">(ciphertext, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt_and_unpad = function (ciphertext, params, cb) {
  var b, err, p, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Pair.decrypt_and_unpad&#x22;
      });
      _this.decrypt(ciphertext.y(), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return p = arguments[1];
          };
        })(),
        lineno: 318
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _ref5;
      if (err == null) {
        b = p.to_padded_octets(_this.pub.n);
        _ref5 = eme_pkcs1_decode(b), err = _ref5[0], ret = _ref5[1];
      }
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.encrypt" id="apidoc.element.kbpgp.asym.RSA.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(p, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (p, cb) {
  return this.pub.encrypt(p, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.export_output" id="apidoc.element.kbpgp.asym.RSA.prototype.export_output">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>export_output
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_output = function (args) {
  return new Output(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return c_mpis = arguments[0];
          };
        })(),
        lineno: 114
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return __iced_k(ret = _this.<span class="apidocCodeKeywordSpan">export_output</span>({
        c_mpis: c_mpis
      }));
    });
  } else {
    return __iced_k();
  }
})(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.get_type" id="apidoc.element.kbpgp.asym.RSA.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.max_value" id="apidoc.element.kbpgp.asym.RSA.prototype.max_value">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>max_value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max_value = function () {
  return this.pub.n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.read_priv = function(raw_priv) {
  var err, _ref1;
  _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];
  return err;
};

BaseKeyPair.prototype.find = function(i) {
  return i.mod(this.<span class="apidocCodeKeywordSpan">max_value</span>());
};

BaseKeyPair.prototype.hide = function(_arg, cb) {
  var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  i = _arg.i, max = _arg.max, slosh = _arg.slosh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.pad_and_encrypt" id="apidoc.element.kbpgp.asym.RSA.prototype.pad_and_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>pad_and_encrypt
        <span class="apidocSignatureSpan">(data, params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_encrypt = function (data, params, cb) {
  var ct, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Pair.pad_and_encrypt&#x22;
      });
      eme_pkcs1_encode(data, _this.pub.n.mpi_byte_length(), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return m = arguments[1];
          };
        })(),
        lineno: 306
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
              funcname: &#x22;Pair.pad_and_encrypt&#x22;
            });
            _this.encrypt(m, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ct = arguments[0];
                };
              })(),
              lineno: 308
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(ret = _this.export_output({
              y_mpi: ct
            }));
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, ret);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._encrypt_session_key_once&#x22;
  });
  pub_k.<span class="apidocCodeKeywordSpan">pad_and_encrypt</span>(payload, {
    fingerprint: fingerprint
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return ekey = arguments[0];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.pad_and_sign" id="apidoc.element.kbpgp.asym.RSA.prototype.pad_and_sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>pad_and_sign
        <span class="apidocSignatureSpan">(data, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_sign = function (data, _arg, cb) {
  var hashed_data, hasher, m, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hasher = _arg.hasher;
  hasher || (hasher = SHA512);
  hashed_data = hasher(data);
  m = emsa_pkcs1_encode(hashed_data, this.pub.n.mpi_byte_length(), {
    hasher: hasher
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Pair.pad_and_sign&#x22;
      });
      _this.sign(m, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return sig = arguments[0];
          };
        })(),
        lineno: 330
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, sig.to_mpi_buffer());
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.sanity_check" id="apidoc.element.kbpgp.asym.RSA.prototype.sanity_check">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>sanity_check
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanity_check = function (cb) {
  var err, x0, x1, x2, y0, y1, y2, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = this.priv.n().compareTo(this.pub.n) === 0 ? null : new Error(&#x22;pq != n&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        x0 = MRF().random_zn(_this.pub.n);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
            funcname: &#x22;Pair.sanity_check&#x22;
          });
          _this.encrypt(x0, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return x1 = arguments[0];
              };
            })(),
            lineno: 240
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
              funcname: &#x22;Pair.sanity_check&#x22;
            });
            _this.decrypt(x1, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return x2 = arguments[1];
                };
              })(),
              lineno: 241
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k((err == null) &#x26;&#x26; x0.compareTo(x2) !== 0 ? err = new Error(&#x22;Decrypt/encrypt failed&#x22;) : void 0);
          });
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          y0 = MRF().random_zn(_this.pub.n);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
              funcname: &#x22;Pair.sanity_check&#x22;
            });
            _this.sign(y0, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return y1 = arguments[0];
                };
              })(),
              lineno: 246
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
                funcname: &#x22;Pair.sanity_check&#x22;
              });
              _this.verify(y1, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return y2 = arguments[0];
                  };
                })(),
                lineno: 247
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(y0.compareTo(y2) !== 0 ? err = new Error(&#x22;Sign/verify failed&#x22;) : void 0);
            });
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.sign" id="apidoc.element.kbpgp.asym.RSA.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>sign
        <span class="apidocSignatureSpan">(m, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (m, cb) {
  return this.priv.sign(m, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.to_openpgp" id="apidoc.element.kbpgp.asym.RSA.prototype.to_openpgp">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>to_openpgp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_openpgp = function () {
  var key;
  key = new (new RSA).keyObject();
  key.n = this.pub.n;
  key.e = this.pub.e.intValue();
  key.ee = this.pub.e;
  key.d = this.priv.d;
  key.p = this.priv.p;
  key.q = this.priv.q;
  key.dmp1 = this.priv.dmp1;
  key.dmq1 = this.priv.dmq1;
  key.u = this.priv.u;
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.validity_check" id="apidoc.element.kbpgp.asym.RSA.prototype.validity_check">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>validity_check
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validity_check = function (cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
        funcname: &#x22;Pair.validity_check&#x22;
      });
      _this.pub.validity_check(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 391
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return function() {
      return cb(err, ret);
    };
  })(this));
};

BaseKeyPair.prototype.validity_check = function(cb) {
  return this.pub.<span class="apidocCodeKeywordSpan">validity_check</span>(cb);
};

BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
  var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.verify" id="apidoc.element.kbpgp.asym.RSA.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>verify
        <span class="apidocSignatureSpan">(s, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (s, cb) {
  return this.pub.verify(s, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.verify_unpad_and_check_hash" id="apidoc.element.kbpgp.asym.RSA.prototype.verify_unpad_and_check_hash">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>verify_unpad_and_check_hash
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify_unpad_and_check_hash = function (_arg, cb) {
  var b, data, err, hash, hasher, hd1, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;
  err = null;
  if (Buffer.isBuffer(sig)) {
    _ref5 = bn.mpi_from_buffer(sig), err = _ref5[0], sig = _ref5[1];
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/rsa.iced&#x22;,
            funcname: &#x22;Pair.verify_unpad_and_check_hash&#x22;
          });
          _this.verify(sig, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return v = arguments[0];
              };
            })(),
            lineno: 339
          }));
          __iced_deferrals._fulfill();
        })(function() {
          var _ref6;
          b = v.to_padded_octets(_this.pub.n);
          _ref6 = emsa_pkcs1_decode(b, hasher), err = _ref6[0], hd1 = _ref6[1];
          return __iced_k(err == null ? (hash || (hash = hasher(data)), !bufeq_secure(hd1, hash) ? err = new Error(&#x22;hash mismatch
&#x22;) : void 0) : void 0);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA.prototype.Priv" id="apidoc.module.kbpgp.asym.RSA.prototype.Priv">module kbpgp.asym.RSA.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv.Priv" id="apidoc.element.kbpgp.asym.RSA.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg
.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Priv.alloc" id="apidoc.element.kbpgp.asym.RSA.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  return BaseKey.alloc(Priv, raw, {
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.asym.RSA.prototype.Pub" id="apidoc.module.kbpgp.asym.RSA.prototype.Pub">module kbpgp.asym.RSA.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub.Pub" id="apidoc.element.kbpgp.asym.RSA.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.n = _arg.n, this.e = _arg.e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.asym.RSA.prototype.Pub.alloc" id="apidoc.element.kbpgp.asym.RSA.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.asym.RSA.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  return BaseKey.alloc(Pub, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.base" id="apidoc.module.kbpgp.base">module kbpgp.base</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.base.BaseEccKey" id="apidoc.element.kbpgp.base.BaseEccKey">
        function <span class="apidocSignatureSpan">kbpgp.base.</span>BaseEccKey
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseEccKey(_arg) {
  this.curve = _arg.curve, this.R = _arg.R;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.base.generate" id="apidoc.element.kbpgp.base.generate">
        function <span class="apidocSignatureSpan">kbpgp.base.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var Pair, R, asp, curve, curve_name, err, nbits, priv, pub, ret, x, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1
, _ref2;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbits = _arg.nbits, asp = _arg.asp, curve_name = _arg.curve_name, Pair = _arg.Pair;
  ret = null;
  if (curve_name) {
    _ref1 = alloc_by_name(curve_name), err = _ref1[0], curve = _ref1[1];
  } else {
    _ref2 = alloc_by_nbits(nbits), err = _ref2[0], curve = _ref2[1];
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
            funcname: &#x22;generate&#x22;
          });
          curve.generate(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                x = arguments[0].x;
                return R = arguments[0].R;
              };
            })(),
            lineno: 58
          }));
          __iced_deferrals._fulfill();
        })(function() {
          pub = new Pair.Pub({
            curve: curve,
            R: R
          });
          priv = new Pair.Priv({
            pub: pub,
            x: x
          });
          return __iced_k(ret = new Pair({
            pub: pub,
            priv: priv
          }));
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.baseburner" id="apidoc.module.kbpgp.baseburner">module kbpgp.baseburner</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.baseburner.BaseBurner" id="apidoc.element.kbpgp.baseburner.BaseBurner">
        function <span class="apidocSignatureSpan">kbpgp.baseburner.</span>BaseBurner
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseBurner(_arg) {
  this.sign_with = _arg.sign_with, this.encrypt_for = _arg.encrypt_for, this.signing_key = _arg.signing_key, this.encryption_key
 = _arg.encryption_key, this.asp = _arg.asp;
  this.asp = ASP.make(this.asp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.basekeypair" id="apidoc.module.kbpgp.basekeypair">module kbpgp.basekeypair</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.basekeypair.BaseKey" id="apidoc.element.kbpgp.basekeypair.BaseKey">
        function <span class="apidocSignatureSpan">kbpgp.basekeypair.</span>BaseKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseKey() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.basekeypair.BaseKeyPair" id="apidoc.element.kbpgp.basekeypair.BaseKeyPair">
        function <span class="apidocSignatureSpan">kbpgp.basekeypair.</span>BaseKeyPair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseKeyPair(_arg) {
  this.priv = _arg.priv, this.pub = _arg.pub;
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.bn" id="apidoc.module.kbpgp.bn">module kbpgp.bn</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger" id="apidoc.element.kbpgp.bn.BigInteger">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
	   // bigi has this, so add it in...
	   if (!(this instanceof BigInteger))
	     return new BigInteger(a, b, c)
	   if(a != null)
	     if(&#x22;number&#x22; == typeof a) this.fromNumber(a,b,c);
	     else if(b == null &#x26;&#x26; &#x22;string&#x22; != typeof a) this.fromString(a,256);
	     else this.fromString(a,b);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.bn_from_left_n_bits" id="apidoc.element.kbpgp.bn.bn_from_left_n_bits">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>bn_from_left_n_bits
        <span class="apidocSignatureSpan">(raw, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bn_from_left_n_bits = function (raw, bits) {
  var buf, bytes, rem, ret;
  if (raw.length * 8 &#x3c;= bits) {
    return nbi().fromBuffer(raw);
  } else {
    rem = bits % 8;
    bytes = (bits &#x3e;&#x3e; 3) + (rem ? 1 : 0);
    buf = raw.slice(0, bytes);
    ret = nbi().fromBuffer(buf);
    if (rem &#x3e; 0) {
      ret = ret.shiftRight(8 - rem);
    }
    return ret;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Pub.alloc = function(raw) {
  return BaseKey.alloc(Pub, raw);
};

Pub.prototype.trunc_hash = function(h) {
  return bn.<span class="apidocCodeKeywordSpan">bn_from_left_n_bits</span>(h, this.q.bitLength());
};

Pub.prototype.nbits = function() {
  var _ref4;
  return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.buffer_shift_right" id="apidoc.element.kbpgp.bn.buffer_shift_right">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>buffer_shift_right
        <span class="apidocSignatureSpan">(buf, nbits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer_shift_right = function (buf, nbits) {
  var c, i, l, mask, nbytes, nxt, rem, _i, _ref1;
  nbytes = nbits &#x3e;&#x3e; 3;
  rem = nbits % 8;
  buf = buf.slice(0, buf.length - nbytes);
  l = buf.length;
  mask = (1 &#x3c;&#x3c; rem) - 1;
  for (i = _i = _ref1 = l - 1; _ref1 &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = _ref1 &#x3c;= 0 ? ++_i : --_i) {
    c = buf.readUInt8(i) &#x3e;&#x3e; rem;
    if (i &#x3e; 0) {
      nxt = buf.readUInt8(i - 1) &#x26; mask;
      c |= nxt &#x3c;&#x3c; (8 - rem);
    }
    buf.writeUInt8(c, i);
  }
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.mpi_from_buffer" id="apidoc.element.kbpgp.bn.mpi_from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>mpi_from_buffer
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_from_buffer = function (raw) {
  var err, hdr, i, n_bits, n_bytes;
  err = i = null;
  if (raw.length &#x3c; 2) {
    err = new Error(&#x22;need at least 2 bytes; got &#x22; + raw.length);
  } else {
    hdr = new Buffer(raw.slice(0, 2));
    raw = raw.slice(2);
    n_bits = hdr.readUInt16BE(0);
    n_bytes = Math.ceil(n_bits / 8);
    if (raw.length &#x3c; n_bytes) {
      err = new Error(&#x22;MPI said &#x22; + n_bytes + &#x22; bytes but only got &#x22; + raw.length);
    } else {
      i = nbi().fromBuffer(raw.slice(0, n_bytes));
      raw = raw.slice(n_bytes);
    }
  }
  return [err, i, raw, n_bytes + 2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
orig_len = raw.length;
err = null;
_ref1 = klass.ORDER;
for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
  o = _ref1[_i];
  if (err == null) {
    _ref2 = bn.<span class="apidocCodeKeywordSpan">mpi_from_buffer</span>(raw), err = _ref2[0], d[o] = _ref2[1], raw = _ref2[2];
  }
}
if (err) {
  return [err, null];
} else {
  return [null, new klass(d), orig_len - raw.length];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.mpi_to_padded_octets" id="apidoc.element.kbpgp.bn.mpi_to_padded_octets">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>mpi_to_padded_octets
        <span class="apidocSignatureSpan">(bn, base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_to_padded_octets = function (bn, base) {
  var ba, diff, i, n, pad;
  n = base.mpi_byte_length();
  ba = bn.toByteArray();
  diff = n - ba.length;
  pad = new Buffer((function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; 0 &#x3c;= diff ? _i &#x3c; diff : _i &#x3e; diff; i = 0 &#x3c;= diff ? ++_i : --_i) {
      _results.push(0);
    }
    return _results;
  })());
  return Buffer.concat([pad, new Buffer(ba)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.nbi" id="apidoc.element.kbpgp.bn.nbi">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nbi() { return new BigInteger(null); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.nbits" id="apidoc.element.kbpgp.bn.nbits">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbits
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nbits(x) {
	 	var n = 1, t;
	 	if ((t = x &#x3e;&#x3e;&#x3e; 16) != 0) {
	 		x = t;
	 		n += 16;
	 	}
	 	if ((t = x &#x3e;&#x3e; 8) != 0) {
	 		x = t;
	 		n += 8;
	 	}
	 	if ((t = x &#x3e;&#x3e; 4) != 0) {
	 		x = t;
	 		n += 4;
	 	}
	 	if ((t = x &#x3e;&#x3e; 2) != 0) {
	 		x = t;
	 		n += 2;
	 	}
	 	if ((t = x &#x3e;&#x3e; 1) != 0) {
	 		x = t;
	 		n += 1;
	 	}
	 	return n;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.nbs" id="apidoc.element.kbpgp.bn.nbs">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbs
        <span class="apidocSignatureSpan">(s, base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbs = function (s, base) {
  var r;
  if (base == null) {
    base = 10;
  }
  r = nbi();
  return r.fromString(s, base);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.nbv" id="apidoc.element.kbpgp.bn.nbv">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>nbv
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nbv(i) { var r = nbi(); r.fromInt(i); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Priv.sign&#x22;
  });
  SRF().random_zn(q.subtract(bn.<span class="apidocCodeKeywordSpan">nbv</span>(2)), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return k = arguments[0];
      };
    })(),
    lineno: 76
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.toMPI" id="apidoc.element.kbpgp.bn.toMPI">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>toMPI
        <span class="apidocSignatureSpan">(bn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toMPI = function (bn) {
  var ba, hdr, size;
  ba = bn.toByteArray();
  size = (ba.length - 1) * 8 + nbits(ba[0]);
  hdr = new Buffer(2);
  hdr.writeUInt16BE(size, 0);
  return Buffer.concat([hdr, new Buffer(ba)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.bn.BigInteger" id="apidoc.module.kbpgp.bn.BigInteger">module kbpgp.bn.BigInteger</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.BigInteger" id="apidoc.element.kbpgp.bn.BigInteger.BigInteger">
        function <span class="apidocSignatureSpan">kbpgp.bn.</span>BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
	   // bigi has this, so add it in...
	   if (!(this instanceof BigInteger))
	     return new BigInteger(a, b, c)
	   if(a != null)
	     if(&#x22;number&#x22; == typeof a) this.fromNumber(a,b,c);
	     else if(b == null &#x26;&#x26; &#x22;string&#x22; != typeof a) this.fromString(a,256);
	     else this.fromString(a,b);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.fromBuffer" id="apidoc.element.kbpgp.bn.BigInteger.fromBuffer">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromBuffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBuffer = function (buf) {
	 	var ret = nbi();
	 	ret.fromBuffer(buf);
	 	return ret;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    a = _ref1[i];
    this.lookup[a] = i;
  }
}

BaseX.prototype.encode = function(buffer) {
  var c, chars, num, pad, q, r, _i, _len;
  num = nbi().<span class="apidocCodeKeywordSpan">fromBuffer</span>(buffer);
  chars = (function() {
    var _ref1, _results;
    _results = [];
    while (num.compareTo(BigInteger.ZERO) &#x3e; 0) {
      _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];
      c = this.alphabet[r.intValue()];
      num = q;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.fromByteArrayUnsigned" id="apidoc.element.kbpgp.bn.BigInteger.fromByteArrayUnsigned">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromByteArrayUnsigned
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromByteArrayUnsigned = function (b) {
	 	return BigInteger.fromBuffer(new Buffer(b));
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.fromDERInteger" id="apidoc.element.kbpgp.bn.BigInteger.fromDERInteger">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromDERInteger
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromDERInteger = function (buf) {
	 	var x = nbi();
	 	x.fromString(buf, 256, false);
	 	return x;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.fromHex" id="apidoc.element.kbpgp.bn.BigInteger.fromHex">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>fromHex
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromHex = function (s) {
	
	 	if (!s.match(/^[a-fA-F0-9]*$/)) { throw new Error(&#x22;hex string invalid: &#x22;+ s); }
	 	if (s.length % 2 != 0) { throw new Error(&#x22;got an odd-length hex-string&#x22;); }
	 	return new BigInteger(s, 16);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.random_nbit" id="apidoc.element.kbpgp.bn.BigInteger.random_nbit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>random_nbit
        <span class="apidocSignatureSpan">(nbits, rf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random_nbit = function (nbits, rf) {
	 	return new BigInteger(nbits, rf);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r_bits = (max - L) + slosh;
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair.hide&#x22;
  });
  SRF().<span class="apidocCodeKeywordSpan">random_nbit</span>(r_bits, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return r = arguments[0];
      };
    })(),
    lineno: 127
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.valueOf" id="apidoc.element.kbpgp.bn.BigInteger.valueOf">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.</span>valueOf
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function (x) {
	 	return bigint_or_number(x);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.bn.BigInteger.prototype" id="apidoc.module.kbpgp.bn.BigInteger.prototype">module kbpgp.bn.BigInteger.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.abs" id="apidoc.element.kbpgp.bn.BigInteger.prototype.abs">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAbs() { return (this.s&#x3c;0)?this.negate():this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.add" id="apidoc.element.kbpgp.bn.BigInteger.prototype.add">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>add
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              return r = arguments[0];
            };
          })(),
          lineno: 127
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return __iced_k(ret = r.multiply(n).<span class="apidocCodeKeywordSpan">add</span>(i));
      });
    }
  });
})(this)((function(_this) {
  return function() {
    return cb(err, ret);
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.addTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.addTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>addTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpAddTo(a, r) {
	   var i = 0, c = 0, m = Math.min(a.t,this.t);
	   while(i &#x3c; m) {
	     c += this[i]+a[i];
	     r[i++] = c&#x26;this.DM;
	     c &#x3e;&#x3e;= this.DB;
	   }
	   if(a.t &#x3c; this.t) {
	     c += a.s;
	     while(i &#x3c; this.t) {
	       c += this[i];
	       r[i++] = c&#x26;this.DM;
	       c &#x3e;&#x3e;= this.DB;
	     }
	     c += this.s;
	   }
	   else {
	     c += this.s;
	     while(i &#x3c; a.t) {
	       c += a[i];
	       r[i++] = c&#x26;this.DM;
	       c &#x3e;&#x3e;= this.DB;
	     }
	     c += a.s;
	   }
	   r.s = (c&#x3c;0)?-1:0;
	   if(c &#x3e; 0) r[i++] = c;
	   else if(c &#x3c; -1) r[i++] = this.DV+c;
	   r.t = i;
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.am" id="apidoc.element.kbpgp.bn.BigInteger.prototype.am">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>am
        <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function am3(i, x, w, j, c, n) {
	   var xl = x&#x26;0x3fff, xh = x&#x3e;&#x3e;14;
	   while(--n &#x3e;= 0) {
	     var l = this[i]&#x26;0x3fff;
	     var h = this[i++]&#x3e;&#x3e;14;
	     var m = xh*l+h*xl;
	     l = xl*l+((m&#x26;0x3fff)&#x3c;&#x3c;14)+w[j]+c;
	     c = (l&#x3e;&#x3e;28)+(m&#x3e;&#x3e;14)+xh*h;
	     w[j++] = l&#x26;0xfffffff;
	   }
	   return c;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.and" id="apidoc.element.kbpgp.bn.BigInteger.prototype.and">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>and
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.andNot" id="apidoc.element.kbpgp.bn.BigInteger.prototype.andNot">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>andNot
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitCount" id="apidoc.element.kbpgp.bn.BigInteger.prototype.bitCount">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitCount() {
	   var r = 0, x = this.s&#x26;this.DM;
	   for(var i = 0; i &#x3c; this.t; ++i) r += cbit(this[i]^x);
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitLength" id="apidoc.element.kbpgp.bn.BigInteger.prototype.bitLength">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitLength() {
	   if(this.t &#x3c;= 0) return 0;
	   return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&#x26;this.DM));
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
i = _arg.i, max = _arg.max, slosh = _arg.slosh;
ret = err = null;
n = this.max_value();
(function(_this) {
  return (function(__iced_k) {
    if ((L = n.<span class="apidocCodeKeywordSpan">bitLength</span>()) &#x3e; max) {
      return __iced_k(err = new Error(&#x22;Can&#x27;t hide &#x3e; &#x22; + max + &#x22; bits; got &#x22; + L));
    } else {
      r_bits = (max - L) + slosh;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.bitwiseTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.bitwiseTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>bitwiseTo
        <span class="apidocSignatureSpan">(a, op, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpBitwiseTo(a, op, r) {
	   var i, f, m = Math.min(a.t,this.t);
	   for(i = 0; i &#x3c; m; ++i) r[i] = op(this[i],a[i]);
	   if(a.t &#x3c; this.t) {
	     f = a.s&#x26;this.DM;
	     for(i = m; i &#x3c; this.t; ++i) r[i] = op(this[i],f);
	     r.t = this.t;
	   }
	   else {
	     f = this.s&#x26;this.DM;
	     for(i = m; i &#x3c; a.t; ++i) r[i] = op(f,a[i]);
	     r.t = a.t;
	   }
	   r.s = op(this.s,a.s);
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.byteLength" id="apidoc.element.kbpgp.bn.BigInteger.prototype.byteLength">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>byteLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteLength = function () { return this.t; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fta = new Avg();

fermat2_test = function(n) {
  var Bl, bl, i, ret, t, _i;
  t = nbv(1);
  bl = n.bitLength();
  bl--;
  Bl = n.<span class="apidocCodeKeywordSpan">byteLength</span>();
  for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
    t = t.square();
    if (t.byteLength() &#x3e; Bl) {
      t = t.mod(n);
    }
    if (n.testBit(i)) {
      t = t.shiftLeft(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.byteValue" id="apidoc.element.kbpgp.bn.BigInteger.prototype.byteValue">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>byteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnByteValue() { return (this.t==0)?this.s:(this[0]&#x3c;&#x3c;24)&#x3e;&#x3e;24; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.changeBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.changeBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>changeBit
        <span class="apidocSignatureSpan">(n, op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChangeBit(n, op) {
	   var r = BigInteger.ONE.shiftLeft(n);
	   this.bitwiseTo(r,op,r);
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.chunkSize" id="apidoc.element.kbpgp.bn.BigInteger.prototype.chunkSize">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>chunkSize
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clamp" id="apidoc.element.kbpgp.bn.BigInteger.prototype.clamp">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpClamp() {
	   var c = this.s&#x26;this.DM;
	   while(this.t &#x3e; 0 &#x26;&#x26; this[this.t-1] == c) --this.t;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clearBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.clearBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clearBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClearBit(n) { return this.changeBit(n,op_andnot); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.clone" id="apidoc.element.kbpgp.bn.BigInteger.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClone() { var r = nbi(); this.copyTo(r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.compareTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.compareTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>compareTo
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnCompareTo(a) {
	   var r = this.s-a.s;
	   if(r != 0) return r;
	   var i = this.t;
	   r = i-a.t;
	   if(r != 0) return r;
	   while(--i &#x3e;= 0) if((r=this[i]-a[i]) != 0) return r;
	   return 0;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    BaseX.prototype.encode = function(buffer) {
var c, chars, num, pad, q, r, _i, _len;
num = nbi().fromBuffer(buffer);
chars = (function() {
  var _ref1, _results;
  _results = [];
  while (num.<span class="apidocCodeKeywordSpan">compareTo</span>(BigInteger.ZERO) &#x3e; 0) {
    _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];
    c = this.alphabet[r.intValue()];
    num = q;
    _results.push(c);
  }
  return _results;
}).call(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.copyTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.copyTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>copyTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpCopyTo(r) {
	   for(var i = this.t-1; i &#x3e;= 0; --i) r[i] = this[i];
	   r.t = this.t;
	   r.s = this.s;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dAddOffset" id="apidoc.element.kbpgp.bn.BigInteger.prototype.dAddOffset">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dAddOffset
        <span class="apidocSignatureSpan">(n, w)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDAddOffset(n, w) {
	   if(n == 0) return;
	   while(this.t &#x3c;= w) this[this.t++] = 0;
	   this[w] += n;
	   while(this[w] &#x3e;= this.DV) {
	     this[w] -= this.DV;
	     if(++w &#x3e;= this.t) this[this.t++] = 0;
	     ++this[w];
	   }
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dMultiply" id="apidoc.element.kbpgp.bn.BigInteger.prototype.dMultiply">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dMultiply
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDMultiply(n) {
	   this[this.t] = this.am(0,n-1,this,0,0,this.t);
	   ++this.t;
	   this.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divRemTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.divRemTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divRemTo
        <span class="apidocSignatureSpan">(m, q, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDivRemTo(m, q, r) {
	   var pm = m.abs();
	   if(pm.t &#x3c;= 0) return;
	   var pt = this.abs();
	   if(pt.t &#x3c; pm.t) {
	     if(q != null) q.fromInt(0);
	     if(r != null) this.copyTo(r);
	     return;
	   }
	   if(r == null) r = nbi();
	   var y = nbi(), ts = this.s, ms = m.s;
	   var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
	   if(nsh &#x3e; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
	   else { pm.copyTo(y); pt.copyTo(r); }
	   var ys = y.t;
	   var y0 = y[ys-1];
	   if(y0 == 0) return;
	   var yt = y0*(1&#x3c;&#x3c;this.F1)+((ys&#x3e;1)?y[ys-2]&#x3e;&#x3e;this.F2:0);
	   var d1 = this.FV/yt, d2 = (1&#x3c;&#x3c;this.F1)/yt, e = 1&#x3c;&#x3c;this.F2;
	   var i = r.t, j = i-ys, t = (q==null)?nbi():q;
	   y.dlShiftTo(j,t);
	   if(r.compareTo(t) &#x3e;= 0) {
	     r[r.t++] = 1;
	     r.subTo(t,r);
	   }
	   BigInteger.ONE.dlShiftTo(ys,t);
	   t.subTo(y,y);	// &#x22;negative&#x22; y so we can replace sub with am later
	   while(y.t &#x3c; ys) y[y.t++] = 0;
	   while(--j &#x3e;= 0) {
	     // Estimate quotient digit
	     var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
	     if((r[i]+=y.am(0,qd,r,j,0,ys)) &#x3c; qd) {	// Try it out
	       y.dlShiftTo(j,t);
	       r.subTo(t,r);
	       while(r[i] &#x3c; --qd) r.subTo(t,r);
	     }
	   }
	   if(q != null) {
	     r.drShiftTo(ys,q);
	     if(ts != ms) BigInteger.ZERO.subTo(q,q);
	   }
	   r.t = ys;
	   r.clamp();
	   if(nsh &#x3e; 0) r.rShiftTo(nsh,r);	// Denormalize remainder
	   if(ts &#x3c; 0) BigInteger.ZERO.subTo(r,r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divide" id="apidoc.element.kbpgp.bn.BigInteger.prototype.divide">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divide
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Priv.prototype.phi = function() {
  return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));
};

Priv.prototype.lambda = function() {
  return this.phi.<span class="apidocCodeKeywordSpan">divide</span>(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger
.ONE)));
};

Priv.alloc = function(raw, pub) {
  return BaseKey.alloc(Priv, raw, {
    pub: pub
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.divideAndRemainder" id="apidoc.element.kbpgp.bn.BigInteger.prototype.divideAndRemainder">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>divideAndRemainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivideAndRemainder(a) {
	   var q = nbi(), r = nbi();
	   this.divRemTo(a,q,r);
	   return new Array(q,r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BaseX.prototype.encode = function(buffer) {
var c, chars, num, pad, q, r, _i, _len;
num = nbi().fromBuffer(buffer);
chars = (function() {
  var _ref1, _results;
  _results = [];
  while (num.compareTo(BigInteger.ZERO) &#x3e; 0) {
    _ref1 = num.<span class="apidocCodeKeywordSpan">divideAndRemainder</span>(this.basebn), q = _ref1[0], r = _ref1[1];
    c = this.alphabet[r.intValue()];
    num = q;
    _results.push(c);
  }
  return _results;
}).call(this);
chars.reverse();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.dlShiftTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.dlShiftTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>dlShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDLShiftTo(n, r) {
	   var i;
	   for(i = this.t-1; i &#x3e;= 0; --i) r[i+n] = this[i];
	   for(i = n-1; i &#x3e;= 0; --i) r[i] = 0;
	   r.t = this.t+n;
	   r.s = this.s;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.drShiftTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.drShiftTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>drShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDRShiftTo(n, r) {
	   for(var i = n; i &#x3c; this.t; ++i) r[i-n] = this[i];
	   r.t = Math.max(this.t-n,0);
	   r.s = this.s;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.equals" id="apidoc.element.kbpgp.bn.BigInteger.prototype.equals">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>equals
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnEquals(a) { return(this.compareTo(a)==0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.<span class="apidocCodeKeywordSpan">equals</span>(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
  return cb(err);
};

return Pub;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.exp" id="apidoc.element.kbpgp.bn.BigInteger.prototype.exp">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>exp
        <span class="apidocSignatureSpan">(e, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpExp(e, z) {
	   if(e &#x3e; 0xffffffff || e &#x3c; 1) return BigInteger.ONE;
	   var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
	   g.copyTo(r);
	   while(--i &#x3e;= 0) {
	     z.sqrTo(r,r2);
	     if((e&#x26;(1&#x3c;&#x3c;i)) &#x3e; 0) z.mulTo(r2,g,r);
	     else { var t = r; r = r2; r2 = t; }
	   }
	   return z.revert(r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.flipBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.flipBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>flipBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnFlipBit(n) { return this.changeBit(n,op_xor); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromBuffer" id="apidoc.element.kbpgp.bn.BigInteger.prototype.fromBuffer">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromBuffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBuffer = function (buf) {
	     // the last &#x27;true&#x27; is for &#x27;unsigned&#x27;, our hack to jsbn.js to
	     // shut off DER-integer interpretation
	 	this.fromString(buffer_to_ui8a(buf), 256, true);
	 	return this;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    a = _ref1[i];
    this.lookup[a] = i;
  }
}

BaseX.prototype.encode = function(buffer) {
  var c, chars, num, pad, q, r, _i, _len;
  num = nbi().<span class="apidocCodeKeywordSpan">fromBuffer</span>(buffer);
  chars = (function() {
    var _ref1, _results;
    _results = [];
    while (num.compareTo(BigInteger.ZERO) &#x3e; 0) {
      _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];
      c = this.alphabet[r.intValue()];
      num = q;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromInt" id="apidoc.element.kbpgp.bn.BigInteger.prototype.fromInt">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromInt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromInt(x) {
	   this.t = 1;
	   this.s = (x&#x3c;0)?-1:0;
	   if(x &#x3e; 0) this[0] = x;
	   else if(x &#x3c; -1) this[0] = x+this.DV;
	   else this.t = 0;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromNumber" id="apidoc.element.kbpgp.bn.BigInteger.prototype.fromNumber">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromNumber
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromNumber(a, b, c) {
	   if(&#x22;number&#x22; == typeof b) {
	     // new BigInteger(int,int,RNG)
	     if(a &#x3c; 2) this.fromInt(1);
	     else {
	       this.fromNumber(a,c);
	       if(!this.testBit(a-1))	// force MSB set
	         this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
	       if(this.isEven()) this.dAddOffset(1,0); // force odd
	       while(!this.isProbablePrime(b)) {
	         this.dAddOffset(2,0);
	         if(this.bitLength() &#x3e; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
	       }
	     }
	   }
	   else {
	     // new BigInteger(int,RNG)
	     var x = new Array(), t = a&#x26;7;
	     x.length = (a&#x3e;&#x3e;3)+1;
	     b.nextBytes(x);
	     if(t &#x3e; 0) x[0] &#x26;= ((1&#x3c;&#x3c;t)-1); else x[0] = 0;
	     this.fromString(x,256);
	   }
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromRadix" id="apidoc.element.kbpgp.bn.BigInteger.prototype.fromRadix">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromRadix
        <span class="apidocSignatureSpan">(s, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromRadix(s, b) {
	   this.fromInt(0);
	   if(b == null) b = 10;
	   var cs = this.chunkSize(b);
	   var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
	   for(var i = 0; i &#x3c; s.length; ++i) {
	     var x = intAt(s,i);
	     if(x &#x3c; 0) {
	       if(s.charAt(i) == &#x22;-&#x22; &#x26;&#x26; this.signum() == 0) mi = true;
	       continue;
	     }
	     w = b*w+x;
	     if(++j &#x3e;= cs) {
	       this.dMultiply(d);
	       this.dAddOffset(w,0);
	       j = 0;
	       w = 0;
	     }
	   }
	   if(j &#x3e; 0) {
	     this.dMultiply(Math.pow(b,j));
	     this.dAddOffset(w,0);
	   }
	   if(mi) BigInteger.ZERO.subTo(this,this);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.fromString" id="apidoc.element.kbpgp.bn.BigInteger.prototype.fromString">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>fromString
        <span class="apidocSignatureSpan">(s, b, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromString(s, b, unsigned) {
	   var k;
	   if(b == 16) k = 4;
	   else if(b == 8) k = 3;
	   else if(b == 256) k = 8; // byte array
	   else if(b == 2) k = 1;
	   else if(b == 32) k = 5;
	   else if(b == 4) k = 2;
	   else { this.fromRadix(s,b); return this; }
	   this.t = 0;
	   this.s = 0;
	   var i = s.length, mi = false, sh = 0;
	   while(--i &#x3e;= 0) {
	     var x = (k==8)?s[i]&#x26;0xff:intAt(s,i);
	     if(x &#x3c; 0) {
	       if(s.charAt(i) == &#x22;-&#x22;) mi = true;
	       continue;
	     }
	     mi = false;
	     if(sh == 0)
	       this[this.t++] = x;
	     else if(sh+k &#x3e; this.DB) {
	       this[this.t-1] |= (x&#x26;((1&#x3c;&#x3c;(this.DB-sh))-1))&#x3c;&#x3c;sh;
	       this[this.t++] = (x&#x3e;&#x3e;(this.DB-sh));
	     }
	     else
	       this[this.t-1] |= x&#x3c;&#x3c;sh;
	     sh += k;
	     if(sh &#x3e;= this.DB) sh -= this.DB;
	   }
	   if(!unsigned &#x26;&#x26; k == 8 &#x26;&#x26; (s[0]&#x26;0x80) != 0) {
	     this.s = -1;
	     if(sh &#x3e; 0) this[this.t-1] |= ((1&#x3c;&#x3c;(this.DB-sh))-1)&#x3c;&#x3c;sh;
	   }
	   this.clamp();
	   if(mi) BigInteger.ZERO.subTo(this,this);
	   return this;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.gcd" id="apidoc.element.kbpgp.bn.BigInteger.prototype.gcd">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>gcd
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGCD(a) {
	   var x = (this.s&#x3c;0)?this.negate():this.clone();
	   var y = (a.s&#x3c;0)?a.negate():a.clone();
	   if(x.compareTo(y) &#x3c; 0) { var t = x; x = y; y = t; }
	   var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	   if(g &#x3c; 0) return x;
	   if(i &#x3c; g) g = i;
	   if(g &#x3e; 0) {
	     x.rShiftTo(g,x);
	     y.rShiftTo(g,y);
	   }
	   while(x.signum() &#x3e; 0) {
	     if((i = x.getLowestSetBit()) &#x3e; 0) x.rShiftTo(i,x);
	     if((i = y.getLowestSetBit()) &#x3e; 0) y.rShiftTo(i,y);
	     if(x.compareTo(y) &#x3e;= 0) {
	       x.subTo(y,x);
	       x.rShiftTo(1,x);
	     }
	     else {
	       y.subTo(x,y);
	       y.rShiftTo(1,y);
	     }
	   }
	   if(g &#x3e; 0) y.lShiftTo(g,y);
	   return y;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })(),
    lineno: 262
  }));
  __iced_deferrals._fulfill();
})(function() {
  p = p.setBit(0).setBit(nbits - 1).setBit(nbits - 2);
  (function(__iced_k) {
    if ((e == null) || p.subtract(BigInteger.ONE).<span class="apidocCodeKeywordSpan">gcd</span>(e).compareTo(BigInteger.ONE) ===
0) {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
        });
        asp.progress({
          what: &#x22;guess&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.getLowestSetBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.getLowestSetBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>getLowestSetBit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGetLowestSetBit() {
	   for(var i = 0; i &#x3c; this.t; ++i)
	     if(this[i] != 0) return i*this.DB+lbit(this[i]);
	   if(this.s &#x3c; 0) return this.t*this.DB;
	   return -1;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ret = _MR_small_check({
  p: p
});
(function(_this) {
  return (function(__iced_k) {
    if (ret) {
      p1 = p.subtract(BigInteger.ONE);
      s = p1.<span class="apidocCodeKeywordSpan">getLowestSetBit</span>();
      r = p1.shiftRight(s);
      ret = true;
      (function(__iced_k) {
        var _begin, _end, _i, _positive, _results, _step, _while;
        i = 0;
        _begin = 0;
        _end = iter;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.inspect" id="apidoc.element.kbpgp.bn.BigInteger.prototype.inspect">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
	 	return &#x22;&#x3c;BigInteger/pure &#x22; + this.toString() + &#x22;&#x3e;&#x22;;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.intValue" id="apidoc.element.kbpgp.bn.BigInteger.prototype.intValue">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>intValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIntValue() {
	   if(this.s &#x3c; 0) {
	     if(this.t == 1) return this[0]-this.DV;
	     else if(this.t == 0) return -1;
	   }
	   else if(this.t == 1) return this[0];
	   else if(this.t == 0) return 0;
	   // assumes 16 &#x3c; DB &#x3c; 32
	   return ((this[1]&#x26;((1&#x3c;&#x3c;(32-this.DB))-1))&#x3c;&#x3c;this.DB)|this[0];
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var c, chars, num, pad, q, r, _i, _len;
num = nbi().fromBuffer(buffer);
chars = (function() {
  var _ref1, _results;
  _results = [];
  while (num.compareTo(BigInteger.ZERO) &#x3e; 0) {
    _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];
    c = this.alphabet[r.<span class="apidocCodeKeywordSpan">intValue</span>()];
    num = q;
    _results.push(c);
  }
  return _results;
}).call(this);
chars.reverse();
pad = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.invDigit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.invDigit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>invDigit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpInvDigit() {
	   if(this.t &#x3c; 1) return 0;
	   var x = this[0];
	   if((x&#x26;1) == 0) return 0;
	   var y = x&#x26;3;		// y == 1/x mod 2^2
	   y = (y*(2-(x&#x26;0xf)*y))&#x26;0xf;	// y == 1/x mod 2^4
	   y = (y*(2-(x&#x26;0xff)*y))&#x26;0xff;	// y == 1/x mod 2^8
	   y = (y*(2-(((x&#x26;0xffff)*y)&#x26;0xffff)))&#x26;0xffff;	// y == 1/x mod 2^16
	   // last step - calculate inverse mod DV directly;
	   // assumes 16 &#x3c; DB &#x3c;= 32 and assumes ability to handle 48-bit ints
	   y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
	   // we really want the negative inverse, and -DV &#x3c; y &#x3c; DV
	   return (y&#x3e;0)?this.DV-y:-y;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.isEven" id="apidoc.element.kbpgp.bn.BigInteger.prototype.isEven">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpIsEven() { return ((this.t&#x3e;0)?(this[0]&#x26;1):this.s) == 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.isProbablePrime" id="apidoc.element.kbpgp.bn.BigInteger.prototype.isProbablePrime">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>isProbablePrime
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIsProbablePrime(t) {
	   var i, x = this.abs();
	   if(x.t == 1 &#x26;&#x26; x[0] &#x3c;= lowprimes[lowprimes.length-1]) {
	     for(i = 0; i &#x3c; lowprimes.length; ++i)
	       if(x[0] == lowprimes[i]) return true;
	     return false;
	   }
	   if(x.isEven()) return false;
	   i = 1;
	   while(i &#x3c; lowprimes.length) {
	     var m = lowprimes[i], j = i+1;
	     while(j &#x3c; lowprimes.length &#x26;&#x26; m &#x3c; lplim) m *= lowprimes[j++];
	     m = x.modInt(m);
	     while(i &#x3c; j) if(m%lowprimes[i++] == 0) return false;
	   }
	   return x.millerRabin(t);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.lShiftTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.lShiftTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>lShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpLShiftTo(n, r) {
	   var bs = n%this.DB;
	   var cbs = this.DB-bs;
	   var bm = (1&#x3c;&#x3c;cbs)-1;
	   var ds = Math.floor(n/this.DB), c = (this.s&#x3c;&#x3c;bs)&#x26;this.DM, i;
	   for(i = this.t-1; i &#x3e;= 0; --i) {
	     r[i+ds+1] = (this[i]&#x3e;&#x3e;cbs)|c;
	     c = (this[i]&#x26;bm)&#x3c;&#x3c;bs;
	   }
	   for(i = ds-1; i &#x3e;= 0; --i) r[i] = 0;
	   r[ds] = c;
	   r.t = this.t+ds+1;
	   r.s = this.s;
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.max" id="apidoc.element.kbpgp.bn.BigInteger.prototype.max">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>max
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMax(a) { return(this.compareTo(a)&#x3e;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.millerRabin" id="apidoc.element.kbpgp.bn.BigInteger.prototype.millerRabin">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>millerRabin
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMillerRabin(t) {
	   var n1 = this.subtract(BigInteger.ONE);
	   var k = n1.getLowestSetBit();
	   if(k &#x3c;= 0) return false;
	   var r = n1.shiftRight(k);
	   t = (t+1)&#x3e;&#x3e;1;
	   if(t &#x3e; lowprimes.length) t = lowprimes.length;
	   var a = nbi();
	   for(var i = 0; i &#x3c; t; ++i) {
	     //Pick bases at random, instead of starting at 2
	     a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
	     var y = a.modPow(r,this);
	     if(y.compareTo(BigInteger.ONE) != 0 &#x26;&#x26; y.compareTo(n1) != 0) {
	       var j = 1;
	       while(j++ &#x3c; k &#x26;&#x26; y.compareTo(n1) != 0) {
	         y = y.modPowInt(2,this);
	         if(y.compareTo(BigInteger.ONE) == 0) return false;
	       }
	       if(y.compareTo(n1) != 0) return false;
	     }
	   }
	   return true;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.min" id="apidoc.element.kbpgp.bn.BigInteger.prototype.min">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>min
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMin(a) { return(this.compareTo(a)&#x3c;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret = this.buf.readUInt32BE(this.i);
  this.i += 4;
  this.check();
  return ret;
};

SlicerBuffer.prototype.read_buffer_at_most = function(l) {
  return this.read_buffer(Math.<span class="apidocCodeKeywordSpan">min</span>(l, this.rem()));
};

SlicerBuffer.prototype.read_buffer = function(l) {
  var ret;
  ret = this.buf.slice(this.i, this.i + l);
  this.i += l;
  this.check();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.mod" id="apidoc.element.kbpgp.bn.BigInteger.prototype.mod">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>mod
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMod(a) {
	   var r = nbi();
	   this.abs().divRemTo(a,null,r);
	   if(this.s &#x3c; 0 &#x26;&#x26; r.compareTo(BigInteger.ZERO) &#x3e; 0) a.subTo(r,r);
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.read_priv = function(raw_priv) {
  var err, _ref1;
  _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];
  return err;
};

BaseKeyPair.prototype.find = function(i) {
  return i.<span class="apidocCodeKeywordSpan">mod</span>(this.max_value());
};

BaseKeyPair.prototype.hide = function(_arg, cb) {
  var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  i = _arg.i, max = _arg.max, slosh = _arg.slosh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modInt" id="apidoc.element.kbpgp.bn.BigInteger.prototype.modInt">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpModInt(n) {
	   if(n &#x3c;= 0) return 0;
	   var d = this.DV%n, r = (this.s&#x3c;0)?n-1:0;
	   if(this.t &#x3e; 0)
	     if(d == 0) r = this[0]%n;
	     else for(var i = this.t-1; i &#x3e;= 0; --i) r = (d*r+this[i])%n;
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  return Avg;

})();

quickmod = function(p, d) {
  return p.<span class="apidocCodeKeywordSpan">modInt</span>(d);
};

fta = new Avg();

fermat2_test = function(n) {
  var Bl, bl, i, ret, t, _i;
  t = nbv(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modInverse" id="apidoc.element.kbpgp.bn.BigInteger.prototype.modInverse">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modInverse
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModInverse(m) {
	   var ac = m.isEven();
	   if((this.isEven() &#x26;&#x26; ac) || m.signum() == 0) return BigInteger.ZERO;
	   var u = m.clone(), v = this.clone();
	   var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	   while(u.signum() != 0) {
	     while(u.isEven()) {
	       u.rShiftTo(1,u);
	       if(ac) {
	         if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
	         a.rShiftTo(1,a);
	       }
	       else if(!b.isEven()) b.subTo(m,b);
	       b.rShiftTo(1,b);
	     }
	     while(v.isEven()) {
	       v.rShiftTo(1,v);
	       if(ac) {
	         if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
	         c.rShiftTo(1,c);
	       }
	       else if(!d.isEven()) d.subTo(m,d);
	       d.rShiftTo(1,d);
	     }
	     if(u.compareTo(v) &#x3e;= 0) {
	       u.subTo(v,u);
	       if(ac) a.subTo(c,a);
	       b.subTo(d,b);
	     }
	     else {
	       v.subTo(u,v);
	       if(ac) c.subTo(a,c);
	       d.subTo(b,d);
	     }
	   }
	   if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	   if(d.compareTo(m) &#x3e;= 0) return d.subtract(m);
	   if(d.signum() &#x3c; 0) d.addTo(m,d); else return d;
	   if(d.signum() &#x3c; 0) return d.add(m); else return d;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Pub.prototype.verify = function(_arg, h, cb) {
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  w = s.<span class="apidocCodeKeywordSpan">modInverse</span>(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
  return cb(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modPow" id="apidoc.element.kbpgp.bn.BigInteger.prototype.modPow">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modPow
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPow(e, m) {
	   var i = e.bitLength(), k, r = nbv(1), z;
	   if(i &#x3c;= 0) return r;
	   else if(i &#x3c; 18) k = 1;
	   else if(i &#x3c; 48) k = 3;
	   else if(i &#x3c; 144) k = 4;
	   else if(i &#x3c; 768) k = 5;
	   else k = 6;
	   if(i &#x3c; 8)
	     z = new Classic(m);
	   else if(m.isEven())
	     z = new Barrett(m);
	   else
	     z = new Montgomery(m);
	
	   // precomputation
	   var g = new Array(), n = 3, k1 = k-1, km = (1&#x3c;&#x3c;k)-1;
	   g[1] = z.convert(this);
	   if(k &#x3e; 1) {
	     var g2 = nbi();
	     z.sqrTo(g[1],g2);
	     while(n &#x3c;= km) {
	       g[n] = nbi();
	       z.mulTo(g2,g[n-2],g[n]);
	       n += 2;
	     }
	   }
	
	   var j = e.t-1, w, is1 = true, r2 = nbi(), t;
	   i = nbits(e[j])-1;
	   while(j &#x3e;= 0) {
	     if(i &#x3e;= k1) w = (e[j]&#x3e;&#x3e;(i-k1))&#x26;km;
	     else {
	       w = (e[j]&#x26;((1&#x3c;&#x3c;(i+1))-1))&#x3c;&#x3c;(k1-i);
	       if(j &#x3e; 0) w |= e[j-1]&#x3e;&#x3e;(this.DB+i-k1);
	     }
	
	     n = k;
	     while((w&#x26;1) == 0) { w &#x3e;&#x3e;= 1; --n; }
	     if((i -= n) &#x3c; 0) { i += this.DB; --j; }
	     if(is1) {	// ret == 1, don&#x27;t bother squaring or multiplying it
	       g[w].copyTo(r);
	       is1 = false;
	     }
	     else {
	       while(n &#x3e; 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
	       if(n &#x3e; 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
	       z.mulTo(r2,g[w],r);
	     }
	
	     while(j &#x3e;= 0 &#x26;&#x26; (e[j]&#x26;(1&#x3c;&#x3c;i)) == 0) {
	       z.sqrTo(r,r2); t = r; r = r2; r2 = t;
	       if(--i &#x3c; 0) { i = this.DB-1; --j; }
	     }
	   }
	   return z.revert(r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.<span class="apidocCodeKeywordSpan">modPow</span>(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this
.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
  return cb(err);
};

return Pub;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.modPowInt" id="apidoc.element.kbpgp.bn.BigInteger.prototype.modPowInt">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>modPowInt
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPowInt(e, m) {
	   var z;
	   if(e &#x3c; 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
	   return this.exp(e,z);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.mpi_byte_length" id="apidoc.element.kbpgp.bn.BigInteger.prototype.mpi_byte_length">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>mpi_byte_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_byte_length = function () {
  return mpi_byte_length(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  eme_pkcs1_encode(data, _this.pub.p.<span class="apidocCodeKeywordSpan">mpi_byte_length</span>(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 112
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiply" id="apidoc.element.kbpgp.bn.BigInteger.prototype.multiply">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiply
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              return r = arguments[0];
            };
          })(),
          lineno: 127
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return __iced_k(ret = r.<span class="apidocCodeKeywordSpan">multiply</span>(n).add(i));
      });
    }
  });
})(this)((function(_this) {
  return function() {
    return cb(err, ret);
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyLowerTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyLowerTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyLowerTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyLowerTo(a, n, r) {
	   var i = Math.min(this.t+a.t,n);
	   r.s = 0; // assumes a,this &#x3e;= 0
	   r.t = i;
	   while(i &#x3e; 0) r[--i] = 0;
	   var j;
	   for(j = r.t-this.t; i &#x3c; j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
	   for(j = Math.min(a.t,n); i &#x3c; j; ++i) this.am(0,a[i],r,i,0,n-i);
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyTo(a, r) {
	   var x = this.abs(), y = a.abs();
	   var i = x.t;
	   r.t = i+y.t;
	   while(--i &#x3e;= 0) r[i] = 0;
	   for(i = 0; i &#x3c; y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
	   r.s = 0;
	   r.clamp();
	   if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyUpperTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.multiplyUpperTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>multiplyUpperTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyUpperTo(a, n, r) {
	   --n;
	   var i = r.t = this.t+a.t-n;
	   r.s = 0; // assumes a,this &#x3e;= 0
	   while(--i &#x3e;= 0) r[i] = 0;
	   for(i = Math.max(n-this.t,0); i &#x3c; a.t; ++i)
	     r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
	   r.clamp();
	   r.drShiftTo(1,r);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.negate" id="apidoc.element.kbpgp.bn.BigInteger.prototype.negate">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.not" id="apidoc.element.kbpgp.bn.BigInteger.prototype.not">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNot() {
	   var r = nbi();
	   for(var i = 0; i &#x3c; this.t; ++i) r[i] = this.DM&#x26;~this[i];
	   r.t = this.t;
	   r.s = ~this.s;
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.or" id="apidoc.element.kbpgp.bn.BigInteger.prototype.or">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>or
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.pow" id="apidoc.element.kbpgp.bn.BigInteger.prototype.pow">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>pow
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnPow(e) { return this.exp(e,new NullExp()); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.rShiftTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.rShiftTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>rShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpRShiftTo(n, r) {
	   r.s = this.s;
	   var ds = Math.floor(n/this.DB);
	   if(ds &#x3e;= this.t) { r.t = 0; return; }
	   var bs = n%this.DB;
	   var cbs = this.DB-bs;
	   var bm = (1&#x3c;&#x3c;bs)-1;
	   r[0] = this[ds]&#x3e;&#x3e;bs;
	   for(var i = ds+1; i &#x3c; this.t; ++i) {
	     r[i-ds-1] |= (this[i]&#x26;bm)&#x3c;&#x3c;cbs;
	     r[i-ds] = this[i]&#x3e;&#x3e;bs;
	   }
	   if(bs &#x3e; 0) r[this.t-ds-1] |= (this.s&#x26;bm)&#x3c;&#x3c;cbs;
	   r.t = this.t-ds;
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.remainder" id="apidoc.element.kbpgp.bn.BigInteger.prototype.remainder">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>remainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.setBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.setBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>setBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSetBit(n) { return this.changeBit(n,op_or); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return p = arguments[0];
      };
    })(),
    lineno: 262
  }));
  __iced_deferrals._fulfill();
})(function() {
  p = p.<span class="apidocCodeKeywordSpan">setBit</span>(0).setBit(nbits - 1).setBit(nbits - 2);
  (function(__iced_k) {
    if ((e == null) || p.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shiftLeft" id="apidoc.element.kbpgp.bn.BigInteger.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftLeft(n) {
	   var r = nbi();
	   if(n &#x3c; 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Bl = n.byteLength();
for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
  t = t.square();
  if (t.byteLength() &#x3e; Bl) {
    t = t.mod(n);
  }
  if (n.testBit(i)) {
    t = t.<span class="apidocCodeKeywordSpan">shiftLeft</span>(1);
  }
}
if (t.compareTo(n) &#x3e; 0) {
  t = t.mod(n);
}
ret = t.compareTo(nbv(2)) === 0;
return ret;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shiftRight" id="apidoc.element.kbpgp.bn.BigInteger.prototype.shiftRight">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftRight(n) {
	   var r = nbi();
	   if(n &#x3c; 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  p: p
});
(function(_this) {
  return (function(__iced_k) {
    if (ret) {
      p1 = p.subtract(BigInteger.ONE);
      s = p1.getLowestSetBit();
      r = p1.<span class="apidocCodeKeywordSpan">shiftRight</span>(s);
      ret = true;
      (function(__iced_k) {
        var _begin, _end, _i, _positive, _results, _step, _while;
        i = 0;
        _begin = 0;
        _end = iter;
        if (_end &#x3e; _begin) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.shortValue" id="apidoc.element.kbpgp.bn.BigInteger.prototype.shortValue">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>shortValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShortValue() { return (this.t==0)?this.s:(this[0]&#x3c;&#x3c;16)&#x3e;&#x3e;16; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.signum" id="apidoc.element.kbpgp.bn.BigInteger.prototype.signum">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>signum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSigNum() {
	   if(this.s &#x3c; 0) return -1;
	   else if(this.t &#x3c;= 0 || (this.t == 1 &#x26;&#x26; this[0] &#x3c;= 0)) return 0;
	   else return 1;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Pub.prototype.verify = function(_arg, h, cb) {
  var err, hi, n, p, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  if ((r.<span class="apidocCodeKeywordSpan">signum</span>() &#x3c;= 0) || (r.compareTo(this.curve.p) &#x3e; 0)) {
    err = new Error(&#x22;bad r&#x22;);
  } else if ((r.signum() &#x3c;= 0) || (s.compareTo(this.curve.p) &#x3e; 0)) {
    err = new Error(&#x22;bad s&#x22;);
  } else {
    n = this.curve.n;
    w = s.modInverse(n);
    u1 = hi.multiply(w).mod(n);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.square" id="apidoc.element.kbpgp.bn.BigInteger.prototype.square">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>square
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSquare() { var r = nbi(); this.squareTo(r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fermat2_test = function(n) {
var Bl, bl, i, ret, t, _i;
t = nbv(1);
bl = n.bitLength();
bl--;
Bl = n.byteLength();
for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
  t = t.<span class="apidocCodeKeywordSpan">square</span>();
  if (t.byteLength() &#x3e; Bl) {
    t = t.mod(n);
  }
  if (n.testBit(i)) {
    t = t.shiftLeft(1);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.squareTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.squareTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>squareTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSquareTo(r) {
	   var x = this.abs();
	   var i = r.t = 2*x.t;
	   while(--i &#x3e;= 0) r[i] = 0;
	   for(i = 0; i &#x3c; x.t-1; ++i) {
	     var c = x.am(i,x[i],r,2*i,0,1);
	     if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) &#x3e;= x.DV) {
	       r[i+x.t] -= x.DV;
	       r[i+x.t+1] = 1;
	     }
	   }
	   if(r.t &#x3e; 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
	   r.s = 0;
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.subTo" id="apidoc.element.kbpgp.bn.BigInteger.prototype.subTo">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>subTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSubTo(a, r) {
	   var i = 0, c = 0, m = Math.min(a.t,this.t);
	   while(i &#x3c; m) {
	     c += this[i]-a[i];
	     r[i++] = c&#x26;this.DM;
	     c &#x3e;&#x3e;= this.DB;
	   }
	   if(a.t &#x3c; this.t) {
	     c -= a.s;
	     while(i &#x3c; this.t) {
	       c += this[i];
	       r[i++] = c&#x26;this.DM;
	       c &#x3e;&#x3e;= this.DB;
	     }
	     c += this.s;
	   }
	   else {
	     c += this.s;
	     while(i &#x3c; a.t) {
	       c -= a[i];
	       r[i++] = c&#x26;this.DM;
	       c &#x3e;&#x3e;= this.DB;
	     }
	     c -= a.s;
	   }
	   r.s = (c&#x3c;0)?-1:0;
	   if(c &#x3c; -1) r[i++] = this.DV+c;
	   else if(c &#x3e; 0) r[i++] = c;
	   r.t = i;
	   r.clamp();
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.subtract" id="apidoc.element.kbpgp.bn.BigInteger.prototype.subtract">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>subtract
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Priv.sign&#x22;
  });
  SRF().random_zn(q.<span class="apidocCodeKeywordSpan">subtract</span>(bn.nbv(2)), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return k = arguments[0];
      };
    })(),
    lineno: 76
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.testBit" id="apidoc.element.kbpgp.bn.BigInteger.prototype.testBit">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>testBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnTestBit(n) {
	   var j = Math.floor(n/this.DB);
	   if(j &#x3e;= this.t) return(this.s!=0);
	   return((this[j]&#x26;(1&#x3c;&#x3c;(n%this.DB)))!=0);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
bl--;
Bl = n.byteLength();
for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
  t = t.square();
  if (t.byteLength() &#x3e; Bl) {
    t = t.mod(n);
  }
  if (n.<span class="apidocCodeKeywordSpan">testBit</span>(i)) {
    t = t.shiftLeft(1);
  }
}
if (t.compareTo(n) &#x3e; 0) {
  t = t.mod(n);
}
ret = t.compareTo(nbv(2)) === 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toBuffer" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toBuffer">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toBuffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBuffer = function (size) {
	 	var x;
	 	if (!size) { size = 0; }
	 	var s = this.signum();
	 	if (s == 0) { x = []; }
	 	else {x = this.toByteArray(s &#x3c; 0); }
	 	var ret = new Buffer(x);
	 	if ((diff = size - x.length) &#x3e; 0) {
	 		var pad = new Buffer(diff);
	 		pad.fill(0);
	 		ret = Buffer.concat([pad,ret]);
	 	}
	 	return ret;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArray" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArray">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toByteArray
        <span class="apidocSignatureSpan">(encode_sign_bit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToByteArray(encode_sign_bit) {
	   var i = this.t, r = new Array();
	   r[0] = this.s;
	   var p = this.DB-(i*this.DB)%8, d, k = 0;
	   if(i-- &#x3e; 0) {
	     if(p &#x3c; this.DB &#x26;&#x26; (d = this[i]&#x3e;&#x3e;p) != (this.s&#x26;this.DM)&#x3e;&#x3e;p)
	       r[k++] = d|(this.s&#x3c;&#x3c;(this.DB-p));
	     while(i &#x3e;= 0) {
	       if(p &#x3c; 8) {
	         d = (this[i]&#x26;((1&#x3c;&#x3c;p)-1))&#x3c;&#x3c;(8-p);
	         d |= this[--i]&#x3e;&#x3e;(p+=this.DB-8);
	       }
	       else {
	         d = (this[i]&#x3e;&#x3e;(p-=8))&#x26;0xff;
	         if(p &#x3c;= 0) { p += this.DB; --i; }
	       }
	       if (encode_sign_bit) {
	         if((d&#x26;0x80) != 0) d |= -256;
	         if(k == 0 &#x26;&#x26; (this.s&#x26;0x80) != (d&#x26;0x80)) ++k;
	       }
	       if(k &#x3e; 0 || d != this.s) r[k++] = d;
	     }
	   }
	   return r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      c = _ref1[i];
      if ((char_index = this.lookup[c]) == null) {
        throw new Error(&#x27;Value passed is not a valid BaseX string.&#x27;);
      }
      num = num.add(base.multiply(nbv(char_index)));
      base = base.multiply(this.basebn);
    }
    return Buffer.concat([pad, new Buffer(num.<span class="apidocCodeKeywordSpan">toByteArray</span>())]);
  };

  return BaseX;

})();

exports.base58 = base58 = new BaseX(&#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArrayUnsigned" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toByteArrayUnsigned">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toByteArrayUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toByteArrayUnsigned = function () {
	 	return new Uint8Array(this.toBuffer());
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toDERInteger" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toDERInteger">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toDERInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDERInteger = function () {
	 	return this.toByteArray(true);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toHex" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toHex">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toHex
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function (size) {
	 	return this.toBuffer(size).toString(&#x27;hex&#x27;);
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toMPI" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toMPI">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toMPI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToMPI() {
	 	var ba = this.toByteArray();
	 	var size = (ba.length-1)*8+nbits(ba[0]);
	 	var result = &#x22;&#x22;;
	 	result += String.fromCharCode((size &#x26; 0xFF00) &#x3e;&#x3e; 8);
	 	result += String.fromCharCode(size &#x26; 0xFF);
	 	result += util.bin2str(ba);
	 	return result;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toRadix" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toRadix">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toRadix
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpToRadix(b) {
	   if(b == null) b = 10;
	   if(this.signum() == 0 || b &#x3c; 2 || b &#x3e; 36) return &#x22;0&#x22;;
	   var cs = this.chunkSize(b);
	   var a = Math.pow(b,cs);
	   var d = nbv(a), y = nbi(), z = nbi(), r = &#x22;&#x22;;
	   this.divRemTo(d,y,z);
	   while(y.signum() &#x3e; 0) {
	     r = (a+z.intValue()).toString(b).substr(1) + r;
	     y.divRemTo(d,y,z);
	   }
	   return z.intValue().toString(b) + r;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.toString" id="apidoc.element.kbpgp.bn.BigInteger.prototype.toString">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>toString
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToString(b) {
	   if(this.s &#x3c; 0) return &#x22;-&#x22;+this.negate().toString(b);
	   var k;
	   if(b == 16) k = 4;
	   else if(b == 8) k = 3;
	   else if(b == 2) k = 1;
	   else if(b == 32) k = 5;
	   else if(b == 4) k = 2;
	   else return this.toRadix(b);
	   var km = (1&#x3c;&#x3c;k)-1, d, m = false, r = &#x22;&#x22;, i = this.t;
	   var p = this.DB-(i*this.DB)%k;
	   if(i-- &#x3e; 0) {
	     if(p &#x3c; this.DB &#x26;&#x26; (d = this[i]&#x3e;&#x3e;p) &#x3e; 0) { m = true; r = int2char(d); }
	     while(i &#x3e;= 0) {
	       if(p &#x3c; k) {
	         d = (this[i]&#x26;((1&#x3c;&#x3c;p)-1))&#x3c;&#x3c;(k-p);
	         d |= this[--i]&#x3e;&#x3e;(p+=this.DB-k);
	       }
	       else {
	         d = (this[i]&#x3e;&#x3e;(p-=k))&#x26;km;
	         if(p &#x3c;= 0) { p += this.DB; --i; }
	       }
	       if(d &#x3e; 0) m = true;
	       if(m) r += int2char(d);
	     }
	   }
	   return m?r:&#x22;0&#x22;;
	 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  ClearSigner = (function() {
function ClearSigner(_arg) {
  this.msg = _arg.msg, this.signing_key = _arg.signing_key;
}

ClearSigner.prototype._fix_msg = function(cb) {
  this._cleartext = input_to_cleartext(this.msg.<span class="apidocCodeKeywordSpan">toString</span>(&#x27;utf8&#x27;));
  return cb(null);
};

ClearSigner.prototype._sign_msg = function(cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.to_mpi_buffer" id="apidoc.element.kbpgp.bn.BigInteger.prototype.to_mpi_buffer">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>to_mpi_buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_mpi_buffer = function () {
  return toMPI(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var e;
  return Buffer.concat((function() {
    var _i, _len, _ref1, _results;
    _ref1 = this.ORDER;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
      e = _ref1[_i];
      _results.push(this[e].<span class="apidocCodeKeywordSpan">to_mpi_buffer</span>());
    }
    return _results;
  }).call(this));
};

BaseKey.prototype.validity_check = function(cb) {
  return cb(null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.to_padded_octets" id="apidoc.element.kbpgp.bn.BigInteger.prototype.to_padded_octets">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>to_padded_octets
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_padded_octets = function (base) {
  return mpi_to_padded_octets(this, base);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _ref4;
      if (err == null) {
        b = m.<span class="apidocCodeKeywordSpan">to_padded_octets</span>(_this.pub.p);
        _ref4 = eme_pkcs1_decode(b), err = _ref4[0], ret = _ref4[1];
      }
      return cb(err, ret);
    };
  })(this));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.bn.BigInteger.prototype.xor" id="apidoc.element.kbpgp.bn.BigInteger.prototype.xor">
        function <span class="apidocSignatureSpan">kbpgp.bn.BigInteger.prototype.</span>xor
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.clone().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.<span class="apidocCodeKeywordSpan">xor</span>(t, {});
  }
}
C = A;
for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
  r = R[_k];
  C.concat(r);
}
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.buffer" id="apidoc.module.kbpgp.buffer">module kbpgp.buffer</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.buffer.SlicerBuffer" id="apidoc.element.kbpgp.buffer.SlicerBuffer">
        function <span class="apidocSignatureSpan">kbpgp.buffer.</span>SlicerBuffer
        <span class="apidocSignatureSpan">(buf, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SlicerBuffer(buf, start) {
  this.buf = buf;
  this.start = start != null ? start : 0;
  if (!Buffer.isBuffer(this.buf)) {
    throw new Error(&#x27;need a Buffer!&#x27;);
  }
  this.i = this.start;
  this._end = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.burner" id="apidoc.module.kbpgp.burner">module kbpgp.burner</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.burner.Burner" id="apidoc.element.kbpgp.burner.Burner">
        function <span class="apidocSignatureSpan">kbpgp.burner.</span>Burner
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Burner(_arg) {
  var asp, encrypt_for, encryption_key, sign_with, signing_key;
  this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key =
_arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;
  Burner.__super__.constructor.call(this, {
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp
  });
  this.packets = [];
  this.opts || (this.opts = {});
  this.signed_payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.burner.burn" id="apidoc.element.kbpgp.burner.burn">
        function <span class="apidocSignatureSpan">kbpgp.burner.</span>burn
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">burn = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;burn&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">burn</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return raw = arguments[1];
      };
    })(),
    lineno: 247
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.burner.clearsign" id="apidoc.element.kbpgp.burner.clearsign">
        function <span class="apidocSignatureSpan">kbpgp.burner.</span>clearsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearsign = function (_arg, cb) {
  var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, signing_key = _arg.signing_key;
  b = new ClearSigner({
    msg: msg,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      b.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 215
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.burner.detachsign" id="apidoc.element.kbpgp.burner.detachsign">
        function <span class="apidocSignatureSpan">kbpgp.burner.</span>detachsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachsign = function (_arg, cb) {
  var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;
  s = new Signer({
    data: data,
    hash_streamer: hash_streamer,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      s.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 139
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      s.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.burner.make_simple_literals" id="apidoc.element.kbpgp.burner.make_simple_literals">
        function <span class="apidocSignatureSpan">kbpgp.burner.</span>make_simple_literals
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_simple_literals = function (msg) {
  return [
    new Literal({
      data: new Buffer(msg),
      format: C.literal_formats.utf8,
      date: unix_time()
    })
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.cast5" id="apidoc.module.kbpgp.cast5">module kbpgp.cast5</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.cast5.CAST5" id="apidoc.element.kbpgp.cast5.CAST5">
        function <span class="apidocSignatureSpan">kbpgp.cast5.</span>CAST5
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CAST5(key) {
  var n;
  this.masking = new Array(16);
  this.rotate = new Array(16);
  this.reset();
  if (key.sigBytes !== (n = this.keySize)) {
    throw new Error(&#x22;key must be &#x22; + n + &#x22; bytes&#x22;);
  }
  this.keySchedule(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.cfb" id="apidoc.module.kbpgp.cfb">module kbpgp.cfb</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.cfb.decrypt" id="apidoc.element.kbpgp.cfb.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.cfb.</span>decrypt
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (_arg) {
  var b, block_cipher_class, block_size, cipher, ciphertext, d, i, iv, key, list, out, pos;
  block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, ciphertext = _arg.ciphertext, iv = _arg.iv
;
  block_cipher_class || (block_cipher_class = AES);
  cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));
  block_size = cipher.blockSize;
  iv || (iv = new Buffer((function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; 0 &#x3c;= block_size ? _i &#x3c; block_size : _i &#x3e; block_size; i = 0 &#x3c;= block_size ? ++_i : --_i) {
      _results.push(0);
    }
    return _results;
  })()));
  b = WordArray.from_buffer(iv.slice(0, block_size));
  pos = 0;
  list = (function() {
    var _results;
    _results = [];
    while (ciphertext.length &#x3e; pos) {
      cipher.encryptBlock(b.words, 0);
      d = b;
      b = WordArray.from_buffer(ciphertext.slice(pos, pos + block_size));
      d.xor(b, {});
      pos += block_size;
      _results.push(d.to_buffer());
    }
    return _results;
  })();
  out = Buffer.concat(list);
  return out.slice(out, ciphertext.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.cfb.encrypt" id="apidoc.element.kbpgp.cfb.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.cfb.</span>encrypt
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (_arg) {
  var block_cipher_class, block_size, c, cipher, e, iv, key, list, out, plaintext, pos;
  block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, plaintext = _arg.plaintext, iv = _arg.iv;
  block_cipher_class || (block_cipher_class = AES);
  cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));
  block_size = cipher.blockSize;
  c = WordArray.from_buffer(iv.slice(0, block_size));
  pos = 0;
  list = (function() {
    var _results;
    _results = [];
    while (plaintext.length &#x3e; pos) {
      cipher.encryptBlock(c.words, 0);
      e = c;
      c = WordArray.from_buffer(plaintext.slice(pos, pos + block_size));
      e.xor(c, {
        n_words: c.words.length
      });
      pos += block_size;
      c = e;
      _results.push(e.to_buffer());
    }
    return _results;
  })();
  out = Buffer.concat(list);
  return out.slice(0, plaintext.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.clearsign" id="apidoc.module.kbpgp.clearsign">module kbpgp.clearsign</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.clearsign_to_sign" id="apidoc.element.kbpgp.clearsign.clearsign_to_sign">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>clearsign_to_sign
        <span class="apidocSignatureSpan">(lines, warnings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearsign_to_sign = function (lines, warnings) {
  lines = dash_unescape_lines(lines, warnings);
  return input_to_cleartext_sign(lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.dash_escape" id="apidoc.element.kbpgp.clearsign.dash_escape">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_escape
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dash_escape = function (line) {
  if (line.length &#x3e;= 1 &#x26;&#x26; line[0] === &#x27;-&#x27;) {
    return &#x22;- &#x22; + line;
  } else {
    return line;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.dash_unescape_line" id="apidoc.element.kbpgp.clearsign.dash_unescape_line">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_unescape_line
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dash_unescape_line = function (line) {
  var m, out, warn, _ref3;
  warn = false;
  out = (m = line.match(/^-( )?(.*?)$/)) != null ? (((_ref3 = m[1]) != null ? _ref3.length : void 0) !== 1 ? warn = true : void
0, m[2]) : line;
  return [out, warn];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.dash_unescape_lines" id="apidoc.element.kbpgp.clearsign.dash_unescape_lines">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>dash_unescape_lines
        <span class="apidocSignatureSpan">(lines, warnings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dash_unescape_lines = function (lines, warnings) {
  var i, l, line, ret, warn;
  if (warnings == null) {
    warnings = null;
  }
  ret = (function() {
    var _i, _len, _ref3, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i &#x3c; _len; i = ++_i) {
      line = lines[i];
      _ref3 = dash_unescape_line(line), l = _ref3[0], warn = _ref3[1];
      if (warn) {
        if (warnings != null) {
          warnings.push(&#x22;Bad dash-encoding on line &#x22; + (i + 1));
        }
      }
      _results.push(l);
    }
    return _results;
  })();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.input_to_cleartext" id="apidoc.element.kbpgp.clearsign.input_to_cleartext">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input_to_cleartext = function (raw) {
  var lines, ret;
  lines = raw.split(/\n/);
  ret = {
    show: bufferify(input_to_cleartext_display(lines)),
    sign: bufferify(input_to_cleartext_sign(lines))
  };
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.input_to_cleartext_display" id="apidoc.element.kbpgp.clearsign.input_to_cleartext_display">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext_display
        <span class="apidocSignatureSpan">(lines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input_to_cleartext_display = function (lines) {
  var line, out;
  out = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = lines.length; _i &#x3c; _len; _i++) {
      line = lines[_i];
      _results.push(dash_escape(line));
    }
    return _results;
  })();
  if (lines.length === 0 || lines.slice(-1)[0] !== &#x27;&#x27;) {
    out.push(&#x27;&#x27;);
  }
  return out.join(&#x22;\n&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.input_to_cleartext_sign" id="apidoc.element.kbpgp.clearsign.input_to_cleartext_sign">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>input_to_cleartext_sign
        <span class="apidocSignatureSpan">(lines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input_to_cleartext_sign = function (lines) {
  var line, num_trailing_newlines, t, tmp, _i;
  tmp = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = lines.length; _i &#x3c; _len; _i++) {
      line = lines[_i];
      _results.push(whitespace_strip(line));
    }
    return _results;
  })();
  num_trailing_newlines = 0;
  for (_i = tmp.length - 1; _i &#x3e;= 0; _i += -1) {
    t = tmp[_i];
    if (t === &#x27;&#x27;) {
      num_trailing_newlines++;
    } else {
      break;
    }
  }
  if (num_trailing_newlines &#x3e; 0) {
    tmp.pop();
  }
  return tmp.join(&#x22;\r\n&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.sign" id="apidoc.element.kbpgp.clearsign.sign">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>sign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (_arg, cb) {
  var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, signing_key = _arg.signing_key;
  b = new ClearSigner({
    msg: msg,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      b.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 215
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.verify" id="apidoc.element.kbpgp.clearsign.verify">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>verify
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (_arg, cb) {
  var clearsign, err, keyfetch, literal, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  packets = _arg.packets, clearsign = _arg.clearsign, keyfetch = _arg.keyfetch;
  v = new Verifier({
    packets: packets,
    clearsign: clearsign,
    keyfetch: keyfetch
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
        funcname: &#x22;verify&#x22;
      });
      v.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return literal = arguments[1];
          };
        })(),
        lineno: 223
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literal);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.clearsign.whitespace_strip" id="apidoc.element.kbpgp.clearsign.whitespace_strip">
        function <span class="apidocSignatureSpan">kbpgp.clearsign.</span>whitespace_strip
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whitespace_strip = function (line) {
  var m;
  line = line.replace(/\r/g, &#x27;&#x27;);
  if ((m = line.match(/^(.*?)([ \t]*)$/))) {
    return m[1];
  } else {
    return line;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.detachsign" id="apidoc.module.kbpgp.detachsign">module kbpgp.detachsign</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.detachsign.sign" id="apidoc.element.kbpgp.detachsign.sign">
        function <span class="apidocSignatureSpan">kbpgp.detachsign.</span>sign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (_arg, cb) {
  var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;
  s = new Signer({
    data: data,
    hash_streamer: hash_streamer,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      s.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 139
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      s.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.detachsign.verify" id="apidoc.element.kbpgp.detachsign.verify">
        function <span class="apidocSignatureSpan">kbpgp.detachsign.</span>verify
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (_arg, cb) {
  var data, data_fn, err, keyfetch, literals, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, data_fn = _arg.data_fn, packets = _arg.packets, keyfetch = _arg.keyfetch;
  v = new Verifier({
    data: data,
    data_fn: data_fn,
    packets: packets,
    keyfetch: keyfetch
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced&#x22;,
        funcname: &#x22;verify&#x22;
      });
      v.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return literals = arguments[1];
          };
        })(),
        lineno: 147
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.dh" id="apidoc.module.kbpgp.dh">module kbpgp.dh</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.dh.DH" id="apidoc.element.kbpgp.dh.DH">
        function <span class="apidocSignatureSpan">kbpgp.dh.</span>DH
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.dh.Pair" id="apidoc.element.kbpgp.dh.Pair">
        function <span class="apidocSignatureSpan">kbpgp.dh.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.dsa" id="apidoc.module.kbpgp.dsa">module kbpgp.dsa</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.dsa.DSA" id="apidoc.element.kbpgp.dsa.DSA">
        function <span class="apidocSignatureSpan">kbpgp.dsa.</span>DSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.dsa.Pair" id="apidoc.element.kbpgp.dsa.Pair">
        function <span class="apidocSignatureSpan">kbpgp.dsa.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc" id="apidoc.module.kbpgp.ecc">module kbpgp.ecc</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH" id="apidoc.element.kbpgp.ecc.ECDH">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDH
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA" id="apidoc.element.kbpgp.ecc.ECDSA">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA" id="apidoc.element.kbpgp.ecc.EDDSA">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>EDDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH" id="apidoc.module.kbpgp.ecc.ECDH">module kbpgp.ecc.ECDH</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.ECDH" id="apidoc.element.kbpgp.ecc.ECDH.ECDH">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDH
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Priv" id="apidoc.element.kbpgp.ecc.ECDH.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub" id="apidoc.element.kbpgp.ecc.ECDH.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.alloc" id="apidoc.element.kbpgp.ecc.ECDH.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>alloc
        <span class="apidocSignatureSpan">(klass, _arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (klass, _arg) {
  var err, priv, pub, _ref1, _ref2;
  pub = _arg.pub, priv = _arg.priv;
  _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];
  if ((err == null) &#x26;&#x26; (priv != null)) {
    _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];
  }
  if (err != null) {
    return [err, null];
  } else {
    return [
      null, new klass({
        priv: priv,
        pub: pub
      })
    ];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.generate" id="apidoc.element.kbpgp.ecc.ECDH.generate">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var asp, curve_name, err, nbits, pair, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbits = _arg.nbits, curve_name = _arg.curve_name, asp = _arg.asp;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced&#x22;,
        funcname: &#x22;Pair.generate&#x22;
      });
      generate({
        nbits: nbits,
        asp: asp,
        curve_name: curve_name,
        Pair: Pair
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return pair = arguments[1];
          };
        })(),
        lineno: 218
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if (typeof err === &#x22;undefined&#x22; || err === null) {
        pair.pub.apply_defaults();
      }
      return cb(err, pair);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.parse" id="apidoc.element.kbpgp.ecc.ECDH.parse">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  var ret;
  ret = BaseKeyPair.parse(Pair, pub_raw);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.parse_kb" id="apidoc.element.kbpgp.ecc.ECDH.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.parse_output" id="apidoc.element.kbpgp.ecc.ECDH.parse_output">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.</span>parse_output
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_output = function (buf) {
  return Output.parse(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH.Priv.prototype" id="apidoc.module.kbpgp.ecc.ECDH.Priv.prototype">module kbpgp.ecc.ECDH.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.decrypt" id="apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(c, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (c, _arg, cb) {
  var S, V, curve, err, esc, fingerprint, key, params, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  fingerprint = _arg.fingerprint;
  esc = make_esc(cb, &#x22;Priv::decrypt&#x22;);
  curve = this.pub.curve;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced&#x22;,
        funcname: &#x22;Priv.decrypt&#x22;
      });
      c.load_V(curve, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return V = arguments[0];
          };
        })(),
        lineno: 144
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _ref4;
      S = curve.decrypt(_this.x, V);
      params = _this.pub.format_params({
        fingerprint: fingerprint
      });
      key = _this.pub.kdf({
        X: S,
        params: params
      });
      _ref4 = unwrap({
        key: key,
        ciphertext: c.C,
        cipher: _this.pub.cipher
      }), err = _ref4[0], ret = _ref4[1];
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.serialize" id="apidoc.element.kbpgp.ecc.ECDH.Priv.prototype.serialize">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Priv.prototype.</span>serialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function () {
  var curve;
  curve = this.pub.curve;
  return curve.coord_to_mpi_buffer(this.x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}

BaseKeyPair.prototype.serialize = function() {
  return this.pub.<span class="apidocCodeKeywordSpan">serialize</span>();
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH.Pub.prototype" id="apidoc.module.kbpgp.ecc.ECDH.Pub.prototype">module kbpgp.ecc.ECDH.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.apply_defaults" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.apply_defaults">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>apply_defaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply_defaults = function () {
  this.cipher || (this.cipher = sym.get_cipher());
  return this.hasher || (this.hasher = hashmod.SHA512);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        lineno: 218
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if (typeof err === &#x22;undefined&#x22; || err === null) {
        pair.pub.<span class="apidocCodeKeywordSpan">apply_defaults</span>();
      }
      return cb(err, pair);
    };
  })(this));
};

return Pair;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.encrypt" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(m, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (m, _arg, cb) {
  var C, S, V, fingerprint, key, params, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  fingerprint = _arg.fingerprint;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced&#x22;,
        funcname: &#x22;Pub.encrypt&#x22;
      });
      _this.curve.encrypt(_this.R, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            V = arguments[0].V;
            return S = arguments[0].S;
          };
        })(),
        lineno: 97
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      params = _this.format_params({
        fingerprint: fingerprint
      });
      key = _this.kdf({
        X: S,
        params: params
      });
      C = wrap({
        key: key,
        plaintext: m,
        cipher: _this.cipher
      });
      return cb({
        V: V,
        C: C
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.format_params" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.format_params">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>format_params
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format_params = function (_arg) {
  var fingerprint;
  fingerprint = _arg.fingerprint;
  return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params
(), new Buffer(&#x22;Anonymous Sender    &#x22;, &#x22;utf8&#x22;), fingerprint]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      })(),
      lineno: 97
    }));
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    params = _this.<span class="apidocCodeKeywordSpan">format_params</span>({
      fingerprint: fingerprint
    });
    key = _this.kdf({
      X: S,
      params: params
    });
    C = wrap({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.kdf" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.kdf">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>kdf
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kdf = function (_arg) {
  var X, X_compact, buf, hash, o_bytes, params;
  X = _arg.X, params = _arg.params;
  o_bytes = this.cipher.key_size;
  X_compact = this.curve.point_to_mpi_buffer_compact(X);
  buf = Buffer.concat([new Buffer([0, 0, 0, 1]), X_compact, params]);
  hash = this.hasher(buf);
  return hash.slice(0, o_bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    params = _this.format_params({
      fingerprint: fingerprint
    });
    key = _this.<span class="apidocCodeKeywordSpan">kdf</span>({
      X: S,
      params: params
    });
    C = wrap({
      key: key,
      plaintext: m,
      cipher: _this.cipher
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.read_params" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.read_params">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>read_params
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_params = function (sb) {
  var n, size, v, val;
  if ((size = sb.read_uint8()) &#x3c; (n = Const.ecdh.param_bytes)) {
    throw new Error(&#x22;Need at least &#x22; + n + &#x22; bytes of params; got &#x22; + size);
  }
  if ((val = sb.read_uint8()) !== (v = Const.ecdh.version)) {
    throw new Error(&#x22;Cannot deal with future extensions, byte=&#x22; + val + &#x22;; wanted &#x22; + v);
  }
  this.hasher = hashmod.alloc_or_throw(sb.read_uint8());
  this.cipher = sym.get_cipher(sb.read_uint8());
  return sb.advance(size - 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err != null) {
    throw err;
  }
  pub = new klass({
    curve: curve,
    R: R
  });
  pub.<span class="apidocCodeKeywordSpan">read_params</span>(sb);
  len = pre - sb.rem();
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>serialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function () {
  return Buffer.concat([Pub.__super__.serialize.call(this), this.serialize_params()]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}

BaseKeyPair.prototype.serialize = function() {
  return this.pub.<span class="apidocCodeKeywordSpan">serialize</span>();
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize_params" id="apidoc.element.kbpgp.ecc.ECDH.Pub.prototype.serialize_params">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.Pub.prototype.</span>serialize_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize_params = function () {
  return Buffer.concat([uint_to_buffer(8, Const.ecdh.param_bytes), uint_to_buffer(8, Const.ecdh.version), uint_to_buffer(8, this
.hasher.type), uint_to_buffer(8, this.cipher.type)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Pub.prototype.serialize_params = function() {
  return Buffer.concat([uint_to_buffer(8, Const.ecdh.param_bytes), uint_to_buffer(8, Const.ecdh.version), uint_to_buffer(8, this
.hasher.type), uint_to_buffer(8, this.cipher.type)]);
};

Pub.prototype.serialize = function() {
  return Buffer.concat([Pub.__super__.serialize.call(this), this.<span class="apidocCodeKeywordSpan">serialize_params</span>()]);
};

Pub.prototype.format_params = function(_arg) {
  var fingerprint;
  fingerprint = _arg.fingerprint;
  return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params
(), new Buffer(&#x22;Anonymous Sender    &#x22;, &#x22;utf8&#x22;), fingerprint]);
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype" id="apidoc.module.kbpgp.ecc.ECDH.prototype">module kbpgp.ecc.ECDH.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.can_sign" id="apidoc.element.kbpgp.ecc.ECDH.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDH.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.decrypt_and_unpad" id="apidoc.element.kbpgp.ecc.ECDH.prototype.decrypt_and_unpad">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>decrypt_and_unpad
        <span class="apidocSignatureSpan">(ciphertext, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt_and_unpad = function (ciphertext, _arg, cb) {
  var err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  fingerprint = _arg.fingerprint;
  err = ret = null;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced&#x22;,
        funcname: &#x22;Pair.decrypt_and_unpad&#x22;
      });
      _this.priv.decrypt(ciphertext, {
        fingerprint: fingerprint
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return m = arguments[1];
          };
        })(),
        lineno: 207
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, m, true);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.export_output" id="apidoc.element.kbpgp.ecc.ECDH.prototype.export_output">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>export_output
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_output = function (args) {
  return new Output(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return c_mpis = arguments[0];
          };
        })(),
        lineno: 114
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return __iced_k(ret = _this.<span class="apidocCodeKeywordSpan">export_output</span>({
        c_mpis: c_mpis
      }));
    });
  } else {
    return __iced_k();
  }
})(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.fulfills_flags" id="apidoc.element.kbpgp.ecc.ECDH.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var good_for;
  good_for = Const.key_flags.encrypt_comm | Const.key_flags.encrypt_storage;
  return (flags &#x26; good_for) === flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.get_type" id="apidoc.element.kbpgp.ecc.ECDH.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.max_value" id="apidoc.element.kbpgp.ecc.ECDH.prototype.max_value">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>max_value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max_value = function () {
  return this.pub.p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.read_priv = function(raw_priv) {
  var err, _ref1;
  _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];
  return err;
};

BaseKeyPair.prototype.find = function(i) {
  return i.mod(this.<span class="apidocCodeKeywordSpan">max_value</span>());
};

BaseKeyPair.prototype.hide = function(_arg, cb) {
  var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  i = _arg.i, max = _arg.max, slosh = _arg.slosh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.pad_and_encrypt" id="apidoc.element.kbpgp.ecc.ECDH.prototype.pad_and_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>pad_and_encrypt
        <span class="apidocSignatureSpan">(data, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_encrypt = function (data, _arg, cb) {
  var C, V, err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  fingerprint = _arg.fingerprint;
  err = ret = null;
  _ref4 = ecc_pkcs5_pad_data(data), err = _ref4[0], m = _ref4[1];
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced&#x22;,
            funcname: &#x22;Pair.pad_and_encrypt&#x22;
          });
          _this.pub.encrypt(m, {
            fingerprint: fingerprint
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                C = arguments[0].C;
                return V = arguments[0].V;
              };
            })(),
            lineno: 199
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(ret = _this.export_output({
            C: C,
            V: V,
            curve: _this.pub.curve
          }));
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return function() {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._encrypt_session_key_once&#x22;
  });
  pub_k.<span class="apidocCodeKeywordSpan">pad_and_encrypt</span>(payload, {
    fingerprint: fingerprint
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return ekey = arguments[0];
      };
    })(),
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype.Priv" id="apidoc.module.kbpgp.ecc.ECDH.prototype.Priv">module kbpgp.ecc.ECDH.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.Priv" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.alloc" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  var curve, d, err, o, orig_len, _i, _len, _ref4, _ref5;
  orig_len = raw.length;
  err = null;
  curve = pub.curve;
  d = {
    pub: pub
  };
  _ref4 = Priv.ORDER;
  for (_i = 0, _len = _ref4.length; _i &#x3c; _len; _i++) {
    o = _ref4[_i];
    if (err == null) {
      _ref5 = curve.mpi_from_buffer(raw), err = _ref5[0], d[o] = _ref5[1], raw = _ref5[2];
    }
  }
  if (err) {
    return [err, null];
  } else {
    return [null, new Priv(d), orig_len - raw.length];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDH.prototype.Pub" id="apidoc.module.kbpgp.ecc.ECDH.prototype.Pub">module kbpgp.ecc.ECDH.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.Pub" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub._alloc" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Pub._alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>_alloc
        <span class="apidocSignatureSpan">(klass, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_alloc = function (klass, raw) {
  var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  l = sb.read_uint8();
  oid = sb.read_buffer(l);
  _ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];
  if (err != null) {
    throw err;
  }
  _ref2 = curve.mpi_point_from_slicer_buffer(sb), err = _ref2[0], R = _ref2[1];
  if (err != null) {
    throw err;
  }
  pub = new klass({
    curve: curve,
    R: R
  });
  pub.read_params(sb);
  len = pre - sb.rem();
  return [pub, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = BaseEccKey.<span class="apidocCodeKeywordSpan">_alloc</span>(klass, raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.alloc" id="apidoc.element.kbpgp.ecc.ECDH.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDH.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  return BaseEccKey.alloc(Pub, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA" id="apidoc.module.kbpgp.ecc.ECDSA">module kbpgp.ecc.ECDSA</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.ECDSA" id="apidoc.element.kbpgp.ecc.ECDSA.ECDSA">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>ECDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Priv" id="apidoc.element.kbpgp.ecc.ECDSA.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub" id="apidoc.element.kbpgp.ecc.ECDSA.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.alloc" id="apidoc.element.kbpgp.ecc.ECDSA.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>alloc
        <span class="apidocSignatureSpan">(klass, _arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (klass, _arg) {
  var err, priv, pub, _ref1, _ref2;
  pub = _arg.pub, priv = _arg.priv;
  _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];
  if ((err == null) &#x26;&#x26; (priv != null)) {
    _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];
  }
  if (err != null) {
    return [err, null];
  } else {
    return [
      null, new klass({
        priv: priv,
        pub: pub
      })
    ];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.generate" id="apidoc.element.kbpgp.ecc.ECDSA.generate">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var asp, nbits;
  nbits = _arg.nbits, asp = _arg.asp;
  return generate({
    nbits: nbits,
    asp: asp,
    Pair: Pair
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.parse" id="apidoc.element.kbpgp.ecc.ECDSA.parse">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  return BaseKeyPair.parse(Pair, pub_raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.parse_kb" id="apidoc.element.kbpgp.ecc.ECDSA.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.parse_sig" id="apidoc.element.kbpgp.ecc.ECDSA.parse_sig">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>parse_sig
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_sig = function (slice) {
  var buf, err, n, ret, _ref3;
  buf = slice.peek_rest_to_buffer();
  _ref3 = Pair.read_sig_from_buf(buf), err = _ref3[0], ret = _ref3[1], n = _ref3[2];
  if (err != null) {
    throw err;
  }
  slice.advance(n);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.read_sig_from_buf" id="apidoc.element.kbpgp.ecc.ECDSA.read_sig_from_buf">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>read_sig_from_buf
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_sig_from_buf = function (buf) {
  var err, n, o, order, orig_len, ret, x;
  orig_len = buf.length;
  order = [&#x27;r&#x27;, &#x27;s&#x27;];
  err = null;
  ret = (function() {
    var _i, _len, _ref3, _results;
    _results = [];
    for (_i = 0, _len = order.length; _i &#x3c; _len; _i++) {
      o = order[_i];
      if (!(err == null)) {
        continue;
      }
      _ref3 = bn.mpi_from_buffer(buf), err = _ref3[0], x = _ref3[1], buf = _ref3[2];
      _results.push(x);
    }
    return _results;
  })();
  n = orig_len - buf.length;
  return [err, ret, n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
err = null;
if (Buffer.isBuffer(sig)) {
  _ref1 = klass.<span class="apidocCodeKeywordSpan">read_sig_from_buf</span>(sig), err = _ref1[0], sig = _ref1[1];
}
hash || (hash = hasher(data));
(function(_this) {
  return (function(__iced_k) {
    if (sig.length !== 2) {
      return __iced_k(err = new Error(&#x22;Need an [r,s] pair for a DSA-style signature&#x22;));
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.subkey_algo" id="apidoc.element.kbpgp.ecc.ECDSA.subkey_algo">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.</span>subkey_algo
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subkey_algo = function (flags) {
  if (flags &#x26; (C.key_flags.certify_keys | C.key_flags.sign_data)) {
    return Pair;
  } else {
    return ECDH;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return _results;
})());
for (_i = 0, _len = subkeys.length; _i &#x3c; _len; _i++) {
  subkey = subkeys[_i];
  subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);
  subkey.flags || (subkey.flags = KEY_FLAGS_STD);
  subkey.algo || (subkey.algo = primary.algo.<span class="apidocCodeKeywordSpan">subkey_algo</span>(subkey.flags));
  subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);
}
generated || (generated = unix_time());
esc = make_esc(cb, &#x22;KeyManager::generate&#x22;);
if (userid != null) {
  userids = [userid];
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA.Priv.prototype" id="apidoc.module.kbpgp.ecc.ECDSA.Priv.prototype">module kbpgp.ecc.ECDSA.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.sign" id="apidoc.element.kbpgp.ecc.ECDSA.Priv.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Priv.prototype.</span>sign
        <span class="apidocSignatureSpan">(h, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (h, cb) {
  var G, Q, err, hi, k, n, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  _ref3 = this.pub.curve, n = _ref3.n, G = _ref3.G;
  hi = this.pub.trunc_hash(h);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced&#x22;,
        funcname: &#x22;Priv.sign&#x22;
      });
      _this.pub.curve.random_scalar(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return k = arguments[0];
          };
        })(),
        lineno: 79
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      Q = G.multiply(k);
      r = Q.affineX.mod(n);
      if (r.signum() === 0) {
        throw new Error(&#x22;invalid r-value&#x22;);
      }
      s = k.modInverse(n).multiply(hi.add(_this.x.multiply(r))).mod(n);
      return cb([r, s]);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA.Pub.prototype" id="apidoc.module.kbpgp.ecc.ECDSA.Pub.prototype">module kbpgp.ecc.ECDSA.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.nbits" id="apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  return this.curve.nbits();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.read_params" id="apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.read_params">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>read_params
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_params = function (sb) {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err != null) {
    throw err;
  }
  pub = new klass({
    curve: curve,
    R: R
  });
  pub.<span class="apidocCodeKeywordSpan">read_params</span>(sb);
  len = pre - sb.rem();
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.trunc_hash" id="apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.trunc_hash">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>trunc_hash
        <span class="apidocSignatureSpan">(h)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc_hash = function (h) {
  return bn.bn_from_left_n_bits(h, this.nbits());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;
};

Pub.prototype.verify = function(_arg, h, cb) {
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.<span class="apidocCodeKeywordSpan">trunc_hash</span>(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.verify" id="apidoc.element.kbpgp.ecc.ECDSA.Pub.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.Pub.prototype.</span>verify
        <span class="apidocSignatureSpan">(_arg, h, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (_arg, h, cb) {
  var err, hi, n, p, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.trunc_hash(h);
  if ((r.signum() &#x3c;= 0) || (r.compareTo(this.curve.p) &#x3e; 0)) {
    err = new Error(&#x22;bad r&#x22;);
  } else if ((r.signum() &#x3c;= 0) || (s.compareTo(this.curve.p) &#x3e; 0)) {
    err = new Error(&#x22;bad s&#x22;);
  } else {
    n = this.curve.n;
    w = s.modInverse(n);
    u1 = hi.multiply(w).mod(n);
    u2 = r.multiply(w).mod(n);
    p = this.curve.G.multiplyTwo(u1, this.R, u2);
    v = p.affineX.mod(n);
    if (!v.equals(r)) {
      err = new Error(&#x22;verification failed&#x22;);
    }
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype" id="apidoc.module.kbpgp.ecc.ECDSA.prototype">module kbpgp.ecc.ECDSA.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.can_encrypt" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.constructor" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.fulfills_flags" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var good_for;
  good_for = C.key_flags.certify_keys | C.key_flags.sign_data;
  return (flags &#x26; good_for) === flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.get_type" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.good_for_flags" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.good_for_flags">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>good_for_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">good_for_flags = function () {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
  var good_for;
  good_for = this.<span class="apidocCodeKeywordSpan">good_for_flags</span>();
  return (flags &#x26; good_for) === flags;
};

Pair.prototype.good_for_flags = function() {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.pad_and_sign" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.pad_and_sign">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>pad_and_sign
        <span class="apidocSignatureSpan">(data, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_sign = function (data, _arg, cb) {
  var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hasher = _arg.hasher;
  hasher || (hasher = SHA512);
  h = hasher(data);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced&#x22;,
        funcname: &#x22;Pair.pad_and_sign&#x22;
      });
      _this.priv.sign(h, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return sig = arguments[0];
          };
        })(),
        lineno: 134
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, Buffer.concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = sig.length; _i &#x3c; _len; _i++) {
          s = sig[_i];
          _results.push(s.to_mpi_buffer());
        }
        return _results;
      })()));
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.verify_unpad_and_check_hash" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.verify_unpad_and_check_hash">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>verify_unpad_and_check_hash
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify_unpad_and_check_hash = function (_arg, cb) {
  var data, hash, hasher, sig;
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;
  return this._dsa_verify_update_and_check_hash({
    sig: sig,
    data: data,
    hasher: hasher,
    hash: hash,
    klass: Pair
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype.Priv" id="apidoc.module.kbpgp.ecc.ECDSA.prototype.Priv">module kbpgp.ecc.ECDSA.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.Priv" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.alloc" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  return BaseKey.alloc(Priv, raw, {
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.ECDSA.prototype.Pub" id="apidoc.module.kbpgp.ecc.ECDSA.prototype.Pub">module kbpgp.ecc.ECDSA.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.Pub" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub() {
  return Pub.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub._alloc" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub._alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>_alloc
        <span class="apidocSignatureSpan">(klass, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_alloc = function (klass, raw) {
  var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  l = sb.read_uint8();
  oid = sb.read_buffer(l);
  _ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];
  if (err != null) {
    throw err;
  }
  _ref2 = curve.mpi_point_from_slicer_buffer(sb), err = _ref2[0], R = _ref2[1];
  if (err != null) {
    throw err;
  }
  pub = new klass({
    curve: curve,
    R: R
  });
  pub.read_params(sb);
  len = pre - sb.rem();
  return [pub, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = BaseEccKey.<span class="apidocCodeKeywordSpan">_alloc</span>(klass, raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.alloc" id="apidoc.element.kbpgp.ecc.ECDSA.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.ECDSA.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  return BaseEccKey.alloc(Pub, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA" id="apidoc.module.kbpgp.ecc.EDDSA">module kbpgp.ecc.EDDSA</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.EDDSA" id="apidoc.element.kbpgp.ecc.EDDSA.EDDSA">
        function <span class="apidocSignatureSpan">kbpgp.ecc.</span>EDDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Priv" id="apidoc.element.kbpgp.ecc.EDDSA.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub" id="apidoc.element.kbpgp.ecc.EDDSA.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.key = _arg.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.alloc" id="apidoc.element.kbpgp.ecc.EDDSA.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>alloc
        <span class="apidocSignatureSpan">(klass, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = Pub.alloc(raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.eddsa_value_from_buffer" id="apidoc.element.kbpgp.ecc.EDDSA.eddsa_value_from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>eddsa_value_from_buffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eddsa_value_from_buffer = function (buf) {
  var bits, bytes_len, err, ret;
  err = ret = null;
  if ((bits = buf.readUInt16BE(0)) &#x3e; 0x100 || bits &#x3c; (0x100 - 40)) {
    err = new Error(&#x22;Got an unexpected number of Bits for an EdDSA value: &#x22; + bits);
  } else {
    bytes_len = 2 + Math.ceil(bits / 8);
    ret = buf.slice(2, bytes_len);
    buf = buf.slice(bytes_len);
  }
  return [err, ret, buf];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _i, _len, _ref1, _results;
  _results = [];
  for (_i = 0, _len = order.length; _i &#x3c; _len; _i++) {
    o = order[_i];
    if (!(err == null)) {
      continue;
    }
    _ref1 = Pair.<span class="apidocCodeKeywordSpan">eddsa_value_from_buffer</span>(buf), err = _ref1[0], x = _ref1[1], buf = _ref1
[2];
    _results.push(x);
  }
  return _results;
})();
n = orig_len - buf.length;
ret = err != null ? null : bufs;
return [err, ret, n];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.generate" id="apidoc.element.kbpgp.ecc.EDDSA.generate">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var asp, nbits, priv, pub, publicKey, ret, secretKey, seed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbits = _arg.nbits, asp = _arg.asp;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/ecc/eddsa.iced&#x22;,
        funcname: &#x22;Pair.generate&#x22;
      });
      SRF().random_bytes(kbnacl.sign.seedLength, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return seed = arguments[0];
          };
        })(),
        lineno: 280
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _ref1;
      _ref1 = kbnacl.alloc({}).genFromSeed({
        seed: seed
      }), publicKey = _ref1.publicKey, secretKey = _ref1.secretKey;
      pub = new Pub({
        key: new Buffer(publicKey)
      });
      priv = new Priv({
        seed: seed,
        key: new Buffer(secretKey),
        pub: pub
      });
      ret = new Pair({
        pub: pub,
        priv: priv
      });
      return cb(null, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.parse" id="apidoc.element.kbpgp.ecc.EDDSA.parse">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse
        <span class="apidocSignatureSpan">(pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (pub_raw) {
  return BaseKeyPair.parse(Pair, pub_raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.parse_kb" id="apidoc.element.kbpgp.ecc.EDDSA.parse_kb">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse_kb
        <span class="apidocSignatureSpan">(klass, pub_raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_kb = function (klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Pair.prototype.pad_and_sign = function(data, _arg, cb) {
  var hasher;
  hasher = _arg.hasher;
  return cb(new Error(&#x22;pad_and_sign unsupported&#x22;));
};

Pair.parse_kb = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse_kb</span>(Pair, pub_raw);
};

Pair.parse_sig = function(slice) {
  var err;
  err = new Error(&#x22;@parse_sig unsupported&#x22;);
  throw err;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.parse_sig" id="apidoc.element.kbpgp.ecc.EDDSA.parse_sig">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>parse_sig
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_sig = function (slice) {
  var buf, err, n, ret, _ref1;
  buf = slice.peek_rest_to_buffer();
  _ref1 = Pair.read_sig_from_buf(buf), err = _ref1[0], ret = _ref1[1], n = _ref1[2];
  if (err != null) {
    throw err;
  }
  slice.advance(n);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.read_sig_from_buf" id="apidoc.element.kbpgp.ecc.EDDSA.read_sig_from_buf">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>read_sig_from_buf
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_sig_from_buf = function (buf) {
  var bufs, err, n, o, order, orig_len, ret, x;
  orig_len = buf.length;
  order = [&#x27;r&#x27;, &#x27;s&#x27;];
  err = null;
  bufs = (function() {
    var _i, _len, _ref1, _results;
    _results = [];
    for (_i = 0, _len = order.length; _i &#x3c; _len; _i++) {
      o = order[_i];
      if (!(err == null)) {
        continue;
      }
      _ref1 = Pair.eddsa_value_from_buffer(buf), err = _ref1[0], x = _ref1[1], buf = _ref1[2];
      _results.push(x);
    }
    return _results;
  })();
  n = orig_len - buf.length;
  ret = err != null ? null : bufs;
  return [err, ret, n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
err = null;
if (Buffer.isBuffer(sig)) {
  _ref1 = klass.<span class="apidocCodeKeywordSpan">read_sig_from_buf</span>(sig), err = _ref1[0], sig = _ref1[1];
}
hash || (hash = hasher(data));
(function(_this) {
  return (function(__iced_k) {
    if (sig.length !== 2) {
      return __iced_k(err = new Error(&#x22;Need an [r,s] pair for a DSA-style signature&#x22;));
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.subkey_algo" id="apidoc.element.kbpgp.ecc.EDDSA.subkey_algo">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.</span>subkey_algo
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subkey_algo = function (flags) {
  if (flags &#x26; (C.key_flags.certify_keys | C.key_flags.sign_data)) {
    return Pair;
  } else {
    return ECDH;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return _results;
})());
for (_i = 0, _len = subkeys.length; _i &#x3c; _len; _i++) {
  subkey = subkeys[_i];
  subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);
  subkey.flags || (subkey.flags = KEY_FLAGS_STD);
  subkey.algo || (subkey.algo = primary.algo.<span class="apidocCodeKeywordSpan">subkey_algo</span>(subkey.flags));
  subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);
}
generated || (generated = unix_time());
esc = make_esc(cb, &#x22;KeyManager::generate&#x22;);
if (userid != null) {
  userids = [userid];
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA.Priv.prototype" id="apidoc.module.kbpgp.ecc.EDDSA.Priv.prototype">module kbpgp.ecc.EDDSA.Priv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.constructor" id="apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.serialize" id="apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.serialize">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>serialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function () {
  return Buffer.concat([uint_to_buffer(16, kbnacl.sign.seedLength * 8), this.seed]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}

BaseKeyPair.prototype.serialize = function() {
  return this.pub.<span class="apidocCodeKeywordSpan">serialize</span>();
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.sign" id="apidoc.element.kbpgp.ecc.EDDSA.Priv.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Priv.prototype.</span>sign
        <span class="apidocSignatureSpan">(h, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (h, cb) {
  var len, nacl, ret;
  nacl = kbnacl.alloc({
    secretKey: this.key
  });
  ret = nacl.sign({
    payload: h
  });
  len = kbnacl.sign.signatureLength / 2;
  return cb([new Buffer(ret.slice(0, len)), new Buffer(ret.slice(len, len * 2))]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA.Pub.prototype" id="apidoc.module.kbpgp.ecc.EDDSA.Pub.prototype">module kbpgp.ecc.EDDSA.Pub.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.constructor" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.key = _arg.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.nbits" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  return 255;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.read_params" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.read_params">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>read_params
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_params = function (sb) {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err != null) {
    throw err;
  }
  pub = new klass({
    curve: curve,
    R: R
  });
  pub.<span class="apidocCodeKeywordSpan">read_params</span>(sb);
  len = pre - sb.rem();
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.serialize" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.serialize">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>serialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function () {
  var ret;
  ret = Buffer.concat([new Buffer([this.OID.length]), this.OID, this.MPI_LENGTH_HEADERS, this.key]);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pub.parent = this;
  if (this.priv != null) {
    this.priv.parent = this;
  }
}

BaseKeyPair.prototype.serialize = function() {
  return this.pub.<span class="apidocCodeKeywordSpan">serialize</span>();
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.trunc_hash" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.trunc_hash">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>trunc_hash
        <span class="apidocSignatureSpan">(h)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc_hash = function (h) {
  return bn.bn_from_left_n_bits(h, this.nbits());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;
};

Pub.prototype.verify = function(_arg, h, cb) {
  var err, hi, r, s, u1, u2, v, w;
  r = _arg[0], s = _arg[1];
  err = null;
  hi = this.<span class="apidocCodeKeywordSpan">trunc_hash</span>(h);
  w = s.modInverse(this.q);
  u1 = hi.multiply(w).mod(this.q);
  u2 = r.multiply(w).mod(this.q);
  v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);
  if (!v.equals(r)) {
    err = new Error(&#x22;verification failed&#x22;);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.verify" id="apidoc.element.kbpgp.ecc.EDDSA.Pub.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.Pub.prototype.</span>verify
        <span class="apidocSignatureSpan">(_arg, payload, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (_arg, payload, cb) {
  var err, naclw, r, s, sig, _, _ref1;
  r = _arg[0], s = _arg[1];
  naclw = kbnacl.alloc({
    publicKey: this.key
  });
  sig = util.fit_to_size(kbnacl.sign.signatureLength, Buffer.concat([r, s]));
  _ref1 = naclw.verify({
    payload: payload,
    sig: sig,
    detached: true
  }), err = _ref1[0], _ = _ref1[1];
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype" id="apidoc.module.kbpgp.ecc.EDDSA.prototype">module kbpgp.ecc.EDDSA.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.key = _arg.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.can_encrypt" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.constructor" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.fulfills_flags" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var good_for;
  good_for = C.key_flags.certify_keys | C.key_flags.sign_data;
  return (flags &#x26; good_for) === flags;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.get_type" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.good_for_flags" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.good_for_flags">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>good_for_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">good_for_flags = function () {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
  var good_for;
  good_for = this.<span class="apidocCodeKeywordSpan">good_for_flags</span>();
  return (flags &#x26; good_for) === flags;
};

Pair.prototype.good_for_flags = function() {
  return C.key_flags.certify_keys | C.key_flags.sign_data;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.pad_and_sign" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.pad_and_sign">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>pad_and_sign
        <span class="apidocSignatureSpan">(data, _arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad_and_sign = function (data, _arg, cb) {
  var h, hasher, r, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hasher = _arg.hasher;
  hasher || (hasher = SHA512);
  h = hasher(data);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/ecc/eddsa.iced&#x22;,
        funcname: &#x22;Pair.pad_and_sign&#x22;
      });
      _this.priv.sign(h, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return sig = arguments[0];
          };
        })(),
        lineno: 208
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      r = sig[0], s = sig[1];
      return cb(null, Buffer.concat([uint_to_buffer(16, r.length * 8), r, uint_to_buffer(16, s.length * 8), s]));
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.verify_unpad_and_check_hash" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.verify_unpad_and_check_hash">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>verify_unpad_and_check_hash
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify_unpad_and_check_hash = function (_arg, cb) {
  var data, hash, hasher, sig;
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;
  return this._dsa_verify_update_and_check_hash({
    sig: sig,
    data: data,
    hasher: hasher,
    hash: hash,
    klass: Pair
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype.Priv" id="apidoc.module.kbpgp.ecc.EDDSA.prototype.Priv">module kbpgp.ecc.EDDSA.prototype.Priv</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.Priv" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.Priv">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Priv
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Priv(_arg) {
  this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.Pub({
    curve: curve,
    R: R
  });
  priv = new Pair.<span class="apidocCodeKeywordSpan">Priv</span>({
    pub: pub,
    x: x
  });
  return __iced_k(ret = new Pair({
    pub: pub,
    priv: priv
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv._alloc" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv._alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Priv.</span>_alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_alloc = function (raw, pub) {
  var key_len, len, m, n, pre, priv, publicKey, sb, secretKey, seed, _ref1;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  key_len = Math.ceil(sb.read_uint16() / 8);
  if ((n = key_len) !== (m = kbnacl.sign.seedLength)) {
    throw new Error(&#x22;Expected &#x22; + m + &#x22; bytes for EDDSA priv key, got &#x22; + n + &#x22;.&#x22;);
  }
  seed = sb.read_buffer(key_len);
  _ref1 = kbnacl.alloc({}).genFromSeed({
    seed: seed
  }), publicKey = _ref1.publicKey, secretKey = _ref1.secretKey;
  if (!util.bufeq_secure(pub.key, publicKey)) {
    throw new Error(&#x27;Loaded EDDSA private key but it does not match the public key.&#x27;);
  }
  priv = new Priv({
    seed: seed,
    key: new Buffer(secretKey),
    pub: pub
  });
  len = pre - sb.rem();
  return [priv, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = BaseEccKey.<span class="apidocCodeKeywordSpan">_alloc</span>(klass, raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.alloc" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Priv.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Priv.</span>alloc
        <span class="apidocSignatureSpan">(raw, pub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw, pub) {
  var e, err, len, priv, _ref1;
  priv = len = err = null;
  try {
    _ref1 = Priv._alloc(raw, pub), priv = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, priv, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.EDDSA.prototype.Pub" id="apidoc.module.kbpgp.ecc.EDDSA.prototype.Pub">module kbpgp.ecc.EDDSA.prototype.Pub</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.Pub" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.Pub">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.</span>Pub
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pub(_arg) {
  this.key = _arg.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
  }));
  __iced_deferrals._fulfill();
})(function() {
  pub = new Pair.<span class="apidocCodeKeywordSpan">Pub</span>({
    curve: curve,
    R: R
  });
  priv = new Pair.Priv({
    pub: pub,
    x: x
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub._alloc" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub._alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>_alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_alloc = function (raw) {
  var expected, key, l, len, mpi_length_headers, oid, pre, pub, sb;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  l = sb.read_uint8();
  oid = sb.read_buffer(l);
  expected = Pub.OID;
  if (!util.bufeq_secure(oid, expected)) {
    throw new Error(&#x22;Wrong OID in EdDSA key&#x22;);
  }
  mpi_length_headers = sb.read_buffer(Pub.MPI_LENGTH_HEADERS.length);
  if (!util.bufeq_secure(mpi_length_headers, Pub.MPI_LENGTH_HEADERS)) {
    throw new Error(&#x22;Wrong MPI length headers&#x22;);
  }
  key = sb.read_buffer(kbnacl.sign.publicKeyLength);
  pub = new Pub({
    key: key
  });
  len = pre - sb.rem();
  return [pub, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [pub, len];
};

BaseEccKey.alloc = function(klass, raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = BaseEccKey.<span class="apidocCodeKeywordSpan">_alloc</span>(klass, raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.alloc" id="apidoc.element.kbpgp.ecc.EDDSA.prototype.Pub.alloc">
        function <span class="apidocSignatureSpan">kbpgp.ecc.EDDSA.prototype.Pub.</span>alloc
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (raw) {
  var e, err, len, pub, _ref1;
  pub = len = err = null;
  try {
    _ref1 = Pub._alloc(raw), pub = _ref1[0], len = _ref1[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, pub, len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.curves" id="apidoc.module.kbpgp.ecc.curves">module kbpgp.ecc.curves</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve" id="apidoc.element.kbpgp.ecc.curves.Curve">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>Curve
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Curve(_arg) {
  var Gx, Gy, a, b, h, n, p;
  p = _arg.p, a = _arg.a, b = _arg.b, Gx = _arg.Gx, Gy = _arg.Gy, n = _arg.n, h = _arg.h, this.oid = _arg.oid;
  h || (h = BigInteger.ONE);
  Curve.__super__.constructor.call(this, p, a, b, Gx, Gy, n, h);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519" id="apidoc.element.kbpgp.ecc.curves.Curve25519">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>Curve25519
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Curve25519(_arg) {
  this.oid = _arg.oid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.H" id="apidoc.element.kbpgp.ecc.curves.H">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>H
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">H = function (x) {
  return BigInteger.fromHex(x.split(/\s+/).join(&#x27;&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.alloc_by_name" id="apidoc.element.kbpgp.ecc.curves.alloc_by_name">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_name
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc_by_name = function (name) {
  var a, curve, err;
  err = curve = null;
  if ((a = OID_NAMES[name]) != null) {
    curve = a();
  } else {
    err = new Error(&#x22;Unknown curve name: &#x22; + name);
  }
  return [err, curve];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.alloc_by_nbits" id="apidoc.element.kbpgp.ecc.curves.alloc_by_nbits">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_nbits
        <span class="apidocSignatureSpan">(nbits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc_by_nbits = function (nbits) {
  var err, f, ret;
  ret = err = null;
  nbits || (nbits = 256);
  f = (function() {
    switch (nbits) {
      case 256:
        return nist_p256;
      case 384:
        return nist_p384;
      case 521:
        return nist_p521;
      default:
        return null;
    }
  })();
  if (f != null) {
    ret = f();
  } else {
    err = new Error(&#x22;No curve for &#x22; + nbits + &#x22; bits&#x22;);
  }
  return [err, ret];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.alloc_by_oid" id="apidoc.element.kbpgp.ecc.curves.alloc_by_oid">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>alloc_by_oid
        <span class="apidocSignatureSpan">(oid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc_by_oid = function (oid) {
  var curve, err, f;
  if (Buffer.isBuffer(oid)) {
    oid = oid.toString(&#x27;hex&#x27;);
  }
  err = curve = null;
  if ((f = OID_LOOKUP[oid.toLowerCase()]) != null) {
    curve = f();
  } else {
    err = new Error(&#x22;Unknown curve OID: &#x22; + oid);
  }
  return [err, curve];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.brainpool_p256" id="apidoc.element.kbpgp.ecc.curves.brainpool_p256">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p256
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brainpool_p256 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x27;a9fb57db a1eea9bc 3e660a90 9d838d72 6e3bf623 d5262028 2013481d 1f6e5377&#x27;);
  a = H(&#x27;7d5a0975 fc2c3057 eef67530 417affe7 fb8055c1 26dc5c6c e94a4b44 f330b5d9&#x27;);
  b = H(&#x27;26dc5c6c e94a4b44 f330b5d9 bbd77cbf 95841629 5cf7e1ce 6bccdc18 ff8c07b6&#x27;);
  n = H(&#x27;a9fb57db a1eea9bc 3e660a90 9d838d71 8c397aa3 b561a6f7 901e0e82 974856a7&#x27;);
  Gx = H(&#x27;8bd2aeb9 cb7e57cb 2c4b482f fc81b7af b9de27e1 e3bd23c2 3a4453bd 9ace3262&#x27;);
  Gy = H(&#x27;547ef835 c3dac4fd 97f8461a 14611dc9 c2774513 2ded8e54 5c1d54c7 2f046997&#x27;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.brainpool_p256
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.brainpool_p384" id="apidoc.element.kbpgp.ecc.curves.brainpool_p384">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p384
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brainpool_p384 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x27;8cb91e82 a3386d28 0f5d6f7e 50e641df 152f7109 ed5456b4 12b1da19 7fb71123 acd3a729 901d1a71 87470013 3107ec53&#x27;);
  a = H(&#x27;7bc382c6 3d8c150c 3c72080a ce05afa0 c2bea28e 4fb22787 139165ef ba91f90f 8aa5814a 503ad4eb 04a8c7dd 22ce2826&#x27;);
  b = H(&#x27;04a8c7dd 22ce2826 8b39b554 16f0447c 2fb77de1 07dcd2a6 2e880ea5 3eeb62d5 7cb43902 95dbc994 3ab78696 fa504c11&#x27;);
  n = H(&#x27;8cb91e82 a3386d28 0f5d6f7e 50e641df 152f7109 ed5456b3 1f166e6c ac0425a7 cf3ab6af 6b7fc310 3b883202 e9046565&#x27;);
  Gx = H(&#x27;1d1c64f0 68cf45ff a2a63a81 b7c13f6b 8847a3e7 7ef14fe3 db7fcafe 0cbd10e8 e826e034 36d646aa ef87b2e2 47d4af1e&#x27;);
  Gy = H(&#x27;8abe1d75 20f9c2a4 5cb1eb8e 95cfd552 62b70b29 feec5864 e19c054f f9912928 0e464621 77918111 42820341 263c5315&#x27;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.brainpool_p384
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.brainpool_p512" id="apidoc.element.kbpgp.ecc.curves.brainpool_p512">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>brainpool_p512
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brainpool_p512 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x27;aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07 cb308db3 b3c9d20e d6639cca 70330871 7d4d9b00 9bc66842 aecda12a e6a380e6 2881ff2f 2d82c685
 28aa6056 583a48f3&#x27;);
  a = H(&#x27;7830a331 8b603b89 e2327145 ac234cc5 94cbdd8d 3df91610 a83441ca ea9863bc 2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7 2bf2c7b9
 e7c1ac4d 77fc94ca&#x27;);
  b = H(&#x27;3df91610 a83441ca ea9863bc 2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca dc083e67 984050b7 5ebae5dd
 2809bd63 8016f723&#x27;);
  n = H(&#x27;aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07 cb308db3 b3c9d20e d6639cca 70330870 553e5c41 4ca92619 41866119 7fac1047 1db1d381 085ddadd
 b5879682 9ca90069&#x27;);
  Gx = H(&#x27;81aee4bd d82ed964 5a21322e 9c4c6a93 85ed9f70 b5d916c1 b43b62ee f4d0098e ff3b1f78 e2d0d48d 50d1687b 93b97d5f 7c6d5047 406a5e68
 8b352209 bcb9f822&#x27;);
  Gy = H(&#x27;7dde385d 566332ec c0eabfa9 cf7822fd f209f700 24a57b1a a000c55b 881f8111 b2dcde49 4a5f485e 5bca4bd8 8a2763ae d1ca2b2f a8f05406
 78cd1e0f 3ad80892&#x27;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.brainpool_p512
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.cv25519" id="apidoc.element.kbpgp.ecc.curves.cv25519">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>cv25519
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cv25519 = function () {
  return new Curve25519({
    oid: OIDS.cv25519
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.nist_p256" id="apidoc.element.kbpgp.ecc.curves.nist_p256">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p256
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nist_p256 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x22;FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF&#x22;);
  a = H(&#x22;FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC&#x22;);
  b = H(&#x22;5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B&#x22;);
  n = H(&#x22;FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551&#x22;);
  Gx = H(&#x22;6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296&#x22;);
  Gy = H(&#x22;4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5&#x22;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.nist_p256
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.nist_p384" id="apidoc.element.kbpgp.ecc.curves.nist_p384">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p384
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nist_p384 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x27;ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff&#x27;);
  a = H(&#x27;ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc&#x27;);
  b = H(&#x27;b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef&#x27;);
  n = H(&#x27;ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973&#x27;);
  Gx = H(&#x27;aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7&#x27;);
  Gy = H(&#x27;3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f&#x27;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.nist_p384
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.nist_p521" id="apidoc.element.kbpgp.ecc.curves.nist_p521">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.</span>nist_p521
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nist_p521 = function () {
  var Gx, Gy, a, b, n, p;
  p = H(&#x27;000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
 ffffffff ffffffff ffffffff&#x27;);
  a = H(&#x27;000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
 ffffffff ffffffff fffffffc&#x27;);
  b = H(&#x27;00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88
 3d2c34f1 ef451fd4 6b503f00&#x27;);
  n = H(&#x27;000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8
 899c47ae bb6fb71e 91386409&#x27;);
  Gx = H(&#x27;000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1
 856a429b f97e7e31 c2e5bd66&#x27;);
  Gy = H(&#x27;00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086
 a272c240 88be9476 9fd16650&#x27;);
  return new Curve({
    p: p,
    a: a,
    b: b,
    Gx: Gx,
    Gy: Gy,
    n: n,
    oid: OIDS.nist_p521
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.curves.Curve.prototype" id="apidoc.module.kbpgp.ecc.curves.Curve.prototype">module kbpgp.ecc.curves.Curve.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype._mpi_point_from_slicer_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype._mpi_point_from_slicer_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>_mpi_point_from_slicer_buffer
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mpi_point_from_slicer_buffer = function (sb) {
  var b, bits, coord_bytes, n_bits, n_bytes, point, x, y, _ref;
  n_bits = sb.read_uint16();
  n_bytes = Math.ceil(n_bits / 8);
  if (n_bytes !== (b = this.mpi_byte_size())) {
    bits = this.mpi_bit_size();
    throw new Error(&#x22;Need &#x22; + b + &#x22; bytes (&#x22; + bits + &#x22; bits) for this curve; got &#x22; + n_bytes + &#x22; (&#x22; + n_bits + &#x22; bits)&#x22;);
  }
  if (sb.read_uint8() !== 0x4) {
    throw new Error(&#x22;Can only handle 0x4 prefix for MPI representations&#x22;);
  }
  coord_bytes = this.mpi_coord_byte_size();
  _ref = [BigInteger.fromBuffer(sb.read_buffer(coord_bytes)), BigInteger.fromBuffer(sb.read_buffer(coord_bytes))], x = _ref[0],
y = _ref[1];
  point = this.mkpoint({
    x: x,
    y: y
  });
  if (!this.isOnCurve(point)) {
    throw new Error(&#x22;Given ECC point isn&#x27;t on the given curve; data corruption detected.&#x22;);
  }
  return [null, point];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.constructor" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Curve(_arg) {
  var Gx, Gy, a, b, h, n, p;
  p = _arg.p, a = _arg.a, b = _arg.b, Gx = _arg.Gx, Gy = _arg.Gy, n = _arg.n, h = _arg.h, this.oid = _arg.oid;
  h || (h = BigInteger.ONE);
  Curve.__super__.constructor.call(this, p, a, b, Gx, Gy, n, h);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.coord_to_mpi_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.coord_to_mpi_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>coord_to_mpi_buffer
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coord_to_mpi_buffer = function (p) {
  var byte_size;
  byte_size = this.mpi_coord_byte_size();
  return Buffer.concat([uint_to_buffer(16, byte_size * 8), p.toBuffer(byte_size)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}

Priv.prototype.serialize = function() {
  var curve;
  curve = this.pub.curve;
  return curve.<span class="apidocCodeKeywordSpan">coord_to_mpi_buffer</span>(this.x);
};

Priv.alloc = function(raw, pub) {
  var curve, d, err, o, orig_len, _i, _len, _ref4, _ref5;
  orig_len = raw.length;
  err = null;
  curve = pub.curve;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.decrypt" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(x, V)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (x, V) {
  return V.multiply(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.encrypt" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(R, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (R, cb) {
  var G, S, V, n, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  n = this.n, G = this.G;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/curves.iced&#x22;,
        funcname: &#x22;Curve.encrypt&#x22;
      });
      _this.random_scalar(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return v = arguments[0];
          };
        })(),
        lineno: 134
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      V = G.multiply(v);
      S = R.multiply(v);
      return cb({
        V: V,
        S: S
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.generate" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.generate">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>generate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (cb) {
  var R, x, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/curves.iced&#x22;,
        funcname: &#x22;Curve.generate&#x22;
      });
      _this.random_scalar(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return x = arguments[0];
          };
        })(),
        lineno: 157
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      R = _this.G.multiply(x);
      return cb({
        x: x,
        R: R
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mkpoint" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mkpoint">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mkpoint
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkpoint = function (_arg) {
  var x, y;
  x = _arg.x, y = _arg.y;
  return base.Point.fromAffine(this, x, y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_bit_size" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_bit_size">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_bit_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_bit_size = function () {
  return 2 * this.mpi_coord_bit_size() + 3;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_byte_size" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_byte_size">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_byte_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_byte_size = function () {
  return Math.ceil(this.mpi_bit_size() / 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_bit_size" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_bit_size">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_coord_bit_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_coord_bit_size = function () {
  return this.mpi_coord_byte_size() * 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_byte_size" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_coord_byte_size">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_coord_byte_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_coord_byte_size = function () {
  return Math.ceil(this.nbits() / 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_from_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_from_buffer
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_from_buffer = function (raw) {
  return bn.mpi_from_buffer(raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
orig_len = raw.length;
err = null;
_ref1 = klass.ORDER;
for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
  o = _ref1[_i];
  if (err == null) {
    _ref2 = bn.<span class="apidocCodeKeywordSpan">mpi_from_buffer</span>(raw), err = _ref2[0], d[o] = _ref2[1], raw = _ref2[2];
  }
}
if (err) {
  return [err, null];
} else {
  return [null, new klass(d), orig_len - raw.length];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_point_from_buffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_point_from_buffer = function (b) {
  return this.mpi_point_from_slicer_buffer(new SlicerBuffer(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Output(_arg) {
  this.V_buf = _arg.V_buf, this.C = _arg.C, this.V = _arg.V, this.curve = _arg.curve;
}

Output.prototype.load_V = function(curve, cb) {
  var err, _ref4;
  this.curve = curve;
  _ref4 = curve.<span class="apidocCodeKeywordSpan">mpi_point_from_buffer</span>(this.V_buf), err = _ref4[0], this.V = _ref4[1];
  return cb(err, this.V);
};

Output.parse = function(buf) {
  var C, V_buf, a, n_bits, n_bytes, ret, sb;
  sb = new SlicerBuffer(buf);
  n_bits = sb.read_uint16();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_slicer_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.mpi_point_from_slicer_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>mpi_point_from_slicer_buffer
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_point_from_slicer_buffer = function (sb) {
  var e, err, point, _ref;
  err = point = null;
  try {
    _ref = this._mpi_point_from_slicer_buffer(sb), err = _ref[0], point = _ref[1];
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, point];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pre = sb.rem();
l = sb.read_uint8();
oid = sb.read_buffer(l);
_ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];
if (err != null) {
  throw err;
}
_ref2 = curve.<span class="apidocCodeKeywordSpan">mpi_point_from_slicer_buffer</span>(sb), err = _ref2[0], R = _ref2[1];
if (err != null) {
  throw err;
}
pub = new klass({
  curve: curve,
  R: R
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.nbits" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  return this.p.bitLength();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>point_to_mpi_buffer
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point_to_mpi_buffer = function (p) {
  var ret, sz;
  sz = this.mpi_coord_byte_size();
  ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x4]), p.affineX.toBuffer(sz), p.affineY.toBuffer(sz
)]);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function BaseEccKey(_arg) {
  this.curve = _arg.curve, this.R = _arg.R;
}

BaseEccKey.prototype.serialize = function() {
  var oid;
  oid = this.curve.oid;
  return Buffer.concat([new Buffer([oid.length]), oid, this.curve.<span class="apidocCodeKeywordSpan">point_to_mpi_buffer</span>(
this.R)]);
};

BaseEccKey._alloc = function(klass, raw) {
  var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  l = sb.read_uint8();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer_compact" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.point_to_mpi_buffer_compact">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>point_to_mpi_buffer_compact
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point_to_mpi_buffer_compact = function (p) {
  return p.affineX.toBuffer(this.mpi_coord_byte_size());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params
(), new Buffer(&#x22;Anonymous Sender    &#x22;, &#x22;utf8&#x22;), fingerprint]);
};

Pub.prototype.kdf = function(_arg) {
  var X, X_compact, buf, hash, o_bytes, params;
  X = _arg.X, params = _arg.params;
  o_bytes = this.cipher.key_size;
  X_compact = this.curve.<span class="apidocCodeKeywordSpan">point_to_mpi_buffer_compact</span>(X);
  buf = Buffer.concat([new Buffer([0, 0, 0, 1]), X_compact, params]);
  hash = this.hasher(buf);
  return hash.slice(0, o_bytes);
};

Pub.prototype.encrypt = function(m, _arg, cb) {
  var C, S, V, fingerprint, key, params, ___iced_passed_deferral, __iced_deferrals, __iced_k;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve.prototype.random_scalar" id="apidoc.element.kbpgp.ecc.curves.Curve.prototype.random_scalar">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve.prototype.</span>random_scalar
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random_scalar = function (cb) {
  var k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/curves.iced&#x22;,
        funcname: &#x22;Curve.random_scalar&#x22;
      });
      SRF().random_zn(_this.n.subtract(bn.nbv(2)), __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return k = arguments[0];
          };
        })(),
        lineno: 103
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      k = k.add(bn.BigInteger.ONE);
      return cb(k);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced&#x22;,
    funcname: &#x22;Priv.sign&#x22;
  });
  _this.pub.curve.<span class="apidocCodeKeywordSpan">random_scalar</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return k = arguments[0];
      };
    })(),
    lineno: 79
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecc.curves.Curve25519.prototype" id="apidoc.module.kbpgp.ecc.curves.Curve25519.prototype">module kbpgp.ecc.curves.Curve25519.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype._mpi_point_from_slicer_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype._mpi_point_from_slicer_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>_mpi_point_from_slicer_buffer
        <span class="apidocSignatureSpan">(sb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mpi_point_from_slicer_buffer = function (sb) {
  var b, bits, n_bits, n_bytes, point;
  n_bits = sb.read_uint16();
  n_bytes = Math.ceil(n_bits / 8);
  if (n_bytes !== (b = this.mpi_byte_size())) {
    bits = this.mpi_bit_size();
    throw new Error(&#x22;Need &#x22; + b + &#x22; bytes (&#x22; + bits + &#x22; bits) for this curve; got &#x22; + n_bytes + &#x22; (&#x22; + n_bits + &#x22; bits)&#x22;);
  }
  if (sb.read_uint8() !== 0x40) {
    throw new Error(&#x22;Can only handle 0x40 prefix for 25519 MPI representations&#x22;);
  }
  n_bytes = this.mpi_coord_byte_size();
  point = sb.read_buffer(n_bytes);
  return [null, point];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.constructor" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Curve25519(_arg) {
  this.oid = _arg.oid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.coord_to_mpi_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.coord_to_mpi_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>coord_to_mpi_buffer
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coord_to_mpi_buffer = function (p) {
  var byte_size;
  byte_size = this.mpi_coord_byte_size();
  return Buffer.concat([uint_to_buffer(16, byte_size * 8), p]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Priv(_arg) {
  this.x = _arg.x, this.pub = _arg.pub;
}

Priv.prototype.serialize = function() {
  var curve;
  curve = this.pub.curve;
  return curve.<span class="apidocCodeKeywordSpan">coord_to_mpi_buffer</span>(this.x);
};

Priv.alloc = function(raw, pub) {
  var curve, d, err, o, orig_len, _i, _len, _ref4, _ref5;
  orig_len = raw.length;
  err = null;
  curve = pub.curve;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.decrypt" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(x, V)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (x, V) {
  var S;
  x = Curve25519.reverse_buf(x);
  S = kbnacl.alloc({}).scalarmult(x, V);
  return S;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.encrypt" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(R, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (R, cb) {
  var S, V, nacl, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/curves.iced&#x22;,
        funcname: &#x22;Curve25519.encrypt&#x22;
      });
      _this.random_scalar(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return v = arguments[0];
          };
        })(),
        lineno: 257
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      nacl = kbnacl.alloc({});
      V = nacl.scalarmult_base(v);
      S = nacl.scalarmult(v, R);
      return cb({
        V: V,
        S: S
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.generate" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.generate">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>generate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (cb) {
  var R, x, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/curves.iced&#x22;,
        funcname: &#x22;Curve25519.generate&#x22;
      });
      _this.random_scalar(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return x = arguments[0];
          };
        })(),
        lineno: 291
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      R = kbnacl.alloc({}).scalarmult_base(x);
      x = Curve25519.reverse_buf(x);
      return cb({
        x: x,
        R: R
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_bit_size" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_bit_size">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>mpi_bit_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_bit_size = function () {
  return 263;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_from_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.mpi_from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>mpi_from_buffer
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mpi_from_buffer = function (raw) {
  var err, hdr, i, n_bits, n_bytes;
  err = i = null;
  if (raw.length &#x3c; 2) {
    err = new Error(&#x22;need at least 2 bytes; got &#x22; + raw.length);
  } else {
    hdr = new Buffer(raw.slice(0, 2));
    raw = raw.slice(2);
    n_bits = hdr.readUInt16BE(0);
    n_bytes = Math.ceil(n_bits / 8);
    if (raw.length &#x3c; n_bytes) {
      err = new Error(&#x22;MPI said &#x22; + n_bytes + &#x22; bytes but only got &#x22; + raw.length);
    } else {
      i = raw.slice(0, n_bytes);
      raw = raw.slice(n_bytes);
    }
  }
  return [err, i, raw, n_bytes + 2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
orig_len = raw.length;
err = null;
_ref1 = klass.ORDER;
for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
  o = _ref1[_i];
  if (err == null) {
    _ref2 = bn.<span class="apidocCodeKeywordSpan">mpi_from_buffer</span>(raw), err = _ref2[0], d[o] = _ref2[1], raw = _ref2[2];
  }
}
if (err) {
  return [err, null];
} else {
  return [null, new klass(d), orig_len - raw.length];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.nbits" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.nbits">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>nbits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbits = function () {
  return 256;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BaseKeyPair.prototype.is_toxic = function() {
  return false;
};

BaseKeyPair.prototype.nbits = function() {
  var _ref1;
  return (_ref1 = this.pub) != null ? _ref1.<span class="apidocCodeKeywordSpan">nbits</span>() : void 0;
};

BaseKeyPair.prototype.good_for_flags = function() {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;
};

BaseKeyPair.prototype.eq = function(k2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>point_to_mpi_buffer
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point_to_mpi_buffer = function (p) {
  var ret, sz;
  sz = this.mpi_coord_byte_size();
  ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x40]), p]);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function BaseEccKey(_arg) {
  this.curve = _arg.curve, this.R = _arg.R;
}

BaseEccKey.prototype.serialize = function() {
  var oid;
  oid = this.curve.oid;
  return Buffer.concat([new Buffer([oid.length]), oid, this.curve.<span class="apidocCodeKeywordSpan">point_to_mpi_buffer</span>(
this.R)]);
};

BaseEccKey._alloc = function(klass, raw) {
  var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;
  sb = new SlicerBuffer(raw);
  pre = sb.rem();
  l = sb.read_uint8();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer_compact" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.point_to_mpi_buffer_compact">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>point_to_mpi_buffer_compact
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">point_to_mpi_buffer_compact = function (p) {
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params
(), new Buffer(&#x22;Anonymous Sender    &#x22;, &#x22;utf8&#x22;), fingerprint]);
};

Pub.prototype.kdf = function(_arg) {
  var X, X_compact, buf, hash, o_bytes, params;
  X = _arg.X, params = _arg.params;
  o_bytes = this.cipher.key_size;
  X_compact = this.curve.<span class="apidocCodeKeywordSpan">point_to_mpi_buffer_compact</span>(X);
  buf = Buffer.concat([new Buffer([0, 0, 0, 1]), X_compact, params]);
  hash = this.hasher(buf);
  return hash.slice(0, o_bytes);
};

Pub.prototype.encrypt = function(m, _arg, cb) {
  var C, S, V, fingerprint, key, params, ___iced_passed_deferral, __iced_deferrals, __iced_k;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.random_scalar" id="apidoc.element.kbpgp.ecc.curves.Curve25519.prototype.random_scalar">
        function <span class="apidocSignatureSpan">kbpgp.ecc.curves.Curve25519.prototype.</span>random_scalar
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random_scalar = function (cb) {
  return SRF().random_bytes(this.mpi_coord_byte_size(), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced&#x22;,
    funcname: &#x22;Priv.sign&#x22;
  });
  _this.pub.curve.<span class="apidocCodeKeywordSpan">random_scalar</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return k = arguments[0];
      };
    })(),
    lineno: 79
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecdh" id="apidoc.module.kbpgp.ecdh">module kbpgp.ecdh</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecdh.ECDH" id="apidoc.element.kbpgp.ecdh.ECDH">
        function <span class="apidocSignatureSpan">kbpgp.ecdh.</span>ECDH
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecdh.Pair" id="apidoc.element.kbpgp.ecdh.Pair">
        function <span class="apidocSignatureSpan">kbpgp.ecdh.</span>Pair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair() {
  return Pair.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ecdsa" id="apidoc.module.kbpgp.ecdsa">module kbpgp.ecdsa</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ecdsa.ECDSA" id="apidoc.element.kbpgp.ecdsa.ECDSA">
        function <span class="apidocSignatureSpan">kbpgp.ecdsa.</span>ECDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ecdsa.Pair" id="apidoc.element.kbpgp.ecdsa.Pair">
        function <span class="apidocSignatureSpan">kbpgp.ecdsa.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.eddsa" id="apidoc.module.kbpgp.eddsa">module kbpgp.eddsa</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.eddsa.EDDSA" id="apidoc.element.kbpgp.eddsa.EDDSA">
        function <span class="apidocSignatureSpan">kbpgp.eddsa.</span>EDDSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.eddsa.Pair" id="apidoc.element.kbpgp.eddsa.Pair">
        function <span class="apidocSignatureSpan">kbpgp.eddsa.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.elgamal" id="apidoc.module.kbpgp.elgamal">module kbpgp.elgamal</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.elgamal.ElGamal" id="apidoc.element.kbpgp.elgamal.ElGamal">
        function <span class="apidocSignatureSpan">kbpgp.elgamal.</span>ElGamal
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.elgamal.Pair" id="apidoc.element.kbpgp.elgamal.Pair">
        function <span class="apidocSignatureSpan">kbpgp.elgamal.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.elgamalse" id="apidoc.module.kbpgp.elgamalse">module kbpgp.elgamalse</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.elgamalse.ElGamalSignEncrypt" id="apidoc.element.kbpgp.elgamalse.ElGamalSignEncrypt">
        function <span class="apidocSignatureSpan">kbpgp.elgamalse.</span>ElGamalSignEncrypt
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.elgamalse.Pair" id="apidoc.element.kbpgp.elgamalse.Pair">
        function <span class="apidocSignatureSpan">kbpgp.elgamalse.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  pub = _arg.pub, priv = _arg.priv;
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.encode" id="apidoc.module.kbpgp.encode">module kbpgp.encode</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.encode.pack" id="apidoc.element.kbpgp.encode.pack">
        function <span class="apidocSignatureSpan">kbpgp.encode.</span>pack
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pack = function (x) {
  return purepack.pack(x, {
    sort_keys: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
purepack = require(&#x27;purepack&#x27;);

_ref1 = require(&#x27;../util&#x27;), katch = _ref1.katch, obj_extract = _ref1.obj_extract, bufeq_secure = _ref1.bufeq_secure;

null_hash = new Buffer(0);

pack = function(x) {
  return purepack.<span class="apidocCodeKeywordSpan">pack</span>(x, {
    sort_keys: true
  });
};

unpack = function(x) {
  return purepack.unpack(x, {
    strict: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.encode.read_base64" id="apidoc.element.kbpgp.encode.read_base64">
        function <span class="apidocSignatureSpan">kbpgp.encode.</span>read_base64
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_base64 = function (raw) {
  var parts;
  parts = (raw.split(/\s+/)).join(&#x27;&#x27;);
  return new Buffer(parts, &#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.encode.seal" id="apidoc.element.kbpgp.encode.seal">
        function <span class="apidocSignatureSpan">kbpgp.encode.</span>seal
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seal = function (_arg) {
  var dohash, hasher, obj, oo, packed;
  obj = _arg.obj, dohash = _arg.dohash;
  hasher = SHA256;
  oo = {
    version: K.versions.V1,
    tag: obj.tag,
    body: obj.body
  };
  if (dohash) {
    oo.hash = {
      type: hasher.type,
      value: null_hash
    };
    packed = pack(oo);
    oo.hash.value = hasher(packed);
  }
  return pack(oo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.encode.unpack" id="apidoc.element.kbpgp.encode.unpack">
        function <span class="apidocSignatureSpan">kbpgp.encode.</span>unpack
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpack = function (x) {
  return purepack.unpack(x, {
    strict: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pack = function(x) {
  return purepack.pack(x, {
    sort_keys: true
  });
};

unpack = function(x) {
  return purepack.<span class="apidocCodeKeywordSpan">unpack</span>(x, {
    strict: true
  });
};

seal = function(_arg) {
  var dohash, hasher, obj, oo, packed;
  obj = _arg.obj, dohash = _arg.dohash;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.encode.unseal" id="apidoc.element.kbpgp.encode.unseal">
        function <span class="apidocSignatureSpan">kbpgp.encode.</span>unseal
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unseal = function (buf) {
  var h, hasher, hv, oo, t, _ref2;
  oo = unpack(buf);
  if ((hv = oo != null ? (_ref2 = oo.hash) != null ? _ref2.value : void 0 : void 0) != null) {
    oo.hash.value = null_hash;
    hasher = alloc((t = oo.hash.type));
    if (hasher == null) {
      throw new Error(&#x22;unknown hash algo: &#x22; + t);
    }
    h = hasher(pack(oo));
    if (!bufeq_secure(h, hv)) {
      throw new Error(&#x22;hash mismatch&#x22;);
    }
    if (oo.version !== K.versions.V1) {
      throw new Error(&#x22;unknown version&#x22;);
    }
  }
  return obj_extract(oo, [&#x27;tag&#x27;, &#x27;body&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.errors" id="apidoc.module.kbpgp.errors">module kbpgp.errors</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.errors.RevokedKeyError" id="apidoc.element.kbpgp.errors.RevokedKeyError">
        function <span class="apidocSignatureSpan">kbpgp.errors.</span>RevokedKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RevokedKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.errors.WrongSigningKeyError" id="apidoc.element.kbpgp.errors.WrongSigningKeyError">
        function <span class="apidocSignatureSpan">kbpgp.errors.</span>WrongSigningKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WrongSigningKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.errors.RevokedKeyError" id="apidoc.module.kbpgp.errors.RevokedKeyError">module kbpgp.errors.RevokedKeyError</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.errors.RevokedKeyError.RevokedKeyError" id="apidoc.element.kbpgp.errors.RevokedKeyError.RevokedKeyError">
        function <span class="apidocSignatureSpan">kbpgp.errors.</span>RevokedKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RevokedKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.errors.RevokedKeyError.super_" id="apidoc.element.kbpgp.errors.RevokedKeyError.super_">
        function <span class="apidocSignatureSpan">kbpgp.errors.RevokedKeyError.</span>super_
        <span class="apidocSignatureSpan">(msg, constructor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (msg, constructor) {
  if (typeof Error.captureStackTrace === &#x22;function&#x22;) {
    Error.captureStackTrace(this, this.constructor);
  }
  return this.message = msg || &#x27;Error&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.errors.RevokedKeyError.prototype" id="apidoc.module.kbpgp.errors.RevokedKeyError.prototype">module kbpgp.errors.RevokedKeyError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.errors.RevokedKeyError.prototype.inspect" id="apidoc.element.kbpgp.errors.RevokedKeyError.prototype.inspect">
        function <span class="apidocSignatureSpan">kbpgp.errors.RevokedKeyError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return &#x22;[&#x22; + k + &#x22;: &#x22; + this.message + &#x22; (code &#x22; + this.code + &#x22;)]&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.errors.WrongSigningKeyError" id="apidoc.module.kbpgp.errors.WrongSigningKeyError">module kbpgp.errors.WrongSigningKeyError</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.WrongSigningKeyError" id="apidoc.element.kbpgp.errors.WrongSigningKeyError.WrongSigningKeyError">
        function <span class="apidocSignatureSpan">kbpgp.errors.</span>WrongSigningKeyError
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WrongSigningKeyError = function (msg) {
  BaseError.call(this, msg || default_msg, this.constructor);
  this.istack = [];
  this.code = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.super_" id="apidoc.element.kbpgp.errors.WrongSigningKeyError.super_">
        function <span class="apidocSignatureSpan">kbpgp.errors.WrongSigningKeyError.</span>super_
        <span class="apidocSignatureSpan">(msg, constructor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (msg, constructor) {
  if (typeof Error.captureStackTrace === &#x22;function&#x22;) {
    Error.captureStackTrace(this, this.constructor);
  }
  return this.message = msg || &#x27;Error&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.errors.WrongSigningKeyError.prototype" id="apidoc.module.kbpgp.errors.WrongSigningKeyError.prototype">module kbpgp.errors.WrongSigningKeyError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.errors.WrongSigningKeyError.prototype.inspect" id="apidoc.element.kbpgp.errors.WrongSigningKeyError.prototype.inspect">
        function <span class="apidocSignatureSpan">kbpgp.errors.WrongSigningKeyError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return &#x22;[&#x22; + k + &#x22;: &#x22; + this.message + &#x22; (code &#x22; + this.code + &#x22;)]&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash" id="apidoc.module.kbpgp.hash">module kbpgp.hash</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5" id="apidoc.element.kbpgp.hash.MD5">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>MD5
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MD5 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160" id="apidoc.element.kbpgp.hash.RIPEMD160">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>RIPEMD160
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RIPEMD160 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1" id="apidoc.element.kbpgp.hash.SHA1">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA1
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA1 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224" id="apidoc.element.kbpgp.hash.SHA224">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA224
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA224 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256" id="apidoc.element.kbpgp.hash.SHA256">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA256
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA256 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  S2K = (function() {
S2K.prototype._count = function(c, bias) {
  return (16 + (c &#x26; 15)) &#x3c;&#x3c; ((c &#x3e;&#x3e; 4) + bias);
};

function S2K() {
  this.hash = SHA256;
  this.streamer = streamers.<span class="apidocCodeKeywordSpan">SHA256</span>();
}

S2K.prototype.set_hash_algorithm = function(which) {
  if ((this.hash = alloc(which)) != null) {
    return this.streamer = streamers[this.hash.algname]();
  } else {
    console.warn(&#x22;No such hash: &#x22; + which + &#x22;; defaulting to SHA-256&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384" id="apidoc.element.kbpgp.hash.SHA384">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA384
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA384 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512" id="apidoc.element.kbpgp.hash.SHA512">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA512
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA512 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signer.prototype._run_hash = function(cb) {
  var err;
  err = null;
  if (this.hash_streamer != null) {

  } else if (this.data != null) {
    this.hash_streamer = streamers.<span class="apidocCodeKeywordSpan">SHA512</span>();
    this.hash_streamer.update(this.data);
  } else {
    err = new Error(&#x22;Need either a hasher or data&#x22;);
  }
  return cb(err);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.alloc" id="apidoc.element.kbpgp.hash.alloc">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>alloc
        <span class="apidocSignatureSpan">(typ)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (typ) {
  var klass, name, ret;
  ret = null;
  name = _lookup[typ];
  if (name != null) {
    klass = algos[name];
  }
  if (klass != null) {
    ret = make_hasher(klass, name, typ);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.alloc_or_throw" id="apidoc.element.kbpgp.hash.alloc_or_throw">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>alloc_or_throw
        <span class="apidocSignatureSpan">(typ)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc_or_throw = function (typ) {
  var ret;
  ret = alloc(typ);
  if (!ret) {
    throw new Error(&#x22;unknown hash type: &#x22; + typ);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var n, size, v, val;
  if ((size = sb.read_uint8()) &#x3c; (n = Const.ecdh.param_bytes)) {
    throw new Error(&#x22;Need at least &#x22; + n + &#x22; bytes of params; got &#x22; + size);
  }
  if ((val = sb.read_uint8()) !== (v = Const.ecdh.version)) {
    throw new Error(&#x22;Cannot deal with future extensions, byte=&#x22; + val + &#x22;; wanted &#x22; + v);
  }
  this.hasher = hashmod.<span class="apidocCodeKeywordSpan">alloc_or_throw</span>(sb.read_uint8());
  this.cipher = sym.get_cipher(sb.read_uint8());
  return sb.advance(size - 3);
};

Pub.alloc = function(raw) {
  return BaseEccKey.alloc(Pub, raw);
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.MD5" id="apidoc.module.kbpgp.hash.MD5">module kbpgp.hash.MD5</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.MD5" id="apidoc.element.kbpgp.hash.MD5.MD5">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>MD5
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MD5 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass" id="apidoc.element.kbpgp.hash.MD5.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MD5() {
  return MD5.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.MD5.klass.prototype" id="apidoc.module.kbpgp.hash.MD5.klass.prototype">module kbpgp.hash.MD5.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.MD5.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var H, H_i, data, dataWords, hash, i, nBitsLeft, nBitsTotal, nBitsTotalH, nBitsTotalL, _i;
  data = this._data;
  dataWords = data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = data.sigBytes * 8;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x80 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
  nBitsTotalL = nBitsTotal;
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 15] = (((nBitsTotalH &#x3c;&#x3c; 8) | (nBitsTotalH &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((nBitsTotalH &#x3c;&#x3c;
24) | (nBitsTotalH &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 14] = (((nBitsTotalL &#x3c;&#x3c; 8) | (nBitsTotalL &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((nBitsTotalL &#x3c;&#x3c;
24) | (nBitsTotalL &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
  data.sigBytes = (dataWords.length + 1) * 4;
  this._process();
  hash = this._hash;
  H = hash.words;
  for (i = _i = 0; _i &#x3c; 4; i = ++_i) {
    H_i = H[i];
    H[i] = (((H_i &#x3c;&#x3c; 8) | (H_i &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((H_i &#x3c;&#x3c; 24) | (H_i &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
  }
  return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doProcessBlock" id="apidoc.element.kbpgp.hash.MD5.klass.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var H, M_offset_0, M_offset_1, M_offset_10, M_offset_11, M_offset_12, M_offset_13, M_offset_14, M_offset_15, M_offset_2, M_offset_3
, M_offset_4, M_offset_5, M_offset_6, M_offset_7, M_offset_8, M_offset_9, M_offset_i, a, b, c, d, i, offset_i, _i;
  for (i = _i = 0; _i &#x3c; 16; i = ++_i) {
    offset_i = offset + i;
    M_offset_i = M[offset_i];
    M[offset_i] = (((M_offset_i &#x3c;&#x3c; 8) | (M_offset_i &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((M_offset_i &#x3c;&#x3c; 24) | (M_offset_i &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00
);
  }
  H = this._hash.words;
  M_offset_0 = M[offset + 0];
  M_offset_1 = M[offset + 1];
  M_offset_2 = M[offset + 2];
  M_offset_3 = M[offset + 3];
  M_offset_4 = M[offset + 4];
  M_offset_5 = M[offset + 5];
  M_offset_6 = M[offset + 6];
  M_offset_7 = M[offset + 7];
  M_offset_8 = M[offset + 8];
  M_offset_9 = M[offset + 9];
  M_offset_10 = M[offset + 10];
  M_offset_11 = M[offset + 11];
  M_offset_12 = M[offset + 12];
  M_offset_13 = M[offset + 13];
  M_offset_14 = M[offset + 14];
  M_offset_15 = M[offset + 15];
  a = H[0];
  b = H[1];
  c = H[2];
  d = H[3];
  a = FF(a, b, c, d, M_offset_0, 7, glbl.T[0]);
  d = FF(d, a, b, c, M_offset_1, 12, glbl.T[1]);
  c = FF(c, d, a, b, M_offset_2, 17, glbl.T[2]);
  b = FF(b, c, d, a, M_offset_3, 22, glbl.T[3]);
  a = FF(a, b, c, d, M_offset_4, 7, glbl.T[4]);
  d = FF(d, a, b, c, M_offset_5, 12, glbl.T[5]);
  c = FF(c, d, a, b, M_offset_6, 17, glbl.T[6]);
  b = FF(b, c, d, a, M_offset_7, 22, glbl.T[7]);
  a = FF(a, b, c, d, M_offset_8, 7, glbl.T[8]);
  d = FF(d, a, b, c, M_offset_9, 12, glbl.T[9]);
  c = FF(c, d, a, b, M_offset_10, 17, glbl.T[10]);
  b = FF(b, c, d, a, M_offset_11, 22, glbl.T[11]);
  a = FF(a, b, c, d, M_offset_12, 7, glbl.T[12]);
  d = FF(d, a, b, c, M_offset_13, 12, glbl.T[13]);
  c = FF(c, d, a, b, M_offset_14, 17, glbl.T[14]);
  b = FF(b, c, d, a, M_offset_15, 22, glbl.T[15]);
  a = GG(a, b, c, d, M_offset_1, 5, glbl.T[16]);
  d = GG(d, a, b, c, M_offset_6, 9, glbl.T[17]);
  c = GG(c, d, a, b, M_offset_11, 14, glbl.T[18]);
  b = GG(b, c, d, a, M_offset_0, 20, glbl.T[19]);
  a = GG(a, b, c, d, M_offset_5, 5, glbl.T[20]);
  d = GG(d, a, b, c, M_offset_10, 9, glbl.T[21]);
  c = GG(c, d, a, b, M_offset_15, 14, glbl.T[22]);
  b = GG(b, c, d, a, M_offset_4, 20, glbl.T[23]);
  a = GG(a, b, c, d, M_offset_9, 5, glbl.T[24]);
  d = GG(d, a, b, c, M_offset_14, 9, glbl.T[25]);
  c = GG(c, d, a, b, M_offset_3, 14, glbl.T[26]);
  b = GG(b, c, d, a, M_offset_8, 20, glbl.T[27]);
  a = GG(a, b, c, d, M_offset_13, 5, glbl.T[28]);
  d = GG(d, a, b, c, M_offset_2, 9, glbl.T[29]);
  c = GG(c, d, a, b, M_offset_7, 14, glbl.T[30]);
  b = GG(b, c, d, a, M_offset_12, 20, glbl.T[31]);
  a = HH(a, b, c, d, M_offset_5, 4, glbl.T[32]);
  d = HH(d, a, b, c, M_offset_8, 11, glbl.T[33]);
  c = HH(c, d, a, b, M_offset_11, 16, glbl.T[34]);
  b = HH(b, c, d, a, M_offset_14, 23, glbl.T[35]);
  a = HH(a, b, c, d, M_offset_1, 4, glbl.T[36]);
  d = HH(d, a, b, c, M_offset_4, 11, glbl.T[37]);
  c = HH(c, d, a, b, M_offset_7, 16, glbl.T[38]);
  b = HH(b, c, d, a, M_offset_10, 23, glbl.T[39]);
  a = HH(a, b, c, d, M_offset_13, 4, glbl.T[40]);
  d = HH(d, a, b, c, M_offset_0, 11, glbl.T[41]);
  c = HH(c, d, a, b, M_offset_3, 16, glbl.T[42]);
  b = HH(b, c, d, a, M_offset_6, 23, glbl.T[43]);
  a = HH(a, b, c, d, M_offset_9, 4, glbl.T[44]);
  d = HH(d, a, b, c, M_offset_12, 11, glbl.T[45]);
  c = HH(c, d, a, b, M_offset_15, 16, glbl.T[46]);
  b = HH(b, c, d, a, M_offset_2, 23, glbl.T[47]);
  a = II(a, b, c, d, M_offset_0, 6, glbl.T[48]);
  d = II(d, a, b, c, M_offset_7, 10, glbl.T[49]);
  c = II(c, d, a, b, M_offset_14, 15, glbl.T[50]);
  b = II(b, c, d, a, M_offset_5, 21, glbl.T[51]);
  a = II(a, b, c, d, M_offset_12, 6, glbl.T[52]);
  d = II(d, a, b, c, M_offset_3, 10, glbl.T[53]);
  c = II(c, d, a, b, M_offset_10, 15, glbl.T[54]);
  b = II(b, c, d, a, M_offset_1, 21, glbl.T[55]);
  a = II(a, b, c, d, M_offset_8, 6, glbl.T[56]);
  d = II(d, a, b, c, M_offset_15, 10, glbl.T[57]);
  c = II(c, d, a, b, M_offset_6, 15, glbl.T[58]);
  b = II(b, c, d, a, M_offset_13, 21, glbl.T[59]);
  a = II(a, b, c, d, M_offset ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.MD5.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.clone" id="apidoc.element.kbpgp.hash.MD5.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new MD5();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.MD5.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MD5() {
  return MD5.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.MD5.klass.prototype.copy_to" id="apidoc.element.kbpgp.hash.MD5.klass.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.hash.MD5.klass.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  MD5.__super__.copy_to.call(this, obj);
  return obj._hash = this._hash.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.RIPEMD160" id="apidoc.module.kbpgp.hash.RIPEMD160">module kbpgp.hash.RIPEMD160</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.RIPEMD160" id="apidoc.element.kbpgp.hash.RIPEMD160.RIPEMD160">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>RIPEMD160
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RIPEMD160 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass" id="apidoc.element.kbpgp.hash.RIPEMD160.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RIPEMD160() {
  return RIPEMD160.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.RIPEMD160.klass.prototype" id="apidoc.module.kbpgp.hash.RIPEMD160.klass.prototype">module kbpgp.hash.RIPEMD160.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var H, H_i, data, dataWords, hash, i, nBitsLeft, nBitsTotal, _i;
  data = this._data;
  dataWords = data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = data.sigBytes * 8;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x80 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 14] = (((nBitsTotal &#x3c;&#x3c; 8) | (nBitsTotal &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((nBitsTotal &#x3c;&#x3c;
24) | (nBitsTotal &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
  data.sigBytes = (dataWords.length + 1) * 4;
  this._process();
  hash = this._hash;
  H = hash.words;
  for (i = _i = 0; _i &#x3c; 5; i = ++_i) {
    H_i = H[i];
    H[i] = (((H_i &#x3c;&#x3c; 8) | (H_i &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((H_i &#x3c;&#x3c; 24) | (H_i &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
  }
  return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doProcessBlock" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var H, M_offset_i, al, ar, bl, br, cl, cr, dl, dr, el, er, hl, hr, i, offset_i, sl, sr, t, zl, zr, _i, _j;
  for (i = _i = 0; _i &#x3c; 16; i = ++_i) {
    offset_i = offset + i;
    M_offset_i = M[offset_i];
    M[offset_i] = (((M_offset_i &#x3c;&#x3c; 8) | (M_offset_i &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((M_offset_i &#x3c;&#x3c; 24) | (M_offset_i &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00
);
  }
  H = this._hash.words;
  hl = G._hl.words;
  hr = G._hr.words;
  zl = G._zl.words;
  zr = G._zr.words;
  sl = G._sl.words;
  sr = G._sr.words;
  ar = al = H[0];
  br = bl = H[1];
  cr = cl = H[2];
  dr = dl = H[3];
  er = el = H[4];
  for (i = _j = 0; _j &#x3c; 80; i = ++_j) {
    t = (al + M[offset + zl[i]]) | 0;
    if (i &#x3c; 16) {
      t += f1(bl, cl, dl) + hl[0];
    } else if (i &#x3c; 32) {
      t += f2(bl, cl, dl) + hl[1];
    } else if (i &#x3c; 48) {
      t += f3(bl, cl, dl) + hl[2];
    } else if (i &#x3c; 64) {
      t += f4(bl, cl, dl) + hl[3];
    } else {
      t += f5(bl, cl, dl) + hl[4];
    }
    t = t | 0;
    t = rotl(t, sl[i]);
    t = (t + el) | 0;
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = t;
    t = (ar + M[offset + zr[i]]) | 0;
    if (i &#x3c; 16) {
      t += f5(br, cr, dr) + hr[0];
    } else if (i &#x3c; 32) {
      t += f4(br, cr, dr) + hr[1];
    } else if (i &#x3c; 48) {
      t += f3(br, cr, dr) + hr[2];
    } else if (i &#x3c; 64) {
      t += f2(br, cr, dr) + hr[3];
    } else {
      t += f1(br, cr, dr) + hr[4];
    }
    t = t | 0;
    t = rotl(t, sr[i]);
    t = (t + er) | 0;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = t;
  }
  t = (H[1] + cl + dr) | 0;
  H[1] = (H[2] + dl + er) | 0;
  H[2] = (H[3] + el + ar) | 0;
  H[3] = (H[4] + al + br) | 0;
  H[4] = (H[0] + bl + cr) | 0;
  return H[0] = t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new WordArray([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.clone" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new RIPEMD160();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RIPEMD160() {
  return RIPEMD160.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.copy_to" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  RIPEMD160.__super__.copy_to.call(this, obj);
  return obj._hash = this._hash.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.get_output_size" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.get_output_size">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>get_output_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_output_size = function () {
  return this.output_size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.scrub" id="apidoc.element.kbpgp.hash.RIPEMD160.klass.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.hash.RIPEMD160.klass.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  return this._hash.scrub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA1" id="apidoc.module.kbpgp.hash.SHA1">module kbpgp.hash.SHA1</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.SHA1" id="apidoc.element.kbpgp.hash.SHA1.SHA1">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA1
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA1 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass" id="apidoc.element.kbpgp.hash.SHA1.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA1() {
  return SHA1.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA1.klass.prototype" id="apidoc.module.kbpgp.hash.SHA1.klass.prototype">module kbpgp.hash.SHA1.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var data, dataWords, nBitsLeft, nBitsTotal;
  data = this._data;
  dataWords = data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = data.sigBytes * 8;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x80 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 15] = nBitsTotal;
  data.sigBytes = dataWords.length * 4;
  this._process();
  return this._hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doProcessBlock" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var H, a, b, c, d, e, i, n, t, _i;
  H = this._hash.words;
  a = H[0];
  b = H[1];
  c = H[2];
  d = H[3];
  e = H[4];
  for (i = _i = 0; _i &#x3c; 80; i = ++_i) {
    if (i &#x3c; 16) {
      W[i] = M[offset + i] | 0;
    } else {
      n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      W[i] = (n &#x3c;&#x3c; 1) | (n &#x3e;&#x3e;&#x3e; 31);
    }
    t = ((a &#x3c;&#x3c; 5) | (a &#x3e;&#x3e;&#x3e; 27)) + e + W[i];
    if (i &#x3c; 20) {
      t += ((b &#x26; c) | (~b &#x26; d)) + 0x5a827999;
    } else if (i &#x3c; 40) {
      t += (b ^ c ^ d) + 0x6ed9eba1;
    } else if (i &#x3c; 60) {
      t += ((b &#x26; c) | (b &#x26; d) | (c &#x26; d)) - 0x70e44324;
    } else {
      t += (b ^ c ^ d) - 0x359d3e2a;
    }
    e = d;
    d = c;
    c = (b &#x3c;&#x3c; 30) | (b &#x3e;&#x3e;&#x3e; 2);
    b = a;
    a = t;
  }
  H[0] = (H[0] + a) | 0;
  H[1] = (H[1] + b) | 0;
  H[2] = (H[2] + c) | 0;
  H[3] = (H[3] + d) | 0;
  return H[4] = (H[4] + e) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.clone" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA1();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA1() {
  return SHA1.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA1.klass.prototype.copy_to" id="apidoc.element.kbpgp.hash.SHA1.klass.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA1.klass.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  SHA1.__super__.copy_to.call(this, obj);
  return obj._hash = this._hash.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA224" id="apidoc.module.kbpgp.hash.SHA224">module kbpgp.hash.SHA224</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.SHA224" id="apidoc.element.kbpgp.hash.SHA224.SHA224">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA224
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA224 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.klass" id="apidoc.element.kbpgp.hash.SHA224.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA224() {
  return SHA224.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA224.klass.prototype" id="apidoc.module.kbpgp.hash.SHA224.klass.prototype">module kbpgp.hash.SHA224.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.SHA224.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var hash;
  hash = SHA224.__super__._doFinalize.call(this);
  hash.sigBytes -= 4;
  return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.SHA224.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new WordArray([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype.clone" id="apidoc.element.kbpgp.hash.SHA224.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA224();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA224.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.SHA224.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA224.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA224() {
  return SHA224.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA256" id="apidoc.module.kbpgp.hash.SHA256">module kbpgp.hash.SHA256</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.SHA256" id="apidoc.element.kbpgp.hash.SHA256.SHA256">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA256
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA256 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  S2K = (function() {
S2K.prototype._count = function(c, bias) {
  return (16 + (c &#x26; 15)) &#x3c;&#x3c; ((c &#x3e;&#x3e; 4) + bias);
};

function S2K() {
  this.hash = SHA256;
  this.streamer = streamers.<span class="apidocCodeKeywordSpan">SHA256</span>();
}

S2K.prototype.set_hash_algorithm = function(which) {
  if ((this.hash = alloc(which)) != null) {
    return this.streamer = streamers[this.hash.algname]();
  } else {
    console.warn(&#x22;No such hash: &#x22; + which + &#x22;; defaulting to SHA-256&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass" id="apidoc.element.kbpgp.hash.SHA256.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA256() {
  return SHA256.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA256.klass.prototype" id="apidoc.module.kbpgp.hash.SHA256.klass.prototype">module kbpgp.hash.SHA256.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var data, dataWords, nBitsLeft, nBitsTotal;
  data = this._data;
  dataWords = data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = data.sigBytes * 8;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x80 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
  dataWords[(((nBitsLeft + 64) &#x3e;&#x3e;&#x3e; 9) &#x3c;&#x3c; 4) + 15] = nBitsTotal;
  data.sigBytes = dataWords.length * 4;
  this._process();
  return this._hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doProcessBlock" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var H, K, W, a, b, c, ch, d, e, f, g, gamma0, gamma0x, gamma1, gamma1x, h, i, maj, sigma0, sigma1, t1, t2, _i;
  H = this._hash.words;
  W = glbl.W;
  K = glbl.K;
  a = H[0];
  b = H[1];
  c = H[2];
  d = H[3];
  e = H[4];
  f = H[5];
  g = H[6];
  h = H[7];
  for (i = _i = 0; _i &#x3c; 64; i = ++_i) {
    if (i &#x3c; 16) {
      W[i] = M[offset + i] | 0;
    } else {
      gamma0x = W[i - 15];
      gamma0 = ((gamma0x &#x3c;&#x3c; 25) | (gamma0x &#x3e;&#x3e;&#x3e; 7)) ^ ((gamma0x &#x3c;&#x3c; 14) | (gamma0x &#x3e;&#x3e;&#x3e; 18)) ^ (gamma0x &#x3e;&#x3e;&#x3e; 3);
      gamma1x = W[i - 2];
      gamma1 = ((gamma1x &#x3c;&#x3c; 15) | (gamma1x &#x3e;&#x3e;&#x3e; 17)) ^ ((gamma1x &#x3c;&#x3c; 13) | (gamma1x &#x3e;&#x3e;&#x3e; 19)) ^ (gamma1x &#x3e;&#x3e;&#x3e; 10);
      W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
    }
    ch = (e &#x26; f) ^ (~e &#x26; g);
    maj = (a &#x26; b) ^ (a &#x26; c) ^ (b &#x26; c);
    sigma0 = ((a &#x3c;&#x3c; 30) | (a &#x3e;&#x3e;&#x3e; 2)) ^ ((a &#x3c;&#x3c; 19) | (a &#x3e;&#x3e;&#x3e; 13)) ^ ((a &#x3c;&#x3c; 10) | (a &#x3e;&#x3e;&#x3e; 22));
    sigma1 = ((e &#x3c;&#x3c; 26) | (e &#x3e;&#x3e;&#x3e; 6)) ^ ((e &#x3c;&#x3c; 21) | (e &#x3e;&#x3e;&#x3e; 11)) ^ ((e &#x3c;&#x3c; 7) | (e &#x3e;&#x3e;&#x3e; 25));
    t1 = h + sigma1 + ch + K[i] + W[i];
    t2 = sigma0 + maj;
    h = g;
    g = f;
    f = e;
    e = (d + t1) | 0;
    d = c;
    c = b;
    b = a;
    a = (t1 + t2) | 0;
  }
  H[0] = (H[0] + a) | 0;
  H[1] = (H[1] + b) | 0;
  H[2] = (H[2] + c) | 0;
  H[3] = (H[3] + d) | 0;
  H[4] = (H[4] + e) | 0;
  H[5] = (H[5] + f) | 0;
  H[6] = (H[6] + g) | 0;
  return H[7] = (H[7] + h) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new WordArray(glbl.H.slice(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.clone" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA256();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA256() {
  return SHA256.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.copy_to" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  SHA256.__super__.copy_to.call(this, obj);
  return obj._hash = this._hash.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.get_output_size" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype.get_output_size">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>get_output_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_output_size = function () {
  return this.output_size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA256.klass.prototype.scrub" id="apidoc.element.kbpgp.hash.SHA256.klass.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA256.klass.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  return this._hash.scrub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA384" id="apidoc.module.kbpgp.hash.SHA384">module kbpgp.hash.SHA384</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.SHA384" id="apidoc.element.kbpgp.hash.SHA384.SHA384">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA384
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA384 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.klass" id="apidoc.element.kbpgp.hash.SHA384.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA384() {
  return SHA384.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA384.klass.prototype" id="apidoc.module.kbpgp.hash.SHA384.klass.prototype">module kbpgp.hash.SHA384.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.SHA384.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var hash;
  hash = SHA384.__super__._doFinalize.call(this);
  hash.sigBytes -= 16;
  return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.SHA384.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = new X64WordArray(Global.convert([0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8
, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype.clone" id="apidoc.element.kbpgp.hash.SHA384.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA384();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA384.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.SHA384.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA384.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA384() {
  return SHA384.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA512" id="apidoc.module.kbpgp.hash.SHA512">module kbpgp.hash.SHA512</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.SHA512" id="apidoc.element.kbpgp.hash.SHA512.SHA512">
        function <span class="apidocSignatureSpan">kbpgp.hash.</span>SHA512
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA512 = function (x) {
  return (new klass).bufhash(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signer.prototype._run_hash = function(cb) {
  var err;
  err = null;
  if (this.hash_streamer != null) {

  } else if (this.data != null) {
    this.hash_streamer = streamers.<span class="apidocCodeKeywordSpan">SHA512</span>();
    this.hash_streamer.update(this.data);
  } else {
    err = new Error(&#x22;Need either a hasher or data&#x22;);
  }
  return cb(err);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass" id="apidoc.element.kbpgp.hash.SHA512.klass">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.</span>klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA512() {
  return SHA512.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset
()) : !sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.<span class="apidocCodeKeywordSpan">klass</span>(WordArray.from_buffer(key));
};

exports.export_key_pgp = export_key_pgp = function(algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.SHA512.klass.prototype" id="apidoc.module.kbpgp.hash.SHA512.klass.prototype">module kbpgp.hash.SHA512.klass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doFinalize" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var dataWords, nBitsLeft, nBitsTotal;
  dataWords = this._data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = this._data.sigBytes * 8;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x80 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  dataWords[(((nBitsLeft + 128) &#x3e;&#x3e;&#x3e; 10) &#x3c;&#x3c; 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
  dataWords[(((nBitsLeft + 128) &#x3e;&#x3e;&#x3e; 10) &#x3c;&#x3c; 5) + 31] = nBitsTotal;
  this._data.sigBytes = dataWords.length * 4;
  this._process();
  return this._hash.toX32();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doProcessBlock" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var H, H0, H0h, H0l, H1, H1h, H1l, H2, H2h, H2l, H3, H3h, H3l, H4, H4h, H4l, H5, H5h, H5l, H6, H6h, H6l, H7, H7h, H7l, Ki, Kih
, Kil, W, Wi, Wi16, Wi16h, Wi16l, Wi7, Wi7h, Wi7l, Wih, Wil, ah, al, bh, bl, ch, chh, chl, cl, dh, dl, eh, el, fh, fl, gamma0h,
gamma0l, gamma0x, gamma0xh, gamma0xl, gamma1h, gamma1l, gamma1x, gamma1xh, gamma1xl, gh, gl, hh, hl, i, majh, majl, sigma0h, sigma0l
, sigma1h, sigma1l, t1h, t1l, t2h, t2l, _i;
  H = this._hash.words;
  W = glbl.W;
  H0 = H[0];
  H1 = H[1];
  H2 = H[2];
  H3 = H[3];
  H4 = H[4];
  H5 = H[5];
  H6 = H[6];
  H7 = H[7];
  H0h = H0.high;
  H0l = H0.low;
  H1h = H1.high;
  H1l = H1.low;
  H2h = H2.high;
  H2l = H2.low;
  H3h = H3.high;
  H3l = H3.low;
  H4h = H4.high;
  H4l = H4.low;
  H5h = H5.high;
  H5l = H5.low;
  H6h = H6.high;
  H6l = H6.low;
  H7h = H7.high;
  H7l = H7.low;
  ah = H0h;
  al = H0l;
  bh = H1h;
  bl = H1l;
  ch = H2h;
  cl = H2l;
  dh = H3h;
  dl = H3l;
  eh = H4h;
  el = H4l;
  fh = H5h;
  fl = H5l;
  gh = H6h;
  gl = H6l;
  hh = H7h;
  hl = H7l;
  for (i = _i = 0; _i &#x3c; 80; i = ++_i) {
    Wi = W[i];
    if (i &#x3c; 16) {
      Wih = Wi.high = M[offset + i * 2] | 0;
      Wil = Wi.low = M[offset + i * 2 + 1] | 0;
    } else {
      gamma0x = W[i - 15];
      gamma0xh = gamma0x.high;
      gamma0xl = gamma0x.low;
      gamma0h = ((gamma0xh &#x3e;&#x3e;&#x3e; 1) | (gamma0xl &#x3c;&#x3c; 31)) ^ ((gamma0xh &#x3e;&#x3e;&#x3e; 8) | (gamma0xl &#x3c;&#x3c; 24)) ^ (gamma0xh &#x3e;&#x3e;&#x3e; 7);
      gamma0l = ((gamma0xl &#x3e;&#x3e;&#x3e; 1) | (gamma0xh &#x3c;&#x3c; 31)) ^ ((gamma0xl &#x3e;&#x3e;&#x3e; 8) | (gamma0xh &#x3c;&#x3c; 24)) ^ ((gamma0xl &#x3e;&#x3e;&#x3e; 7) | (gamma0xh &#x3c;&#x3c;
25));
      gamma1x = W[i - 2];
      gamma1xh = gamma1x.high;
      gamma1xl = gamma1x.low;
      gamma1h = ((gamma1xh &#x3e;&#x3e;&#x3e; 19) | (gamma1xl &#x3c;&#x3c; 13)) ^ ((gamma1xh &#x3c;&#x3c; 3) | (gamma1xl &#x3e;&#x3e;&#x3e; 29)) ^ (gamma1xh &#x3e;&#x3e;&#x3e; 6);
      gamma1l = ((gamma1xl &#x3e;&#x3e;&#x3e; 19) | (gamma1xh &#x3c;&#x3c; 13)) ^ ((gamma1xl &#x3c;&#x3c; 3) | (gamma1xh &#x3e;&#x3e;&#x3e; 29)) ^ ((gamma1xl &#x3e;&#x3e;&#x3e; 6) | (gamma1xh &#x3c;&#x3c;
26));
      Wi7 = W[i - 7];
      Wi7h = Wi7.high;
      Wi7l = Wi7.low;
      Wi16 = W[i - 16];
      Wi16h = Wi16.high;
      Wi16l = Wi16.low;
      Wil = gamma0l + Wi7l;
      Wih = gamma0h + Wi7h + ((Wil &#x3e;&#x3e;&#x3e; 0) &#x3c; (gamma0l &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
      Wil = Wil + gamma1l;
      Wih = Wih + gamma1h + ((Wil &#x3e;&#x3e;&#x3e; 0) &#x3c; (gamma1l &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
      Wil = Wil + Wi16l;
      Wih = Wih + Wi16h + ((Wil &#x3e;&#x3e;&#x3e; 0) &#x3c; (Wi16l &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
      Wi.high = Wih;
      Wi.low = Wil;
    }
    chh = (eh &#x26; fh) ^ (~eh &#x26; gh);
    chl = (el &#x26; fl) ^ (~el &#x26; gl);
    majh = (ah &#x26; bh) ^ (ah &#x26; ch) ^ (bh &#x26; ch);
    majl = (al &#x26; bl) ^ (al &#x26; cl) ^ (bl &#x26; cl);
    sigma0h = ((ah &#x3e;&#x3e;&#x3e; 28) | (al &#x3c;&#x3c; 4)) ^ ((ah &#x3c;&#x3c; 30) | (al &#x3e;&#x3e;&#x3e; 2)) ^ ((ah &#x3c;&#x3c; 25) | (al &#x3e;&#x3e;&#x3e; 7));
    sigma0l = ((al &#x3e;&#x3e;&#x3e; 28) | (ah &#x3c;&#x3c; 4)) ^ ((al &#x3c;&#x3c; 30) | (ah &#x3e;&#x3e;&#x3e; 2)) ^ ((al &#x3c;&#x3c; 25) | (ah &#x3e;&#x3e;&#x3e; 7));
    sigma1h = ((eh &#x3e;&#x3e;&#x3e; 14) | (el &#x3c;&#x3c; 18)) ^ ((eh &#x3e;&#x3e;&#x3e; 18) | (el &#x3c;&#x3c; 14)) ^ ((eh &#x3c;&#x3c; 23) | (el &#x3e;&#x3e;&#x3e; 9));
    sigma1l = ((el &#x3e;&#x3e;&#x3e; 14) | (eh &#x3c;&#x3c; 18)) ^ ((el &#x3e;&#x3e;&#x3e; 18) | (eh &#x3c;&#x3c; 14)) ^ ((el &#x3c;&#x3c; 23) | (eh &#x3e;&#x3e;&#x3e; 9));
    Ki = glbl.K[i];
    Kih = Ki.high;
    Kil = Ki.low;
    t1l = hl + sigma1l;
    t1h = hh + sigma1h + ((t1l &#x3e;&#x3e;&#x3e; 0) &#x3c; (hl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
    t1l = t1l + chl;
    t1h = t1h + chh + ((t1l &#x3e;&#x3e;&#x3e; 0) &#x3c; (chl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
    t1l = t1l + Kil;
    t1h = t1h + Kih + ((t1l &#x3e;&#x3e;&#x3e; 0) &#x3c; (Kil &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
    t1l = t1l + Wil;
    t1h = t1h + Wih + ((t1l &#x3e;&#x3e;&#x3e; 0) &#x3c; (Wil &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
    t2l = sigma0l + majl;
    t2h = sigma0h + majh + ((t2l &#x3e;&#x3e;&#x3e; 0) &#x3c; (sigma0l &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = (dl + t1l) | 0;
    eh = (dh + t1h + ((el &#x3e;&#x3e;&#x3e; 0) &#x3c; (dl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0)) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = (t1l + t2l) | 0;
    ah = (t1h + t2h + ((al &#x3e;&#x3e;&#x3e; 0) &#x3c; (t1l &#x3e;&#x3e;&#x3e; 0) ? 1 : 0)) | 0;
  }
  H0l = H0.low = H0l + al;
  H0.high = H0h + ah + ((H0l &#x3e;&#x3e;&#x3e; 0) &#x3c; (al &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
  H1l = H1.low = H1l + bl;
  H1.high = H1h + bh + ((H1l &#x3e;&#x3e;&#x3e; 0) &#x3c; (bl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
  H2l = H2.low = H2l + cl;
  H2.high = H2h + ch + ((H2l &#x3e;&#x3e;&#x3e; 0) &#x3c; (cl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
  H3l = H3.low = H3l + dl;
  H3.high = H3h + dh + ((H3l &#x3e;&#x3e;&#x3e; 0) &#x3c; (dl &#x3e;&#x3e;&#x3e; 0) ? 1 : 0);
  H4l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype._doReset" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  return this._hash = glbl.I.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.clone" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA512();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.constructor" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA512() {
  return SHA512.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.SHA512.klass.prototype.copy_to" id="apidoc.element.kbpgp.hash.SHA512.klass.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.hash.SHA512.klass.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  SHA512.__super__.copy_to.call(this, obj);
  return obj._hash = this._hash.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hash.streamers" id="apidoc.module.kbpgp.hash.streamers">module kbpgp.hash.streamers</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.MD5" id="apidoc.element.kbpgp.hash.streamers.MD5">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>MD5
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MD5 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.RIPEMD160" id="apidoc.element.kbpgp.hash.streamers.RIPEMD160">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>RIPEMD160
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RIPEMD160 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.SHA1" id="apidoc.element.kbpgp.hash.streamers.SHA1">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA1 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.SHA224" id="apidoc.element.kbpgp.hash.streamers.SHA224">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA224
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA224 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.SHA256" id="apidoc.element.kbpgp.hash.streamers.SHA256">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA256
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA256 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  S2K = (function() {
S2K.prototype._count = function(c, bias) {
  return (16 + (c &#x26; 15)) &#x3c;&#x3c; ((c &#x3e;&#x3e; 4) + bias);
};

function S2K() {
  this.hash = SHA256;
  this.streamer = streamers.<span class="apidocCodeKeywordSpan">SHA256</span>();
}

S2K.prototype.set_hash_algorithm = function(which) {
  if ((this.hash = alloc(which)) != null) {
    return this.streamer = streamers[this.hash.algname]();
  } else {
    console.warn(&#x22;No such hash: &#x22; + which + &#x22;; defaulting to SHA-256&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.SHA384" id="apidoc.element.kbpgp.hash.streamers.SHA384">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA384
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA384 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hash.streamers.SHA512" id="apidoc.element.kbpgp.hash.streamers.SHA512">
        function <span class="apidocSignatureSpan">kbpgp.hash.streamers.</span>SHA512
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SHA512 = function () {
  var obj, ret;
  obj = new klass;
  ret = function(buf) {
    return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();
  };
  ret.update = function(buf) {
    if (buf != null) {
      obj.update(WordArray.from_buffer(buf));
    }
    return this;
  };
  return decorate(ret, klass, name, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signer.prototype._run_hash = function(cb) {
  var err;
  err = null;
  if (this.hash_streamer != null) {

  } else if (this.data != null) {
    this.hash_streamer = streamers.<span class="apidocCodeKeywordSpan">SHA512</span>();
    this.hash_streamer.update(this.data);
  } else {
    err = new Error(&#x22;Need either a hasher or data&#x22;);
  }
  return cb(err);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.hilev" id="apidoc.module.kbpgp.hilev">module kbpgp.hilev</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.hilev.SignatureEngine" id="apidoc.element.kbpgp.hilev.SignatureEngine">
        function <span class="apidocSignatureSpan">kbpgp.hilev.</span>SignatureEngine
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hilev.box" id="apidoc.element.kbpgp.hilev.box">
        function <span class="apidocSignatureSpan">kbpgp.hilev.</span>box
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.hilev.unbox" id="apidoc.element.kbpgp.hilev.unbox">
        function <span class="apidocSignatureSpan">kbpgp.hilev.</span>unbox
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (_arg, cb) {
  var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, now, proc, raw, strict, warnings, ___iced_passed_deferral
, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg
.data, strict = _arg.strict, now = _arg.now;
  literals = null;
  err = msg = warnings = esk = null;
  if (armored != null) {
    _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];
  } else if (raw != null) {
    msg_type || (msg_type = C.message_types.generic);
    msg = {
      body: raw,
      type: msg_type
    };
  } else {
    err = new Error(&#x22;No input to do_message; need either &#x27;armored&#x27; or &#x27;raw&#x27; input&#x22;);
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        if (strict == null) {
          strict = true;
        }
        proc = new Message({
          keyfetch: keyfetch,
          data_fn: data_fn,
          data: data,
          strict: strict,
          now: now
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;
          });
          proc.parse_and_process(msg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 409
          }));
          __iced_deferrals._fulfill();
        })(function() {
          warnings = proc.warnings;
          return __iced_k(esk = proc.encryption_subkey);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals, warnings, esk);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kb" id="apidoc.module.kbpgp.kb">module kbpgp.kb</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager" id="apidoc.element.kbpgp.kb.EncKeyManager">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>EncKeyManager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncKeyManager() {
  return EncKeyManager.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager" id="apidoc.element.kbpgp.kb.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  this.key = _arg.key, this.server_half = _arg.server_half;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.box" id="apidoc.element.kbpgp.kb.box">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>box
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (_arg, cb) {
  var anonymous, armored, encrypt_for, esc, msg, packed, packet, sealed, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, anonymous = _arg.anonymous;
  esc = make_esc(cb, &#x22;box&#x22;);
  msg = bufferify(msg);
  (function(_this) {
    return (function(__iced_k) {
      if (encrypt_for != null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;
          });
          Encryption.box({
            sign_with: sign_with,
            encrypt_for: encrypt_for,
            plaintext: msg,
            anonymous: anonymous
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return packet = arguments[0];
              };
            })(),
            lineno: 199
          })));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;
          });
          Signature.box({
            km: sign_with,
            payload: msg
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return packet = arguments[0];
              };
            })(),
            lineno: 201
          })));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      packed = packet.frame_packet();
      sealed = encode.seal({
        obj: packed,
        dohash: false
      });
      armored = sealed.toString(&#x27;base64&#x27;);
      return cb(null, armored, sealed);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.decode_sig" id="apidoc.element.kbpgp.kb.decode_sig">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>decode_sig
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode_sig = function (_arg) {
  var armored, decoded;
  armored = _arg.armored;
  decoded = {
    body: new Buffer(armored, &#x27;base64&#x27;),
    type: C.message_types.generic,
    payload: armored
  };
  return [null, decoded];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.get_sig_body" id="apidoc.element.kbpgp.kb.get_sig_body">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>get_sig_body
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_sig_body = function (_arg) {
  var armored, decoded, err, _ref2;
  armored = _arg.armored;
  _ref2 = decode_sig({
    armored: armored
  }), err = _ref2[0], decoded = _ref2[1];
  return [err, decoded != null ? decoded.body : void 0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.unbox" id="apidoc.element.kbpgp.kb.unbox">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>unbox
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (_arg, cb) {
  var armored, binary, encrypt_for, esc, packet, rawobj, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, binary = _arg.binary, rawobj = _arg.rawobj, encrypt_for = _arg.encrypt_for;
  esc = make_esc(cb, &#x22;unbox&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;
      });
      asyncify(unbox_decode({
        armored: armored,
        binary: binary,
        rawobj: rawobj
      }), esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            packet = arguments[0];
            return binary = arguments[1];
          };
        })(),
        lineno: 181
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;
        });
        packet.unbox({
          encrypt_for: encrypt_for
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return res = arguments[0];
            };
          })(),
          lineno: 182
        })));
        __iced_deferrals._fulfill();
      })(function() {
        if (res.keypair != null) {
          res.km = new KeyManager({
            key: res.keypair
          });
        }
        if (res.sender_keypair != null) {
          res.sender_km = new KeyManager({
            key: res.sender_keypair
          });
        }
        if (res.receiver_keypair != null) {
          res.receiver_km = new KeyManager({
            key: res.receiver_keypair
          });
        }
        return cb(null, res, binary);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.unbox_decode" id="apidoc.element.kbpgp.kb.unbox_decode">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>unbox_decode
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox_decode = function (_arg) {
  var armored, binary, e, err, rawobj, ret, _ref2;
  armored = _arg.armored, binary = _arg.binary, rawobj = _arg.rawobj;
  err = ret = null;
  if ((armored == null) &#x26;&#x26; (rawobj == null) &#x26;&#x26; (binary == null)) {
    err = new Error(&#x22;need either &#x27;armored&#x27; or &#x27;binary&#x27; or &#x27;rawobj&#x27;&#x22;);
    return [err, null];
  }
  if (armored != null) {
    binary = new Buffer(armored, &#x27;base64&#x27;);
  }
  if (binary != null) {
    try {
      rawobj = encode.unseal(binary);
    } catch (_error) {
      e = _error;
      return [e, null];
    }
  }
  _ref2 = alloc(rawobj), err = _ref2[0], ret = _ref2[1];
  return [err, ret, binary];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kb.EncKeyManager" id="apidoc.module.kbpgp.kb.EncKeyManager">module kbpgp.kb.EncKeyManager</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.EncKeyManager" id="apidoc.element.kbpgp.kb.EncKeyManager.EncKeyManager">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>EncKeyManager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncKeyManager() {
  return EncKeyManager.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.generate" id="apidoc.element.kbpgp.kb.EncKeyManager.generate">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>generate
        <span class="apidocSignatureSpan">(params, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (params, cb) {
  params.algo = DH;
  params.klass = EncKeyManager;
  return KeyManager.generate(params, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.import_private" id="apidoc.element.kbpgp.kb.EncKeyManager.import_private">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>import_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_private = function (_arg, cb) {
  var err, hex, km, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hex = _arg.hex, raw = _arg.raw;
  err = ret = null;
  if (hex != null) {
    raw = new Buffer(hex, &#x27;hex&#x27;);
  }
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;,
        funcname: &#x22;EncKeyManager.import_private&#x22;
      });
      EncKeyManager.generate({
        seed: raw
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return km = arguments[1];
          };
        })(),
        lineno: 141
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, km);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.import_public" id="apidoc.element.kbpgp.kb.EncKeyManager.import_public">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.</span>import_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_public = function (_arg, cb) {
  var err, hex, key, raw, ret, _ref2;
  hex = _arg.hex, raw = _arg.raw;
  err = ret = null;
  if (hex != null) {
    raw = new Buffer(hex, &#x27;hex&#x27;);
  }
  _ref2 = DH.parse_kb(raw), err = _ref2[0], key = _ref2[1];
  if (err == null) {
    ret = new EncKeyManager({
      key: key
    });
  }
  return cb(err, ret);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kb.EncKeyManager.prototype" id="apidoc.module.kbpgp.kb.EncKeyManager.prototype">module kbpgp.kb.EncKeyManager.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_decrypt" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_decrypt">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_decrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_decrypt = function () {
  var _ref2;
  return ((_ref2 = this.key) != null ? _ref2.priv : void 0) != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.can_sign()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_decrypt</span>()) {
    return false;
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_encrypt" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_encrypt">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_encrypt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_encrypt = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_sign" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_verify" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.can_verify">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>can_verify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_verify = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.constructor" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EncKeyManager() {
  return EncKeyManager.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.get_mask" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.get_mask">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>get_mask
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_mask = function () {
  return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.EncKeyManager.prototype.make_sig_eng" id="apidoc.element.kbpgp.kb.EncKeyManager.prototype.make_sig_eng">
        function <span class="apidocSignatureSpan">kbpgp.kb.EncKeyManager.prototype.</span>make_sig_eng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_sig_eng = function () {
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kb.KeyManager" id="apidoc.module.kbpgp.kb.KeyManager">module kbpgp.kb.KeyManager</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.KeyManager" id="apidoc.element.kbpgp.kb.KeyManager.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.kb.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  this.key = _arg.key, this.server_half = _arg.server_half;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.generate" id="apidoc.element.kbpgp.kb.KeyManager.generate">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>generate
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (_arg, cb) {
  var algo, err, key, klass, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  algo = _arg.algo, seed = _arg.seed, split = _arg.split, server_half = _arg.server_half, klass = _arg.klass;
  algo || (algo = EdDSA);
  klass || (klass = KeyManager);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;,
        funcname: &#x22;KeyManager.generate&#x22;
      });
      algo.generate({
        split: split,
        seed: seed,
        server_half: server_half
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            key = arguments[1];
            return server_half = arguments[2];
          };
        })(),
        lineno: 30
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, new klass({
        key: key,
        server_half: server_half
      }));
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.import_private" id="apidoc.element.kbpgp.kb.KeyManager.import_private">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>import_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_private = function (_arg, cb) {
  var err, hex, key, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hex = _arg.hex, raw = _arg.raw;
  err = ret = null;
  if (hex != null) {
    raw = new Buffer(hex, &#x27;hex&#x27;);
  }
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;,
        funcname: &#x22;KeyManager.import_private&#x22;
      });
      EdDSA.import_private({
        raw: raw
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return key = arguments[1];
          };
        })(),
        lineno: 65
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if (err == null) {
        ret = new KeyManager({
          key: key
        });
      }
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.import_public" id="apidoc.element.kbpgp.kb.KeyManager.import_public">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.</span>import_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_public = function (_arg, cb) {
  var err, hex, key, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref2;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  hex = _arg.hex, raw = _arg.raw;
  err = ret = null;
  if (hex != null) {
    raw = new Buffer(hex, &#x27;hex&#x27;);
  }
  _ref2 = EdDSA.parse_kb(raw), err = _ref2[0], key = _ref2[1];
  (function(_this) {
    return (function(__iced_k) {
      if (err != null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;,
            funcname: &#x22;KeyManager.import_public&#x22;
          });
          EncKeyManager.import_public({
            raw: raw
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return ret = arguments[1];
              };
            })(),
            lineno: 77
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k(ret = new KeyManager({
          key: key
        }));
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kb.KeyManager.prototype" id="apidoc.module.kbpgp.kb.KeyManager.prototype">module kbpgp.kb.KeyManager.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.can_sign" id="apidoc.element.kbpgp.kb.KeyManager.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  var _ref2;
  return (_ref2 = this.key) != null ? _ref2.can_sign() : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.can_verify" id="apidoc.element.kbpgp.kb.KeyManager.prototype.can_verify">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>can_verify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_verify = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.check_public_eq" id="apidoc.element.kbpgp.kb.KeyManager.prototype.check_public_eq">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>check_public_eq
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_public_eq = function (km2) {
  return this.eq(km2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.constructor" id="apidoc.element.kbpgp.kb.KeyManager.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  this.key = _arg.key, this.server_half = _arg.server_half;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.eq" id="apidoc.element.kbpgp.kb.KeyManager.prototype.eq">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>eq
        <span class="apidocSignatureSpan">(km2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function (km2) {
  return this.key.eq(km2.key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };
  })(this));
};

Engine.prototype.check_eq = function(eng2) {
  var err, i, key, _i, _len, _ref5;
  err = null;
  if (!this.primary.key.<span class="apidocCodeKeywordSpan">eq</span>(eng2.primary.key)) {
    err = new Error(&#x22;Primary keys don&#x27;t match&#x22;);
  } else if (this.subkeys.length !== eng2.subkeys.length) {
    err = new Error(&#x22;different # of subkeys&#x22;);
  } else {
    _ref5 = this.subkeys;
    for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
      key = _ref5[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_private" id="apidoc.element.kbpgp.kb.KeyManager.prototype.export_private">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_private
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_private = function (_arg, cb) {
  var asp, err, p3skb, passphrase, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  asp = _arg.asp, p3skb = _arg.p3skb, passphrase = _arg.passphrase;
  err = res = null;
  (function(_this) {
    return (function(__iced_k) {
      if (p3skb) {
        return __iced_k(err = new Error(&#x22;No support yet for P3SKB encrypted secret key exports&#x22;));
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced&#x22;,
            funcname: &#x22;KeyManager.export_private&#x22;
          });
          _this.key.export_secret_key_kb({}, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return res = arguments[1];
              };
            })(),
            lineno: 99
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, res);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_public" id="apidoc.element.kbpgp.kb.KeyManager.prototype.export_public">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_public = function (_arg, cb) {
  var asp, regen, ret;
  asp = _arg.asp, regen = _arg.regen;
  ret = this.key.ekid().toString(&#x27;hex&#x27;);
  return cb(null, ret);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.export_server_half" id="apidoc.element.kbpgp.kb.KeyManager.prototype.export_server_half">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>export_server_half
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_server_half = function () {
  var _ref2;
  return (_ref2 = this.server_half) != null ? _ref2.toString(&#x27;hex&#x27;) : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.fetch" id="apidoc.element.kbpgp.kb.KeyManager.prototype.fetch">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>fetch
        <span class="apidocSignatureSpan">(key_ids, flags, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (key_ids, flags, cb) {
  var err, key, mask, s;
  s = this.key.ekid().toString(&#x27;hex&#x27;);
  key = null;
  mask = this.get_mask();
  if ((__indexOf.call(key_ids, s) &#x3e;= 0) &#x26;&#x26; (flags &#x26; mask) === flags) {
    key = this.key;
  } else {
    err = new Error(&#x22;Key not found&#x22;);
  }
  return cb(err, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    obj.userid.most_recent_sig = obj.pair[0];
    ret.push(obj.userid);
  }
  return ret;
};

KeyManager.prototype.fetch = function(key_ids, flags, cb) {
  return this.pgp.<span class="apidocCodeKeywordSpan">fetch</span>(key_ids, flags, cb);
};

KeyManager.prototype.find_pgp_key = function(key_id) {
  return this.pgp.find_key(key_id);
};

KeyManager.prototype.find_pgp_key_material = function(key_id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_ekid" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_ekid">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_ekid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_ekid = function () {
  return this.get_keypair().ekid();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_pgp_fingerprint_str = function() {
  var _ref5;
  return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString(&#x27;hex&#x27;) : void 0;
};

KeyManager.prototype.get_ekid = function() {
  return this.pgp.<span class="apidocCodeKeywordSpan">get_ekid</span>();
};

KeyManager.prototype.clear_pgp_internal_sigs = function() {
  return this.pgp.clear_psc();
};

KeyManager.prototype.get_all_pgp_key_ids = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_fp2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2 = function () {
  return this.get_ekid();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager.prototype.get_fp2 = function() {
  return this.get_pgp_fingerprint();
};

KeyManager.prototype.get_fp2_formatted = function(opts) {
  var p;
  if ((p = this.<span class="apidocCodeKeywordSpan">get_fp2</span>()) != null) {
    return format_pgp_fingerprint_2(p, opts);
  } else {
    return null;
  }
};

KeyManager.prototype.get_type = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2_formatted" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_fp2_formatted">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_fp2_formatted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fp2_formatted = function () {
  return base64u.encode(this.get_fp2());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_keypair" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_keypair">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_keypair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_keypair = function () {
  return this.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_mask" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_mask">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_mask
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_mask = function () {
  return C.key_flags.sign_data | C.key_flags.certify_keys | C.key_flags.auth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_primary_keypair" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_primary_keypair">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_primary_keypair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_primary_keypair = function () {
  return this.key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.get_type" id="apidoc.element.kbpgp.kb.KeyManager.prototype.get_type">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>get_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_type = function () {
  return &#x22;kb&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.hash = function() {
  return SHA256(this.serialize());
};

BaseKeyPair.prototype.ekid = function() {
  return Buffer.concat([new Buffer([K.kid.version, this.<span class="apidocCodeKeywordSpan">get_type</span>()]), this.hash(), new
 Buffer([K.kid.trailer])]);
};

BaseKeyPair.prototype.can_sign = function() {
  return this.priv != null;
};

BaseKeyPair.prototype.can_decrypt = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kb.KeyManager.prototype.make_sig_eng" id="apidoc.element.kbpgp.kb.KeyManager.prototype.make_sig_eng">
        function <span class="apidocSignatureSpan">kbpgp.kb.KeyManager.prototype.</span>make_sig_eng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_sig_eng = function () {
  return new SignatureEngine({
    km: this
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.keyfetch" id="apidoc.module.kbpgp.keyfetch">module kbpgp.keyfetch</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.keyfetch.KeyFetcher" id="apidoc.element.kbpgp.keyfetch.KeyFetcher">
        function <span class="apidocSignatureSpan">kbpgp.keyfetch.</span>KeyFetcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyFetcher() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.keymanager" id="apidoc.module.kbpgp.keymanager">module kbpgp.keymanager</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.keymanager.KeyManager" id="apidoc.element.kbpgp.keymanager.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.keymanager.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  var signed;
  this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public
, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;
  this.pgp = new PgpEngine({
    primary: this.primary,
    subkeys: this.subkeys,
    userids: this.userids,
    user_attributes: this.user_attributes,
    key_manager: this
  });
  this.engines = [this.pgp];
  this._signed = signed != null ? signed : false;
  this.p3skb = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.keyring" id="apidoc.module.kbpgp.keyring">module kbpgp.keyring</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.keyring.KeyRing" id="apidoc.element.kbpgp.keyring.KeyRing">
        function <span class="apidocSignatureSpan">kbpgp.keyring.</span>KeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.keyring.PgpKeyRing" id="apidoc.element.kbpgp.keyring.PgpKeyRing">
        function <span class="apidocSignatureSpan">kbpgp.keyring.</span>PgpKeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.keywrapper" id="apidoc.module.kbpgp.keywrapper">module kbpgp.keywrapper</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.keywrapper.Lifespan" id="apidoc.element.kbpgp.keywrapper.Lifespan">
        function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Lifespan
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lifespan(_arg) {
  this.generated = _arg.generated, this.expire_in = _arg.expire_in;
  if (this.expire_in === void 0) {
    this.expire_in = C.default_key_expire_in;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.keywrapper.Primary" id="apidoc.element.kbpgp.keywrapper.Primary">
        function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Primary
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Primary(_arg) {
  var flags, key, lifespan, _keybase, _pgp;
  key = _arg.key, lifespan = _arg.lifespan, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase;
  Primary.__super__.constructor.call(this, {
    key: key,
    lifespan: lifespan,
    flags: flags,
    _pgp: _pgp,
    _keybase: _keybase
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.keywrapper.Subkey" id="apidoc.element.kbpgp.keywrapper.Subkey">
        function <span class="apidocSignatureSpan">kbpgp.keywrapper.</span>Subkey
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subkey(_arg) {
  var flags, key, lifespan, _keybase, _pgp;
  key = _arg.key, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase, this.desc = _arg.desc, lifespan = _arg.lifespan
, this.primary = _arg.primary;
  Subkey.__super__.constructor.call(this, {
    key: key,
    lifespan: lifespan,
    flags: flags,
    _pgp: _pgp,
    _keybase: _keybase
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.kmi" id="apidoc.module.kbpgp.kmi">module kbpgp.kmi</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.kmi.KeyManagerInterface" id="apidoc.element.kbpgp.kmi.KeyManagerInterface">
        function <span class="apidocSignatureSpan">kbpgp.kmi.</span>KeyManagerInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManagerInterface() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.kmi.SignatureEngineInterface" id="apidoc.element.kbpgp.kmi.SignatureEngineInterface">
        function <span class="apidocSignatureSpan">kbpgp.kmi.</span>SignatureEngineInterface
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngineInterface(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.main" id="apidoc.module.kbpgp.main">module kbpgp.main</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.main.ASP" id="apidoc.element.kbpgp.main.ASP">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>ASP
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ASP(_arg) {
  var canceler, delay, progress_hook;
  progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;
  this._delay = delay != null ? delay : 2;
  this._canceler = canceler || (new Canceler());
  this._progress_hook = progress_hook || (function(obj) {});
  this._section = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.Buffer" id="apidoc.element.kbpgp.main.Buffer">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === &#x27;number&#x27;) {
    if (typeof encodingOrOffset === &#x27;string&#x27;) {
      throw new Error(
        &#x27;If encoding is specified then the first argument must be a string&#x27;
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.Burner" id="apidoc.element.kbpgp.main.Burner">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>Burner
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Burner(_arg) {
  var asp, encrypt_for, encryption_key, sign_with, signing_key;
  this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key =
_arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;
  Burner.__super__.constructor.call(this, {
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp
  });
  this.packets = [];
  this.opts || (this.opts = {});
  this.signed_payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.KeyFetcher" id="apidoc.element.kbpgp.main.KeyFetcher">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyFetcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyFetcher() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.KeyManager" id="apidoc.element.kbpgp.main.KeyManager">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyManager
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyManager(_arg) {
  var signed;
  this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public
, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;
  this.pgp = new PgpEngine({
    primary: this.primary,
    subkeys: this.subkeys,
    userids: this.userids,
    user_attributes: this.user_attributes,
    key_manager: this
  });
  this.engines = [this.pgp];
  this._signed = signed != null ? signed : false;
  this.p3skb = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.KeyRing" id="apidoc.element.kbpgp.main.KeyRing">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>KeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.PgpKeyRing" id="apidoc.element.kbpgp.main.PgpKeyRing">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>PgpKeyRing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PgpKeyRing() {
  this._keys = {};
  this._kms = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.SignatureEngine" id="apidoc.element.kbpgp.main.SignatureEngine">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>SignatureEngine
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.box" id="apidoc.element.kbpgp.main.box">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>box
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.burn" id="apidoc.element.kbpgp.main.burn">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>burn
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">burn = function (_arg, cb) {
  var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral,
__iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key
, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;
  if ((msg != null) &#x26;&#x26; (literals == null)) {
    literals = make_simple_literals(msg);
  }
  b = new Burner({
    literals: literals,
    sign_with: sign_with,
    encrypt_for: encrypt_for,
    signing_key: signing_key,
    encryption_key: encryption_key,
    asp: asp,
    opts: opts
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
        funcname: &#x22;burn&#x22;
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return raw = arguments[1];
          };
        })(),
        lineno: 247
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      if ((typeof raw !== &#x22;undefined&#x22; &#x26;&#x26; raw !== null) &#x26;&#x26; (typeof err === &#x22;undefined&#x22; || err === null)) {
        aout = encode(C.message_types.generic, raw);
      }
      return cb(err, aout, raw);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;burn&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">burn</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return raw = arguments[1];
      };
    })(),
    lineno: 247
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.clearsign" id="apidoc.element.kbpgp.main.clearsign">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>clearsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearsign = function (_arg, cb) {
  var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, signing_key = _arg.signing_key;
  b = new ClearSigner({
    msg: msg,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      b.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 215
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      b.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.detachsign" id="apidoc.element.kbpgp.main.detachsign">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>detachsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachsign = function (_arg, cb) {
  var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;
  s = new Signer({
    data: data,
    hash_streamer: hash_streamer,
    signing_key: signing_key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced&#x22;,
        funcname: &#x22;sign&#x22;
      });
      s.run(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            encoded = arguments[1];
            return signature = arguments[2];
          };
        })(),
        lineno: 139
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      s.scrub();
      return cb(err, encoded, signature);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.make_simple_literals" id="apidoc.element.kbpgp.main.make_simple_literals">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>make_simple_literals
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_simple_literals = function (msg) {
  return [
    new Literal({
      data: new Buffer(msg),
      format: C.literal_formats.utf8,
      date: unix_time()
    })
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.main.unbox" id="apidoc.element.kbpgp.main.unbox">
        function <span class="apidocSignatureSpan">kbpgp.main.</span>unbox
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbox = function (_arg, cb) {
  var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, now, proc, raw, strict, warnings, ___iced_passed_deferral
, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg
.data, strict = _arg.strict, now = _arg.now;
  literals = null;
  err = msg = warnings = esk = null;
  if (armored != null) {
    _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];
  } else if (raw != null) {
    msg_type || (msg_type = C.message_types.generic);
    msg = {
      body: raw,
      type: msg_type
    };
  } else {
    err = new Error(&#x22;No input to do_message; need either &#x27;armored&#x27; or &#x27;raw&#x27; input&#x22;);
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        if (strict == null) {
          strict = true;
        }
        proc = new Message({
          keyfetch: keyfetch,
          data_fn: data_fn,
          data: data,
          strict: strict,
          now: now
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;
          });
          proc.parse_and_process(msg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 409
          }));
          __iced_deferrals._fulfill();
        })(function() {
          warnings = proc.warnings;
          return __iced_k(esk = proc.encryption_subkey);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals, warnings, esk);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ocfb" id="apidoc.module.kbpgp.ocfb">module kbpgp.ocfb</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ocfb.Decryptor" id="apidoc.element.kbpgp.ocfb.Decryptor">
        function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>Decryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decryptor(_arg) {
  var asp, block_cipher_class, cipher, key, prefixrandom, resync;
  block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync =
_arg.resync, this.ciphertext = _arg.ciphertext, asp = _arg.asp;
  Decryptor.__super__.constructor.call(this, {
    block_cipher_class: block_cipher_class,
    key: key,
    cipher: cipher,
    resync: resync,
    asp: asp
  });
  this._init();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ocfb.decrypt" id="apidoc.element.kbpgp.ocfb.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>decrypt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (_arg, cb) {
  var asp, block_cipher_class, cipher, ciphertext, eng, err, key, pt, resync, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, resync = _arg.resync, ciphertext = _arg.ciphertext
, asp = _arg.asp;
  eng = new Decryptor({
    block_cipher_class: block_cipher_class,
    key: key,
    cipher: cipher,
    resync: resync,
    ciphertext: ciphertext,
    asp: asp
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced&#x22;
      });
      eng.check(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 267
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (typeof err === &#x22;undefined&#x22; || err === null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced&#x22;
            });
            eng.dec(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return pt = arguments[1];
                };
              })(),
              lineno: 268
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, pt);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ocfb.encrypt" id="apidoc.element.kbpgp.ocfb.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.ocfb.</span>encrypt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (_arg, cb) {
  var asp, block_cipher_class, cipher, eng, key, plaintext, prefixrandom, resync;
  block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync =
_arg.resync, plaintext = _arg.plaintext, asp = _arg.asp;
  eng = new Encryptor({
    block_cipher_class: block_cipher_class,
    key: key,
    cipher: cipher,
    prefixrandom: prefixrandom,
    resync: resync,
    asp: asp
  });
  return eng.enc(plaintext, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts" id="apidoc.module.kbpgp.opkts">module kbpgp.opkts</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial" id="apidoc.element.kbpgp.opkts.KeyMaterial">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>KeyMaterial
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyMaterial(_arg) {
  this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg
.opts, this.flags = _arg.flags;
  this.opts || (this.opts = {});
  this.flags || (this.flags = 0);
  this._is_duplicate_primary = false;
  KeyMaterial.__super__.constructor.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

PgpEngine.prototype.key = function(k) {
  return k._pgp;
};

PgpEngine.prototype._v_allocate_key_packet = function(key, opts) {
  if (key._pgp == null) {
    return key._pgp = new opkts.<span class="apidocCodeKeywordSpan">KeyMaterial</span>({
      key: key.key,
      timestamp: key.lifespan.generated,
      flags: key.flags,
      opts: opts
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature" id="apidoc.element.kbpgp.opkts.Signature">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>Signature
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(_arg) {
  this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class
 = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets
, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version
 = _arg.version;
  if (this.hasher == null) {
    this.hasher = SHA512;
  }
  if (this.hashed_subpackets == null) {
    this.hashed_subpackets = [];
  }
  if (this.unhashed_subpackets == null) {
    this.unhashed_subpackets = [];
  }
  this.subpacket_index = this._make_subpacket_index();
  this._framed_output = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID" id="apidoc.element.kbpgp.opkts.UserID">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>UserID
        <span class="apidocSignatureSpan">(userid, components)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserID(userid, components) {
  this.components = components != null ? components : null;
  this.userid = bufferify(userid);
  if (this.compontents == null) {
    this._parse();
  }
  UserID.__super__.constructor.call(this);
  this._time_primary_pair = null;
  this.primary = false;
  this.most_recent_sig = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return (function(__iced_k) {
if ((userids != null) &#x26;&#x26; Array.isArray(userids)) {
  return __iced_k(userids = (function() {
    var _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = userids.length; _j &#x3c; _len1; _j++) {
      u = userids[_j];
      _results.push(new opkts.<span class="apidocCodeKeywordSpan">UserID</span>(u));
    }
    return _results;
  })());
} else {
  err = new Error(&#x22;Need either &#x27;userid&#x27; or &#x27;userids&#x27; specified as an array&#x22;);
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.KeyMaterial" id="apidoc.module.kbpgp.opkts.KeyMaterial">module kbpgp.opkts.KeyMaterial</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.KeyMaterial" id="apidoc.element.kbpgp.opkts.KeyMaterial.KeyMaterial">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>KeyMaterial
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyMaterial(_arg) {
  this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg
.opts, this.flags = _arg.flags;
  this.opts || (this.opts = {});
  this.flags || (this.flags = 0);
  this._is_duplicate_primary = false;
  KeyMaterial.__super__.constructor.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

PgpEngine.prototype.key = function(k) {
  return k._pgp;
};

PgpEngine.prototype._v_allocate_key_packet = function(key, opts) {
  if (key._pgp == null) {
    return key._pgp = new opkts.<span class="apidocCodeKeywordSpan">KeyMaterial</span>({
      key: key.key,
      timestamp: key.lifespan.generated,
      flags: key.flags,
      opts: opts
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.parse_private_key" id="apidoc.element.kbpgp.opkts.KeyMaterial.parse_private_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.</span>parse_private_key
        <span class="apidocSignatureSpan">(slice, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_private_key = function (slice, opts) {
  return (new Parser(slice)).parse_private_key(opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.parse_public_key" id="apidoc.element.kbpgp.opkts.KeyMaterial.parse_public_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.</span>parse_public_key
        <span class="apidocSignatureSpan">(slice, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_public_key = function (slice, opts) {
  return (new Parser(slice)).parse_public_key(opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.KeyMaterial.prototype" id="apidoc.module.kbpgp.opkts.KeyMaterial.prototype">module kbpgp.opkts.KeyMaterial.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_primary" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_primary">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_get_expire_time_on_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_get_expire_time_on_primary = function () {
  var expire_in, key_generated, list, packetsig, ret, sig, sig_generated, table, uid, uid_expire_in, uid_winner, winner, _i, _len
;
  table = this.get_psc().lookup.self_sigs_by_uid;
  winner = null;
  key_generated = this.timestamp;
  for (uid in table) {
    list = table[uid];
    uid_winner = null;
    for (_i = 0, _len = list.length; _i &#x3c; _len; _i++) {
      packetsig = list[_i];
      if (!((sig = packetsig.sig) != null)) {
        continue;
      }
      expire_in = sig.get_key_expires();
      sig_generated = sig.when_generated();
      if ((uid_winner == null) || uid_winner.sig_generated &#x3c; sig_generated) {
        uid_winner = {
          expire_in: expire_in,
          sig_generated: sig_generated
        };
      }
    }
    if (uid_winner != null) {
      uid_expire_in = uid_winner.expire_in || 0;
      if ((winner == null) || (uid_expire_in === 0) || ((0 &#x3c; winner &#x26;&#x26; winner &#x3c; uid_expire_in))) {
        winner = uid_expire_in;
      }
    }
  }
  ret = {
    generated: this.timestamp,
    expire_at: null,
    expire_in: null
  };
  if (winner) {
    ret.expire_at = this.timestamp + winner;
    ret.expire_in = winner;
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_subkey" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._get_expire_time_on_subkey">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_get_expire_time_on_subkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_get_expire_time_on_subkey = function () {
  var expire_at, expire_in, generated, list, packetsig, sig, winner, _i, _len;
  list = this.get_psc().lookup.subkey_binding;
  if (!(list != null ? list.length : void 0)) {
    return null;
  }
  winner = null;
  for (_i = 0, _len = list.length; _i &#x3c; _len; _i++) {
    packetsig = list[_i];
    if (!((packetsig.sig != null) &#x26;&#x26; packetsig.is_down())) {
      continue;
    }
    sig = packetsig.sig;
    expire_in = sig.get_key_expires();
    generated = this.timestamp;
    if (expire_in &#x26;&#x26; generated) {
      expire_at = generated + expire_in;
      if ((winner == null) || ((winner.expire_at != null) &#x26;&#x26; (winner.expire_at &#x3c; expire_at))) {
        winner = {
          expire_at: expire_at,
          generated: generated,
          expire_in: expire_in
        };
      }
    } else if (((expire_in != null) &#x26;&#x26; expire_in === 0) || (expire_in == null)) {
      winner = {
        generated: generated,
        expire_in: null,
        expire_at: null
      };
    }
  }
  if (winner == null) {
    winner = {
      generated: 0,
      expire_at: null,
      expire_in: null
    };
  }
  return winner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._self_sign_key" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._self_sign_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_self_sign_key
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_self_sign_key = function (_arg, cb) {
  var err, hsp, lifespan, payload, primary, ps, raw_payload, sig, type, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  userid = _arg.userid, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload, primary = _arg.primary;
  payload = Buffer.concat([this.to_signature_payload(), userid.to_signature_payload()]);
  type = C.sig_types.positive;
  hsp = [new S.CreationTime(lifespan.generated), new S.KeyFlags([this.flags]), new S.PreferredSymmetricAlgorithms([C.symmetric_key_algorithms
.AES256, C.symmetric_key_algorithms.AES128]), new S.PreferredHashAlgorithms([C.hash_algorithms.SHA512, C.hash_algorithms.SHA256]),
new S.Features([C.features.modification_detection]), new S.KeyServerPreferences([C.key_server_preferences.no_modify]), new S.PreferredCompressionAlgorithms
([C.compression.zlib, C.compression.zip])];
  if (primary) {
    hsp.push(new S.PrimaryUserId(1));
  }
  if (lifespan.expire_in) {
    hsp.push(new S.KeyExpirationTime(lifespan.expire_in));
  }
  sig = new Signature({
    type: type,
    key: this.key,
    hashed_subpackets: hsp,
    unhashed_subpackets: [new S.Issuer(this.get_key_id())]
  });
  (function(_this) {
    return (function(__iced_k) {
      if (raw_payload) {
        return __iced_k(sig = payload);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
            funcname: &#x22;KeyMaterial._self_sign_key&#x22;
          });
          sig.write(payload, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 237
          }));
          __iced_deferrals._fulfill();
        })(function() {
          ps = new packetsigs.SelfSig({
            userid: userid,
            type: type,
            sig: sig,
            options: _this.flags
          });
          userid.push_sig(ps);
          return __iced_k(_this.push_sig(ps));
        });
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, sig);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_primary_with_subkey" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_primary_with_subkey">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_primary_with_subkey
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sign_primary_with_subkey = function (_arg, cb) {
  var err, lifespan, payload, primary, sig, sig_unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  primary = _arg.primary, lifespan = _arg.lifespan;
  payload = Buffer.concat([primary.to_signature_payload(), this.to_signature_payload()]);
  sig = new Signature({
    type: C.sig_types.primary_binding,
    key: this.key,
    hashed_subpackets: [new S.CreationTime(lifespan.generated)],
    unhashed_subpackets: [new S.Issuer(this.get_key_id())]
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
        funcname: &#x22;KeyMaterial._sign_primary_with_subkey&#x22;
      });
      sig.write_unframed(payload, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return sig_unframed = arguments[1];
          };
        })(),
        lineno: 288
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, sig_unframed);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_subkey
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sign_subkey = function (_arg, cb) {
  var SKB, err, lifespan, primary_binding, ps, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  subkey = _arg.subkey, lifespan = _arg.lifespan;
  sig = err = primary_binding = null;
  (function(_this) {
    return (function(__iced_k) {
      if (subkey.can_sign()) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
            funcname: &#x22;KeyMaterial._sign_subkey&#x22;
          });
          subkey._sign_primary_with_subkey({
            primary: _this,
            lifespan: lifespan
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return primary_binding = arguments[1];
              };
            })(),
            lineno: 262
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
              funcname: &#x22;KeyMaterial._sign_subkey&#x22;
            });
            _this._sign_subkey_with_primary({
              subkey: subkey,
              lifespan: lifespan,
              primary_binding: primary_binding
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return sig = arguments[1];
                };
              })(),
              lineno: 264
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (err == null) {
          SKB = packetsigs.SubkeyBinding;
          ps = new SKB({
            primary: _this,
            sig: sig,
            direction: SKB.DOWN
          });
          subkey.push_sig(ps);
        }
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey_with_primary" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._sign_subkey_with_primary">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_sign_subkey_with_primary
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sign_subkey_with_primary = function (_arg, cb) {
  var err, lifespan, payload, primary_binding, sig, subkey, unhashed_subpackets, ___iced_passed_deferral, __iced_deferrals, __iced_k
;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  subkey = _arg.subkey, lifespan = _arg.lifespan, primary_binding = _arg.primary_binding;
  payload = Buffer.concat([this.to_signature_payload(), subkey.to_signature_payload()]);
  unhashed_subpackets = [new S.Issuer(this.get_key_id())];
  if (primary_binding != null) {
    unhashed_subpackets.push(new S.EmbeddedSignature({
      rawsig: primary_binding
    }));
  }
  sig = new Signature({
    type: C.sig_types.subkey_binding,
    key: this.key,
    hashed_subpackets: [new S.CreationTime(lifespan.generated), new S.KeyExpirationTime(lifespan.expire_in), new S.KeyFlags([subkey
.flags])],
    unhashed_subpackets: unhashed_subpackets
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
        funcname: &#x22;KeyMaterial._sign_subkey_with_primary&#x22;
      });
      sig.write(payload, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 312
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, sig);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_dummy" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_dummy">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_dummy
        <span class="apidocSignatureSpan">(bufs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write_dummy = function (bufs) {
  return bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.gnu, 0x2]), new Buffer(&#x22;GNU&#x22;, &#x22;utf8
&#x22;), new Buffer([0x1]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_clear" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_clear">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_private_clear
        <span class="apidocSignatureSpan">(bufs, priv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write_private_clear = function (bufs, priv) {
  return bufs.push(new Buffer([C.s2k_convention.none]), priv, uint_to_buffer(16, calc_checksum(priv)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_enc" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_private_enc">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_private_enc
        <span class="apidocSignatureSpan">(bufs, priv, pp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write_private_enc = function (bufs, priv, pp) {
  var c, ct, iv, ivlen, k, ks, plaintext, salt, sha1hash;
  bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.salt_iter, C.hash_algorithms.SHA256]));
  sha1hash = (new SHA1).bufhash(priv);
  salt = native_rng(8);
  bufs.push(salt);
  c = 96;
  bufs.push(new Buffer([c]));
  ks = AES.keySize;
  k = (new S2K).write(pp, salt, c, ks);
  ivlen = AES.blockSize;
  iv = native_rng(ivlen);
  bufs.push(iv);
  plaintext = Buffer.concat([priv, sha1hash]);
  ct = encrypt({
    block_cipher_class: AES,
    key: k,
    plaintext: plaintext,
    iv: iv
  });
  return bufs.push(ct);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_public" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype._write_public">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>_write_public
        <span class="apidocSignatureSpan">(bufs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write_public = function (bufs) {
  var pub;
  pub = this.key.serialize();
  return bufs.push(new Buffer([C.versions.keymaterial.V4]), uint_to_buffer(32, this.timestamp), new Buffer([this.key.type]), pub
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.add_flags" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.add_flags">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>add_flags
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_flags = function (v) {
  return this.flags |= v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.can_sign" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.can_sign">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>can_sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_sign = function () {
  return this.key.can_sign();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BaseKeyPair.prototype.eq = function(k2) {
  return (this.type === k2.type) &#x26;&#x26; (bufeq_secure(this.serialize(), k2.serialize()));
};

BaseKeyPair.prototype.can_perform = function(ops_mask) {
  if ((ops_mask &#x26; konst.ops.sign) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">can_sign</span>()) {
    return false;
  } else if ((ops_mask &#x26; konst.ops.decrypt) &#x26;&#x26; !this.can_decrypt()) {
    return false;
  } else {
    return true;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.check_not_expired" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.check_not_expired">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>check_not_expired
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_not_expired = function (_arg) {
  var e, err, now, _ref4;
  now = _arg.now;
  err = null;
  if ((e = (_ref4 = this.get_expire_time()) != null ? _ref4.expire_at : void 0) &#x26;&#x26; e &#x3c; now) {
    err = new Error(&#x22;PGP key &#x22; + (this.get_fingerprint().toString(&#x27;hex&#x27;)) + &#x22; expired at &#x22; + e + &#x22; but we checked for time &#x22; + now
);
  }
  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return _results;
};

Engine.prototype.check_not_expired = function(_arg) {
  var err, now, subkey_material;
  subkey_material = _arg.subkey_material, now = _arg.now;
  now || (now = unix_time());
  err = this.key(this.primary).<span class="apidocCodeKeywordSpan">check_not_expired</span>({
    now: now
  });
  if (err == null) {
    err = subkey_material.check_not_expired({
      now: now
    });
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.constructor" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyMaterial(_arg) {
  this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg
.opts, this.flags = _arg.flags;
  this.opts || (this.opts = {});
  this.flags || (this.flags = 0);
  this._is_duplicate_primary = false;
  KeyMaterial.__super__.constructor.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.ekid" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.ekid">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>ekid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ekid = function () {
  return this.key.ekid();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  KeyWrapper = (function() {
function KeyWrapper(_arg) {
  this.key = _arg.key, this.lifespan = _arg.lifespan, this._pgp = _arg._pgp, this._keybase = _arg._keybase, this.flags = _arg.flags
;
}

KeyWrapper.prototype.ekid = function() {
  return this.key.<span class="apidocCodeKeywordSpan">ekid</span>();
};

KeyWrapper.prototype.overwrite_with_omitting_revokes = function(kw2) {
  if (kw2._pgp.is_revoked()) {
    return;
  }
  if (this._pgp.is_revoked() || this.lifespan.expires_earlier_than(kw2.lifespan)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.equal" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.equal">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>equal
        <span class="apidocSignatureSpan">(k2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equal = function (k2) {
  return bufeq_secure(this.ekid(), k2.ekid());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    B = A.clone().concat(r);
    AES.decryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    t.words[1]--;
  }
}
if (A.<span class="apidocCodeKeywordSpan">equal</span>(IV)) {
  P = new WordArray([]);
  for (_k = 0, _len = R.length; _k &#x3c; _len; _k++) {
    r = R[_k];
    P.concat(r);
  }
  return [null, P.to_buffer()];
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.export_framed" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.export_framed">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>export_framed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_framed = function (opts) {
  if (opts == null) {
    opts = {};
  }
  if (opts[&#x22;private&#x22;]) {
    return this.private_framed(opts);
  } else {
    return this.public_framed(opts);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _results.push(k.passphrase = pp);
  }
  return _results;
};

PgpEngine.prototype._export_keys_to_binary = function(opts) {
  var packets, subkey, userid, _i, _j, _len, _len1, _ref5, _ref6;
  packets = [this.key(this.primary).<span class="apidocCodeKeywordSpan">export_framed</span>(opts)];
  _ref5 = this.userids;
  for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
    userid = _ref5[_i];
    packets.push(userid.write(), userid.get_framed_signature_output());
  }
  opts.subkey = true;
  _ref6 = this.subkeys;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.fulfills_flags" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.fulfills_flags">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>fulfills_flags
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fulfills_flags = function (flags) {
  var akf, ret;
  if (this.is_revoked()) {
    return false;
  }
  akf = this.get_all_key_flags();
  ret = ((akf &#x26; flags) === flags) || this.key.fulfills_flags(flags) || (this.is_primary() &#x26;&#x26; (akf === 0) &#x26;&#x26; ((this.key.good_for_flags
() &#x26; flags) === flags));
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  need_priv = false;
}
best = null;
check = (function(_this) {
  return function(k) {
    var km, ok1, ok2, ok3;
    km = _this.key(k);
    ok1 = km.<span class="apidocCodeKeywordSpan">fulfills_flags</span>(flags) || ((k.flags &#x26; flags) === flags);
    ok2 = !need_priv || km.has_private();
    ok3 = !km.is_revoked();
    return ok1 &#x26;&#x26; ok2 &#x26;&#x26; ok3;
  };
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_all_key_flags" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_all_key_flags">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_all_key_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_all_key_flags = function () {
  return this._psc.get_all_key_flags();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_expire_time" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_expire_time">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_expire_time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_expire_time = function () {
  var psc;
  if ((psc = this.get_psc()) == null) {
    return null;
  } else if (this.is_primary()) {
    return this._get_expire_time_on_primary();
  } else {
    return this._get_expire_time_on_subkey();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

KeyManager._wrap_pgp = function(klass, kmp) {
  var _ref5;
  return new klass({
    key: kmp.key,
    lifespan: new Lifespan({
      generated: kmp.timestamp,
      expire_in: (_ref5 = kmp.<span class="apidocCodeKeywordSpan">get_expire_time</span>()) != null ? _ref5.expire_in : void 0
    }),
    _pgp: kmp
  });
};

KeyManager.prototype.merge_all_subkeys_omitting_revokes = function(km2) {
  if ((this.pgp != null) &#x26;&#x26; (km2.pgp != null)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_fingerprint" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_fingerprint">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_fingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_fingerprint = function () {
  var data;
  data = this.public_body();
  return (new SHA1).bufhash(Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, data.length), data]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
var ekey, esc, fingerprint, key_id, payload, pkesk, pkt, pub_k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
esc = make_esc(cb, &#x22;_encrypt_session_key_once&#x22;);
payload = export_key_pgp(this._cipher_algo, this._session_key);
pub_k = encryption_key.key;
fingerprint = encryption_key.<span class="apidocCodeKeywordSpan">get_fingerprint</span>();
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner._encrypt_session_key_once&#x22;
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_key_id" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_key_id">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_key_id = function () {
  return this.get_fingerprint().slice(12, 20);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
esc = make_esc(cb, &#x22;Burner::_sign&#x27;&#x22;);
ops = new OnePassSignature({
  sig_type: C.sig_types.binary_doc,
  hasher: SHA512,
  sig_klass: this.signing_key.get_klass(),
  key_id: this.signing_key.<span class="apidocCodeKeywordSpan">get_key_id</span>(),
  is_final: 1
});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_klass" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_klass">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_klass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_klass = function () {
  return this.key.constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var esc, fp, ops, ops_framed, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
esc = make_esc(cb, &#x22;Burner::_sign&#x27;&#x22;);
ops = new OnePassSignature({
  sig_type: C.sig_types.binary_doc,
  hasher: SHA512,
  sig_klass: this.signing_key.<span class="apidocCodeKeywordSpan">get_klass</span>(),
  key_id: this.signing_key.get_key_id(),
  is_final: 1
});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_short_key_id" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_short_key_id">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_short_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_short_key_id = function () {
  return this.get_key_id().slice(-4).toString(&#x27;hex&#x27;).toUpperCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

PgpEngine.prototype.get_key_id = function() {
  return this.key(this.primary).get_key_id();
};

PgpEngine.prototype.get_short_key_id = function() {
  return this.key(this.primary).<span class="apidocCodeKeywordSpan">get_short_key_id</span>();
};

PgpEngine.prototype.get_fingerprint = function() {
  return this.key(this.primary).get_fingerprint();
};

PgpEngine.prototype.get_ekid = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_user_attributes" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_user_attributes">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_signed_user_attributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_signed_user_attributes = function () {
  return this.get_psc().get_signed_user_attributes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_userids" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_signed_userids">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_signed_userids
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_signed_userids = function () {
  return this.get_psc().get_signed_userids();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_subkey_binding
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_subkey_binding = function () {
  if (this.opts.subkey) {
    return this.get_psc().get_subkey_binding();
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding_signature_output" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.get_subkey_binding_signature_output">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>get_subkey_binding_signature_output
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_subkey_binding_signature_output = function () {
  var _ref4, _ref5;
  return (_ref4 = this.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() : void 0 : void 0
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    userid = _ref5[_i];
    packets.push(userid.write(), userid.get_framed_signature_output());
  }
  opts.subkey = true;
  _ref6 = this.subkeys;
  for (_j = 0, _len1 = _ref6.length; _j &#x3c; _len1; _j++) {
    subkey = _ref6[_j];
    packets.push(this.key(subkey).export_framed(opts), this.key(subkey).<span class="apidocCodeKeywordSpan">get_subkey_binding_signature_output
</span>());
  }
  assert_no_nulls(packets);
  return Buffer.concat(packets);
};

PgpEngine.prototype.export_keys = function(opts) {
  var msg, mt, type;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_locked_private" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_locked_private">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_locked_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_locked_private = function () {
  return this.skm &#x26;&#x26; this.skm.has_private();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_private" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_private">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_private = function () {
  return this.has_unlocked_private() || this.has_locked_private();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Engine.prototype.has_private = function() {
  var k, _i, _len, _ref5;
  _ref5 = this._all_keys();
  for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
    k = _ref5[_i];
    if (this.key(k).<span class="apidocCodeKeywordSpan">has_private</span>()) {
      return true;
    }
  }
  return false;
};

Engine.prototype.sign = function(_arg, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_secret_key_material" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_secret_key_material">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_secret_key_material
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_secret_key_material = function () {
  return this.skm != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return err;
};

Engine.prototype._merge_private_primary = function(eng2) {
  var err;
  err = !this.key(eng2.primary).<span class="apidocCodeKeywordSpan">has_secret_key_material</span>() ? null : this._merge_1_private
(this.primary, eng2.primary) ? null : new Error(&#x22;primary public key doesn&#x27;t match private key&#x22;);
  return err;
};

Engine.prototype._merge_private_subkey = function(k2, i) {
  var ekid, err, k;
  err = !this.key(k2).has_secret_key_material() ? null : (ekid = this.ekid(k2)) == null ? new Error(&#x22;Subkey &#x22; + i + &#
x22; is malformed&#x22;) : (k = this._index[ekid]) == null ? new Error(&#x22;Subkey &#x22; + i + &#x22; wasn&#x27;t found in public
 key&#x22;) : this._merge_1_private(k, k2) ? null : new Error(&#x22;subkey &#x22; + i + &#x22; can&#x27;t be merged&#x22;);
  return err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_unlocked_private" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.has_unlocked_private">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>has_unlocked_private
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has_unlocked_private = function () {
  return this.key.has_private();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_duplicate_primary" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_duplicate_primary">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_duplicate_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_duplicate_primary = function () {
  return this._is_duplicate_primary;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_key_material" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_key_material">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_key_material
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_key_material = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_locked" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_locked">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_locked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_locked = function () {
  return (!this.key.has_private()) &#x26;&#x26; (this.skm != null) &#x26;&#x26; this.skm.is_locked();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Engine.prototype.is_locked = function() {
  var i, k, _i, _len, _ref5;
  _ref5 = this._all_keys();
  for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
    k = _ref5[i];
    if (this.key(k).<span class="apidocCodeKeywordSpan">is_locked</span>()) {
      return true;
    }
  }
  return false;
};

Engine.prototype.has_private = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_preferable_to" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_preferable_to">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_preferable_to
        <span class="apidocSignatureSpan">(k2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_preferable_to = function (k2) {
  var e1, e2, ret;
  e1 = this.get_expire_time();
  e2 = k2.get_expire_time();
  if (e1.expire_at == null) {
    e1.expire_at = Infinity;
  }
  if (e2.expire_at == null) {
    e2.expire_at = Infinity;
  }
  ret = e1.expire_at &#x3e; e2.expire_at ? true : e1.expire_at &#x3c; e2.expire_at ? false : e1.generated &#x3e;= e2.generated ? true : false;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(this);
_ref5 = this.subkeys;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
  k = _ref5[_i];
  if (check(k)) {
    if (best == null) {
      best = k;
    } else if (this.key(k).<span class="apidocCodeKeywordSpan">is_preferable_to</span>(this.key(best))) {
      best = k;
    }
  }
}
if ((best == null) &#x26;&#x26; check(this.primary)) {
  best = this.primary;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_primary" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_primary">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_primary = function () {
  var _ref4;
  return !((_ref4 = this.opts) != null ? _ref4.subkey : void 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_revoked" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_revoked">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_revoked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_revoked = function () {
  return this.revocation != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

KeyWrapper.prototype.ekid = function() {
  return this.key.ekid();
};

KeyWrapper.prototype.overwrite_with_omitting_revokes = function(kw2) {
  if (kw2._pgp.<span class="apidocCodeKeywordSpan">is_revoked</span>()) {
    return;
  }
  if (this._pgp.is_revoked() || this.lifespan.expires_earlier_than(kw2.lifespan)) {
    return this.key = kw2.key, this.lifespan = kw2.lifespan, this._pgp = kw2._pgp, this._keybase = kw2._keybase, this.flags = kw2
.flags, kw2;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_self_signed" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_self_signed">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_self_signed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_self_signed = function () {
  return this.get_psc().is_self_signed();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_signed_subkey_of" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.is_signed_subkey_of">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>is_signed_subkey_of
        <span class="apidocSignatureSpan">(primary, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_signed_subkey_of = function (primary, opts) {
  var need_upwards_sig;
  if (this.primary_flag) {
    return false;
  }
  need_upwards_sig = (opts != null ? opts.strict : void 0) &#x26;&#x26; this.fulfills_flags(C.key_flags.sign_data);
  return this.get_psc().is_signed_subkey_of(primary, need_upwards_sig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.mark_revoked" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.mark_revoked">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>mark_revoked
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark_revoked = function (sig) {
  return this.revocation = sig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.merge_private" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.merge_private">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>merge_private
        <span class="apidocSignatureSpan">(k2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_private = function (k2) {
  return this.skm = k2.skm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return _results;
  }).call(this));
};

Engine.prototype._merge_1_private = function(k1, k2) {
  if (bufeq_secure(this.ekid(k1), this.ekid(k2))) {
    this.key(k1).<span class="apidocCodeKeywordSpan">merge_private</span>(this.key(k2));
    return true;
  } else {
    return false;
  }
};

Engine.prototype.merge_subkey_omitting_revokes = function(k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_body" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_body">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>private_body
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">private_body = function (opts) {
  var bufs, p, pp, priv, ret;
  bufs = [];
  this._write_public(bufs);
  priv = (p = this.key.priv) != null ? p.serialize() : null;
  pp = opts.passphrase || this.passphrase;
  if (priv == null) {
    this._write_dummy(bufs);
  } else if (pp != null) {
    this._write_private_enc(bufs, priv, pp);
  } else {
    this._write_private_clear(bufs, priv);
  }
  ret = Buffer.concat(bufs);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_framed" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.private_framed">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>private_framed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">private_framed = function (opts) {
  var T, body, tag;
  body = this.private_body(opts);
  T = C.packet_tags;
  tag = opts.subkey ? T.secret_subkey : T.secret_key;
  return this.frame_packet(tag, body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_body" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_body">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>public_body
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">public_body = function () {
  var bufs;
  bufs = [];
  this._write_public(bufs);
  return Buffer.concat(bufs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_framed" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.public_framed">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>public_framed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">public_framed = function (opts) {
  var T, body, tag;
  if (opts == null) {
    opts = {};
  }
  body = this.public_body();
  T = C.packet_tags;
  tag = opts.subkey ? T.public_subkey : T.public_key;
  return this.frame_packet(tag, body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.push_sig" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.push_sig">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>push_sig
        <span class="apidocSignatureSpan">(packetsig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push_sig = function (packetsig) {
  this.add_flags(packetsig.sig.get_key_flags());
  return KeyMaterial.__super__.push_sig.call(this, packetsig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Verifier.prototype._make_literals = function(cb) {
  if (!this.literals.length) {
    this.literals.push(new Literal({
      data: new Buffer([])
    }));
  }
  this.literals[0].<span class="apidocCodeKeywordSpan">push_sig</span>(new packetsigs.Data({
    sig: this._sig
  }));
  return cb(null);
};

Verifier.prototype.run = function(cb) {
  var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.self_sign_key" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.self_sign_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>self_sign_key
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">self_sign_key = function (_arg, cb) {
  var err, lifespan, primary, raw_payload, sig, sigs, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  userids = _arg.userids, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload;
  err = null;
  sigs = [];
  primary = true;
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref4, _results, _while;
      _ref4 = userids;
      _len = _ref4.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          userid = _ref4[_i];
          if (err == null) {
            sig = null;
            (function(__iced_k) {
              if (_this.key.can_sign() || raw_payload) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
                    funcname: &#x22;KeyMaterial.self_sign_key&#x22;
                  });
                  _this._self_sign_key({
                    userid: userid,
                    lifespan: lifespan,
                    raw_payload: raw_payload,
                    primary: primary
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return sig = arguments[1];
                      };
                    })(),
                    lineno: 194
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k((sig = userid.get_framed_signature_output()) == null ? err = new Error(&#x22;Cannot sign key --- don&#x27;
t have a private key, and can&#x27;t replay&#x22;) : void 0);
              }
            })(function() {
              primary = false;
              return _next(sigs.push(sig));
            });
          } else {
            return _continue();
          }
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, sig);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;PgpEngine._v_self_sign_primary&#x22;
  });
  _this.key(_this.primary).<span class="apidocCodeKeywordSpan">self_sign_key</span>({
    lifespan: lifespan,
    userids: _this.userids,
    raw_payload: raw_payload
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.set_duplicate_primary" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.set_duplicate_primary">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>set_duplicate_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set_duplicate_primary = function () {
  return this._is_duplicate_primary = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.sign_subkey" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.sign_subkey">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>sign_subkey
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign_subkey = function (_arg, cb) {
  var err, lifespan, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  subkey = _arg.subkey, lifespan = _arg.lifespan;
  err = sig = null;
  (function(_this) {
    return (function(__iced_k) {
      var _ref4, _ref5;
      if (_this.key.can_sign()) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
            funcname: &#x22;KeyMaterial.sign_subkey&#x22;
          });
          _this._sign_subkey({
            subkey: subkey,
            lifespan: lifespan
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 250
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k(!((_ref4 = subkey.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() :
void 0 : void 0) ? err = new Error(&#x22;Cannot sign with subkey --- don&#x27;t have private key and can&#x27;t replay&#x22;) : void 0);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;PgpEngine._v_sign_subkey&#x22;
  });
  _this.key(_this.primary).<span class="apidocCodeKeywordSpan">sign_subkey</span>({
    subkey: _this.key(subkey),
    lifespan: lifespan
  }, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.to_signature_payload" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.to_signature_payload">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>to_signature_payload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_signature_payload = function () {
  var pk;
  pk = this.public_body();
  return Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, pk.length), pk]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
};
_next = _continue;
if (!(_i &#x3c; _len)) {
  return _break();
} else {
  l = _ref3[_i];
  sp.push(l.<span class="apidocCodeKeywordSpan">to_signature_payload</span>());
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner._frame_literals&#x22;
    });
    l.write(esc(__iced_deferrals.defer({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.unlock" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.unlock">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>unlock
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock = function (_arg, cb) {
  var c1, c2, end, err, h1, h2, key, passphrase, pt;
  passphrase = _arg.passphrase;
  if (passphrase != null) {
    passphrase = bufferify(passphrase);
  }
  err = null;
  if (this.skm == null) {
    err = new Error(&#x22;Cannot unlock secret key -- no material!&#x22;);
    return cb(err);
  }
  pt = this.skm.s2k_convention === C.s2k_convention.none ? this.skm.payload : this.skm.s2k.type === C.s2k.gnu_dummy ? null : passphrase
 == null ? (err = new Error(&#x22;Key was locked, but no passphrase given&#x22;), null) : (key = this.skm.s2k.produce_key(passphrase, this
.skm.cipher.key_size), decrypt({
    ciphertext: this.skm.payload,
    block_cipher_class: this.skm.cipher.klass,
    iv: this.skm.iv,
    key: key
  }));
  if (pt) {
    switch (this.skm.s2k_convention) {
      case C.s2k_convention.sha1:
        end = pt.length - SHA1.output_size;
        h1 = pt.slice(end);
        pt = pt.slice(0, end);
        h2 = (new SHA1).bufhash(pt);
        if (!bufeq_secure(h1, h2)) {
          err = new Error(&#x22;bad private key passphrase (hash mismatch)&#x22;);
        }
        break;
      case C.s2k_convention.checksum:
      case C.s2k_convention.none:
        end = pt.length - 2;
        c1 = pt.readUInt16BE(end);
        pt = pt.slice(0, end);
        c2 = calc_checksum(pt);
        if (c1 !== c2) {
          err = new Error(&#x22;bad private key passphrase (checksum mismatch)&#x22;);
        }
    }
    if (err == null) {
      err = this.key.read_priv(pt);
    }
  }
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;Engine.unlock_keys&#x22;
  });
  _this.key(_this.primary).<span class="apidocCodeKeywordSpan">unlock</span>({
    asp: asp,
    tsenc: tsenc,
    passphrase: passphrase
  }, esc(__iced_deferrals.defer({
    lineno: 148
  })));
  __iced_deferrals._fulfill();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.KeyMaterial.prototype.validity_check" id="apidoc.element.kbpgp.opkts.KeyMaterial.prototype.validity_check">
        function <span class="apidocSignatureSpan">kbpgp.opkts.KeyMaterial.prototype.</span>validity_check
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validity_check = function (cb) {
  var err, msg, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced&#x22;,
        funcname: &#x22;KeyMaterial.validity_check&#x22;
      });
      _this.key.validity_check(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 346
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if (typeof err !== &#x22;undefined&#x22; &#x26;&#x26; err !== null) {
        msg = &#x22;In key &#x22; + (_this.get_fingerprint().toString(&#x27;hex&#x27;)) + &#x22;: &#x22; + err.message;
        err = new Error(err);
      }
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return function() {
      return cb(err, ret);
    };
  })(this));
};

BaseKeyPair.prototype.validity_check = function(cb) {
  return this.pub.<span class="apidocCodeKeywordSpan">validity_check</span>(cb);
};

BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {
  var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.Signature" id="apidoc.module.kbpgp.opkts.Signature">module kbpgp.opkts.Signature</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.Signature" id="apidoc.element.kbpgp.opkts.Signature.Signature">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>Signature
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(_arg) {
  this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class
 = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets
, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version
 = _arg.version;
  if (this.hasher == null) {
    this.hasher = SHA512;
  }
  if (this.hashed_subpackets == null) {
    this.hashed_subpackets = [];
  }
  if (this.unhashed_subpackets == null) {
    this.unhashed_subpackets = [];
  }
  this.subpacket_index = this._make_subpacket_index();
  this._framed_output = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.parse" id="apidoc.element.kbpgp.opkts.Signature.parse">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.</span>parse
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (slice) {
  return (new Parser(slice)).parse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.Signature.prototype" id="apidoc.module.kbpgp.opkts.Signature.prototype">module kbpgp.opkts.Signature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype._check_key_sig_expiration" id="apidoc.element.kbpgp.opkts.Signature.prototype._check_key_sig_expiration">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_check_key_sig_expiration
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_key_sig_expiration = function (opts) {
  var T, err, key_creation, key_expiration, key_expiration_packet, n, now, sig_creation_packet, sig_expiration, sig_expiration_packet
, _ref3;
  err = null;
  T = C.sig_types;
  key_expiration = 0;
  sig_expiration = 0;
  if ((_ref3 = this.type) === T.issuer || _ref3 === T.persona || _ref3 === T.casual || _ref3 === T.positive || _ref3 === T.subkey_binding
 || _ref3 === T.primary_binding) {
    key_creation = (opts.subkey || this.primary).timestamp;
    key_expiration_packet = this.subpacket_index.hashed[S.key_expiration_time];
    sig_creation_packet = this.subpacket_index.hashed[S.creation_time];
    sig_expiration_packet = this.subpacket_index.hashed[S.sig_expiration_time];
    now = (n = opts != null ? opts.now : void 0) != null ? n : unix_time();
    if ((key_creation != null) &#x26;&#x26; (key_expiration_packet != null ? key_expiration_packet.time : void 0)) {
      key_expiration = key_creation + key_expiration_packet.time;
    }
    if ((sig_creation_packet != null) &#x26;&#x26; (sig_expiration_packet != null ? sig_expiration_packet.time : void 0)) {
      sig_expiration = sig_creation_packet.time + sig_expiration_packet.time;
    }
    if (key_expiration &#x26;&#x26; !opts.time_travel &#x26;&#x26; now &#x3e; key_expiration) {
      err = new Error(&#x22;Key expired &#x22; + (now - key_expiration) + &#x22;s ago&#x22;);
    }
    if (sig_expiration &#x26;&#x26; !opts.time_travel &#x26;&#x26; now &#x3e; sig_expiration) {
      err = new Error(&#x22;Sig expired &#x22; + (now - key_expiration) + &#x22;s ago&#x22;);
    }
  }
  return [err, key_expiration, sig_expiration];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype._make_subpacket_index" id="apidoc.element.kbpgp.opkts.Signature.prototype._make_subpacket_index">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_make_subpacket_index
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_make_subpacket_index = function () {
  var p, ret, _i, _j, _len, _len1, _ref3, _ref4;
  ret = {
    hashed: {},
    unhashed: {},
    all: {}
  };
  _ref3 = this.hashed_subpackets;
  for (_i = 0, _len = _ref3.length; _i &#x3c; _len; _i++) {
    p = _ref3[_i];
    ret.hashed[p.type] = p;
    ret.all[p.type] = p;
  }
  _ref4 = this.unhashed_subpackets;
  for (_j = 0, _len1 = _ref4.length; _j &#x3c; _len1; _j++) {
    p = _ref4[_j];
    ret.unhashed[p.type] = p;
    ret.all[p.type] = p;
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype._verify" id="apidoc.element.kbpgp.opkts.Signature.prototype._verify">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>_verify
        <span class="apidocSignatureSpan">(data_packets, cb, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify = function (data_packets, cb, opts) {
  var SKB, T, buffers, d, data, dp, err, hvalue, iki, key_expiration, n, packets, payload, ps, sig, sig_expiration, subkey, user_attribute
, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  T = C.sig_types;
  subkey = null;
  this.data_packets = (function() {
    switch (this.type) {
      case T.binary_doc:
      case T.canonical_text:
        return data_packets;
      case T.issuer:
      case T.persona:
      case T.casual:
      case T.positive:
      case T.certificate_revocation:
      case T.key_revocation:
        if ((n = data_packets.length) &#x3e; 1) {
          err = new Error(&#x22;Only expecting one (or no) UserID-style packet(s) in a self-sig (got &#x22; + n + &#x22;)&#x22;);
          return [];
        } else {
          return [this.primary].concat(data_packets);
        }
        break;
      case T.subkey_binding:
      case T.primary_binding:
      case T.subkey_revocation:
        packets = [];
        if (data_packets.length !== 1) {
          err = new Error(&#x22;Wrong number of data packets; expected only 1&#x22;);
        } else if (this.primary == null) {
          err = new Error(&#x22;Need a primary key for subkey signature&#x22;);
        } else {
          subkey = data_packets[0];
          packets = [this.primary, subkey];
        }
        return packets;
      case T.direct:
        return [this.primary].concat(data_packets);
      default:
        err = new Error(&#x22;cannot verify sigtype &#x22; + this.type);
        return [];
    }
  }).call(this);
  (function(_this) {
    return (function(__iced_k) {
      var _ref3;
      if (err == null) {
        buffers = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = this.data_packets;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i &#x3c; _len; _i++) {
            dp = _ref3[_i];
            _results.push(dp.to_signature_payload());
          }
          return _results;
        }).call(_this);
        data = Buffer.concat(buffers);
        _ref3 = _this.prepare_payload(data), payload = _ref3.payload, hvalue = _ref3.hvalue;
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/packet/signature.iced&#x22;,
            funcname: &#x22;Signature._verify&#x22;
          });
          _this.key.verify_unpad_and_check_hash({
            sig: _this.sig,
            hash: hvalue,
            hasher: _this.hasher
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 270
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      var _i, _len, _ref3, _ref4;
      if ((err == null) &#x26;&#x26; (_this.key_manager != null)) {
        err = _this.key_manager.pgp_check_not_expired({
          subkey_material: _this.subkey_material,
          now: opts != null ? opts.now : void 0
        });
      }
      if (err == null) {
        opts || (opts = {});
        opts.subkey = subkey;
        _ref3 = _this._check_key_sig_expiration(opts), err = _ref3[0], key_expiration = _ref3[1], sig_expiration = _ref3[2];
        opts.subkey = null;
      }
      sig = _this;
      if (err == null) {
        SKB = packetsigs.SubkeyBinding;
        switch (_this.type) {
          case T.binary_doc:
          case T.canonical_text:
            _ref4 = _this.data_packets;
            for (_i = 0, _len = _ref4.length; _i &#x3c; _len; _i++) {
              d = _ref4[_i];
              d.push_sig(new packetsigs.Data({
                sig: sig
              }));
            }
            break;
          case T.issuer:
          case T.persona:
          case T.casual:
          case T.positive:
            ps = null;
            if ((userid = _this.data_pa ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
      funcname: &#x22;Verifier.run&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_verify</span>(esc(__iced_deferrals.defer({
      lineno: 204
    })));
    __iced_deferrals._fulfill();
  })(function() {
    return cb(null, _this._literal);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.constructor" id="apidoc.element.kbpgp.opkts.Signature.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(_arg) {
  this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class
 = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets
, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version
 = _arg.version;
  if (this.hasher == null) {
    this.hasher = SHA512;
  }
  if (this.hashed_subpackets == null) {
    this.hashed_subpackets = [];
  }
  if (this.unhashed_subpackets == null) {
    this.unhashed_subpackets = [];
  }
  this.subpacket_index = this._make_subpacket_index();
  this._framed_output = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.extract_key" id="apidoc.element.kbpgp.opkts.Signature.prototype.extract_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>extract_key
        <span class="apidocSignatureSpan">(data_packets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract_key = function (data_packets) {
  var p, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = data_packets.length; _i &#x3c; _len; _i++) {
    p = data_packets[_i];
    if (p.key != null) {
      this.key = p.key;
      break;
    } else {
      _results.push(void 0);
    }
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_framed_output" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_framed_output">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_framed_output
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_framed_output = function () {
  return this._framed_output || this.replay();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_fingerprint" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_fingerprint">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_issuer_fingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_issuer_fingerprint = function () {
  var _ref3;
  return (_ref3 = this.subpacket_index.all[S.issuer_fingerprint]) != null ? _ref3.fingerprint : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_key_id" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_issuer_key_id">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_issuer_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_issuer_key_id = function () {
  var _ref3, _ref4;
  return (_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.all[C.sig_subpacket.issuer]) != null ? _ref4.id : void 0 : void
 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_expires" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_key_expires">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_expires
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_key_expires = function () {
  var _ref3;
  return (_ref3 = this.subpacket_index.hashed[S.key_expiration_time]) != null ? _ref3.time : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_flags" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_key_flags">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_flags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_key_flags = function () {
  var _ref3, _ref4, _ref5;
  return ((_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.hashed) != null ? (_ref5 = _ref4[C.sig_subpacket.key_flags]) !=
null ? _ref5.all_flags() : void 0 : void 0 : void 0) || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_key_id" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_key_id">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_key_id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_key_id = function () {
  var _ref3;
  if (this.key_id) {
    return this.key_id;
  } else {
    return (_ref3 = this.subpacket_index.all[S.issuer]) != null ? _ref3.id : void 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
esc = make_esc(cb, &#x22;Burner::_sign&#x27;&#x22;);
ops = new OnePassSignature({
  sig_type: C.sig_types.binary_doc,
  hasher: SHA512,
  sig_klass: this.signing_key.get_klass(),
  key_id: this.signing_key.<span class="apidocCodeKeywordSpan">get_key_id</span>(),
  is_final: 1
});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.get_sig_expires" id="apidoc.element.kbpgp.opkts.Signature.prototype.get_sig_expires">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>get_sig_expires
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_sig_expires = function () {
  var _ref3;
  return (_ref3 = this.subpacket_index.hashed[S.expiration_time]) != null ? _ref3.time : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.is_signature" id="apidoc.element.kbpgp.opkts.Signature.prototype.is_signature">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>is_signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_signature = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.issuer_matches_key" id="apidoc.element.kbpgp.opkts.Signature.prototype.issuer_matches_key">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>issuer_matches_key
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">issuer_matches_key = function (key) {
  var fp;
  if ((fp = this.get_issuer_fingerprint()) != null) {
    if (!bufeq_secure(fp, this.primary.get_fingerprint())) {
      return false;
    }
  }
  return bufeq_secure(this.get_issuer_key_id(), this.primary.get_key_id());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.prepare_payload" id="apidoc.element.kbpgp.opkts.Signature.prototype.prepare_payload">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>prepare_payload
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepare_payload = function (data) {
  var flatsp, hvalue, payload, prefix, s, trailer;
  flatsp = Buffer.concat((function() {
    var _i, _len, _ref3, _results;
    _ref3 = this.hashed_subpackets;
    _results = [];
    for (_i = 0, _len = _ref3.length; _i &#x3c; _len; _i++) {
      s = _ref3[_i];
      _results.push(s.to_buffer());
    }
    return _results;
  }).call(this));
  prefix = Buffer.concat([new Buffer([C.versions.signature.V4, this.type, this.key.type, this.hasher.type]), uint_to_buffer(16,
flatsp.length), flatsp]);
  trailer = Buffer.concat([new Buffer([C.versions.signature.V4, 0xff]), uint_to_buffer(32, prefix.length)]);
  payload = Buffer.concat([data, prefix, trailer]);
  hvalue = this.hasher(payload);
  return {
    prefix: prefix,
    payload: payload,
    hvalue: hvalue
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.time_primary_pair" id="apidoc.element.kbpgp.opkts.Signature.prototype.time_primary_pair">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>time_primary_pair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time_primary_pair = function () {
  var T, _ref3, _ref4;
  T = C.sig_types;
  if ((_ref3 = this.type) === T.issuer || _ref3 === T.persona || _ref3 === T.casual || _ref3 === T.positive) {
    return [this.when_generated(), !!((_ref4 = this.subpacket_index.hashed[S.primary_user_id]) != null ? _ref4.flag : void 0)];
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_ref5 = this.userids;
for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
  userid = _ref5[i];
  if (!(userid != null)) {
    continue;
  }
  s = userid.utf8();
  pair = userid.<span class="apidocCodeKeywordSpan">time_primary_pair</span>();
  obj = {
    userid: userid,
    pair: pair,
    i: i
  };
  do_insert = false;
  if ((prev = tab[s]) != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.verify" id="apidoc.element.kbpgp.opkts.Signature.prototype.verify">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>verify
        <span class="apidocSignatureSpan">(data_packets, cb, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (data_packets, cb, opts) {
  var err, p, s, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/packet/signature.iced&#x22;,
        funcname: &#x22;Signature.verify&#x22;
      });
      _this._verify(data_packets, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return err = arguments[0];
          };
        })(),
        lineno: 210
      }), opts);
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        var _i, _len, _ref3, _results, _while;
        _ref3 = _this.unhashed_subpackets;
        _len = _ref3.length;
        _i = 0;
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = __iced_k;
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = _continue;
          if (!(_i &#x3c; _len)) {
            return _break();
          } else {
            p = _ref3[_i];
            if ((typeof err === &#x22;undefined&#x22; || err === null) &#x26;&#x26; ((s = p.to_sig()) != null)) {
              (function(__iced_k) {
                if (s.type !== C.sig_types.primary_binding) {
                  return __iced_k(err = new Error(&#x22;unknown subpacket signature type: &#x22; + s.type));
                } else {
                  (function(__iced_k) {
                    if (data_packets.length !== 1) {
                      return __iced_k(err = new Error(&#x22;Needed 1 data packet for a primary_binding signature&#x22;));
                    } else {
                      subkey = data_packets[0];
                      s.primary = _this.primary;
                      s.key = subkey.key;
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: &#x22;/home/michal/kbpgp/src/openpgp/packet/signature.iced&#x22;,
                          funcname: &#x22;Signature.verify&#x22;
                        });
                        s._verify([subkey], __iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              return err = arguments[0];
                            };
                          })(),
                          lineno: 220
                        }), opts);
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    }
                  })(__iced_k);
                }
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.when_generated" id="apidoc.element.kbpgp.opkts.Signature.prototype.when_generated">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>when_generated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when_generated = function () {
  var _ref3;
  return (_ref3 = this.subpacket_index.hashed[S.creation_time]) != null ? _ref3.time : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.write" id="apidoc.element.kbpgp.opkts.Signature.prototype.write">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>write
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, cb) {
  var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/packet/signature.iced&#x22;,
        funcname: &#x22;Signature.write&#x22;
      });
      _this.write_unframed(data, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return unframed = arguments[1];
          };
        })(),
        lineno: 181
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      if (typeof err === &#x22;undefined&#x22; || err === null) {
        _this._framed_output = ret = _this.frame_packet(C.packet_tags.signature, unframed);
      }
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sp.push(l.to_signature_payload());
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._frame_literals&#x22;
  });
  l.<span class="apidocCodeKeywordSpan">write</span>(esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return p = arguments[0];
      };
    })(),
    lineno: 51
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.Signature.prototype.write_unframed" id="apidoc.element.kbpgp.opkts.Signature.prototype.write_unframed">
        function <span class="apidocSignatureSpan">kbpgp.opkts.Signature.prototype.</span>write_unframed
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_unframed = function (data, cb) {
  var esc, hvalue, payload, prefix, result2, results, s, sig, uhsp, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;write_unframed&#x22;);
  uhsp = Buffer.concat((function() {
    var _i, _len, _ref3, _results;
    _ref3 = this.unhashed_subpackets;
    _results = [];
    for (_i = 0, _len = _ref3.length; _i &#x3c; _len; _i++) {
      s = _ref3[_i];
      _results.push(s.to_buffer());
    }
    return _results;
  }).call(this));
  _ref3 = this.prepare_payload(data), prefix = _ref3.prefix, payload = _ref3.payload, hvalue = _ref3.hvalue;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/packet/signature.iced&#x22;,
        funcname: &#x22;Signature.write_unframed&#x22;
      });
      _this.key.pad_and_sign(payload, {
        hasher: _this.hasher
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return sig = arguments[0];
          };
        })(),
        lineno: 168
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      result2 = Buffer.concat([uint_to_buffer(16, uhsp.length), uhsp, new Buffer([hvalue.readUInt8(0), hvalue.readUInt8(1)]), sig
]);
      results = Buffer.concat([prefix, result2]);
      return cb(null, results);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.UserID" id="apidoc.module.kbpgp.opkts.UserID">module kbpgp.opkts.UserID</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.UserID" id="apidoc.element.kbpgp.opkts.UserID.UserID">
        function <span class="apidocSignatureSpan">kbpgp.opkts.</span>UserID
        <span class="apidocSignatureSpan">(userid, components)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserID(userid, components) {
  this.components = components != null ? components : null;
  this.userid = bufferify(userid);
  if (this.compontents == null) {
    this._parse();
  }
  UserID.__super__.constructor.call(this);
  this._time_primary_pair = null;
  this.primary = false;
  this.most_recent_sig = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return (function(__iced_k) {
if ((userids != null) &#x26;&#x26; Array.isArray(userids)) {
  return __iced_k(userids = (function() {
    var _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = userids.length; _j &#x3c; _len1; _j++) {
      u = userids[_j];
      _results.push(new opkts.<span class="apidocCodeKeywordSpan">UserID</span>(u));
    }
    return _results;
  })());
} else {
  err = new Error(&#x22;Need either &#x27;userid&#x27; or &#x27;userids&#x27; specified as an array&#x22;);
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.make" id="apidoc.element.kbpgp.opkts.UserID.make">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.</span>make
        <span class="apidocSignatureSpan">(components)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (components) {
  var c, comment, userid;
  comment = (c = components.comment) != null ? &#x22;(&#x22; + c + &#x22;) &#x22; : &#x22;&#x22;;
  userid = &#x22;&#x22; + components.username + &#x22; &#x22; + comment + &#x22;&#x3c;&#x22; + components.email + &#x22;&#x3e;&#x22;;
  return new UserID(userid, components);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
      }
    };
    _while(__iced_k);
  });
})(this)((function(_this) {
  return function() {
    key = Pair.<span class="apidocCodeKeywordSpan">make</span>({
      p: p,
      q: q,
      e: e,
      phi: phi,
      p1: p1,
      q1: q1,
      lambda: lambda
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.parse" id="apidoc.element.kbpgp.opkts.UserID.parse">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.</span>parse
        <span class="apidocSignatureSpan">(slice)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (slice) {
  return new UserID(slice.consume_rest_to_buffer());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.opkts.UserID.prototype" id="apidoc.module.kbpgp.opkts.UserID.prototype">module kbpgp.opkts.UserID.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype._parse" id="apidoc.element.kbpgp.opkts.UserID.prototype._parse">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>_parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parse = function () {
  var c;
  if ((c = parse(this.utf8())) != null) {
    return this.components = c;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.cmp" id="apidoc.element.kbpgp.opkts.UserID.prototype.cmp">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>cmp
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmp = function (b) {
  var x, y;
  x = this.utf8();
  y = b.utf8();
  if (x &#x3c; y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.constructor" id="apidoc.element.kbpgp.opkts.UserID.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>constructor
        <span class="apidocSignatureSpan">(userid, components)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserID(userid, components) {
  this.components = components != null ? components : null;
  this.userid = bufferify(userid);
  if (this.compontents == null) {
    this._parse();
  }
  UserID.__super__.constructor.call(this);
  this._time_primary_pair = null;
  this.primary = false;
  this.most_recent_sig = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_comment" id="apidoc.element.kbpgp.opkts.UserID.prototype.get_comment">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_comment = function () {
  var _ref2;
  return (_ref2 = this.components) != null ? _ref2.comment : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_email" id="apidoc.element.kbpgp.opkts.UserID.prototype.get_email">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_email
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_email = function () {
  var _ref2;
  return (_ref2 = this.components) != null ? _ref2.email : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_framed_signature_output" id="apidoc.element.kbpgp.opkts.UserID.prototype.get_framed_signature_output">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_framed_signature_output
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_framed_signature_output = function () {
  var _ref2, _ref3, _ref4;
  return (_ref2 = this.get_psc()) != null ? (_ref3 = _ref2.get_self_sig()) != null ? (_ref4 = _ref3.sig) != null ? _ref4.get_framed_output
() : void 0 : void 0 : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    PgpEngine.prototype._export_keys_to_binary = function(opts) {
var packets, subkey, userid, _i, _j, _len, _len1, _ref5, _ref6;
packets = [this.key(this.primary).export_framed(opts)];
_ref5 = this.userids;
for (_i = 0, _len = _ref5.length; _i &#x3c; _len; _i++) {
  userid = _ref5[_i];
  packets.push(userid.write(), userid.<span class="apidocCodeKeywordSpan">get_framed_signature_output</span>());
}
opts.subkey = true;
_ref6 = this.subkeys;
for (_j = 0, _len1 = _ref6.length; _j &#x3c; _len1; _j++) {
  subkey = _ref6[_j];
  packets.push(this.key(subkey).export_framed(opts), this.key(subkey).get_subkey_binding_signature_output());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.get_username" id="apidoc.element.kbpgp.opkts.UserID.prototype.get_username">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>get_username
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_username = function () {
  var _ref2;
  return (_ref2 = this.components) != null ? _ref2.username : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.time_primary_pair" id="apidoc.element.kbpgp.opkts.UserID.prototype.time_primary_pair">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>time_primary_pair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time_primary_pair = function () {
  var max, p, pairs, ret, s, _i, _len;
  if (this._time_primary_pair == null) {
    pairs = (function() {
      var _i, _len, _ref2, _ref3, _results;
      _ref2 = this.get_psc().get_self_sigs();
      _results = [];
      for (_i = 0, _len = _ref2.length; _i &#x3c; _len; _i++) {
        s = _ref2[_i];
        _results.push(s != null ? (_ref3 = s.sig) != null ? _ref3.time_primary_pair() : void 0 : void 0);
      }
      return _results;
    }).call(this);
    max = null;
    ret = [null, null];
    for (_i = 0, _len = pairs.length; _i &#x3c; _len; _i++) {
      p = pairs[_i];
      if (!(p != null)) {
        continue;
      }
      if (p[0] &#x26;&#x26; ((ret[0] == null) || (ret[0] &#x3c; p[0]))) {
        ret[0] = p[0];
      }
      if (p[1] &#x26;&#x26; ((ret[1] == null) || (ret[1] &#x3c; p[0]))) {
        ret[1] = p[0];
      }
    }
    this._time_primary_pair = ret;
    this.most_recent_sig = ret[0];
  }
  return this._time_primary_pair;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_ref5 = this.userids;
for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
  userid = _ref5[i];
  if (!(userid != null)) {
    continue;
  }
  s = userid.utf8();
  pair = userid.<span class="apidocCodeKeywordSpan">time_primary_pair</span>();
  obj = {
    userid: userid,
    pair: pair,
    i: i
  };
  do_insert = false;
  if ((prev = tab[s]) != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.to_signature_payload" id="apidoc.element.kbpgp.opkts.UserID.prototype.to_signature_payload">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>to_signature_payload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_signature_payload = function () {
  return Buffer.concat([new Buffer([C.signatures.userid]), uint_to_buffer(32, this.userid.length), this.userid]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
};
_next = _continue;
if (!(_i &#x3c; _len)) {
  return _break();
} else {
  l = _ref3[_i];
  sp.push(l.<span class="apidocCodeKeywordSpan">to_signature_payload</span>());
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
      funcname: &#x22;Burner._frame_literals&#x22;
    });
    l.write(esc(__iced_deferrals.defer({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.to_userid" id="apidoc.element.kbpgp.opkts.UserID.prototype.to_userid">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>to_userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_userid = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.utf8" id="apidoc.element.kbpgp.opkts.UserID.prototype.utf8">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>utf8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utf8 = function () {
  return this.userid.toString(&#x27;utf8&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
_ref5 = this.userids;
for (i = _i = 0, _len = _ref5.length; _i &#x3c; _len; i = ++_i) {
  userid = _ref5[i];
  if (!(userid != null)) {
    continue;
  }
  s = userid.<span class="apidocCodeKeywordSpan">utf8</span>();
  pair = userid.time_primary_pair();
  obj = {
    userid: userid,
    pair: pair,
    i: i
  };
  do_insert = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.opkts.UserID.prototype.write" id="apidoc.element.kbpgp.opkts.UserID.prototype.write">
        function <span class="apidocSignatureSpan">kbpgp.opkts.UserID.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return this.frame_packet(C.packet_tags.userid, this.userid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sp.push(l.to_signature_payload());
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced&#x22;,
    funcname: &#x22;Burner._frame_literals&#x22;
  });
  l.<span class="apidocCodeKeywordSpan">write</span>(esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return p = arguments[0];
      };
    })(),
    lineno: 51
  })));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.pad" id="apidoc.module.kbpgp.pad">module kbpgp.pad</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.pad.ecc_pkcs5_pad_data" id="apidoc.element.kbpgp.pad.ecc_pkcs5_pad_data">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>ecc_pkcs5_pad_data
        <span class="apidocSignatureSpan">(d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ecc_pkcs5_pad_data = function (d) {
  var err, pad_len, ret, v;
  err = ret = null;
  pad_len = 40 - d.length;
  if (pad_len &#x3c; 0) {
    err = new Error(&#x22;Pad underrun&#x22;);
  } else {
    v = (function() {
      var _i, _results;
      _results = [];
      for (_i = 0; 0 &#x3c;= pad_len ? _i &#x3c; pad_len : _i &#x3e; pad_len; 0 &#x3c;= pad_len ? _i++ : _i--) {
        _results.push(pad_len);
      }
      return _results;
    })();
    ret = Buffer.concat([d, new Buffer(v)]);
  }
  return [err, ret];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.pad.ecc_pkcs5_unpad_data" id="apidoc.element.kbpgp.pad.ecc_pkcs5_unpad_data">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>ecc_pkcs5_unpad_data
        <span class="apidocSignatureSpan">(buf, data_len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ecc_pkcs5_unpad_data = function (buf, data_len) {
  var c, err, i, pad_len, _i, _ref1;
  err = null;
  pad_len = buf.length - data_len;
  if (pad_len &#x3c; 0) {
    err = new Error(&#x22;Pad length was &#x3c; 0; pad underrun&#x22;);
  } else if ((buf.length % 8) !== 0) {
    err = new Error(&#x22;Padded data must be a multiple of 8 bytes long&#x22;);
  } else {
    for (i = _i = data_len, _ref1 = buf.length; data_len &#x3c;= _ref1 ? _i &#x3c; _ref1 : _i &#x3e; _ref1; i = data_len &#x3c;= _ref1 ? ++_i : --_i
) {
      if ((c = buf.readUInt8(i)) !== pad_len) {
        err = new Error(&#x22;Got bad PKCS#5 pad character &#x22; + c + &#x22; at position &#x22; + i + &#x22;; wanted &#x22; + pad_len);
        break;
      }
    }
  }
  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.pad.eme_pkcs1_decode" id="apidoc.element.kbpgp.pad.eme_pkcs1_decode">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>eme_pkcs1_decode
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eme_pkcs1_decode = function (v) {
  var err, i, ret;
  err = ret = null;
  if (v.length &#x3c; 12) {
    err = new Error(&#x22;Ciphertext too short, needs to be &#x3e;= 12 bytes&#x22;);
  } else if (v.readUInt16BE(0) !== 0x0002) {
    err = new Error(&#x22;Failed to find expected header: 0x00 0x02&#x22;);
  } else {
    i = 2;
    while (i &#x3c; v.length &#x26;&#x26; (v.readUInt8(i) !== 0x0)) {
      i++;
    }
    if (i &#x3e;= v.length) {
      err = new Error(&#x22;didn&#x27;t get 0x00 seperator octet&#x22;);
    } else {
      i++;
      ret = v.slice(i);
    }
  }
  return [err, ret];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.pad.eme_pkcs1_encode" id="apidoc.element.kbpgp.pad.eme_pkcs1_encode">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>eme_pkcs1_encode
        <span class="apidocSignatureSpan">(v, len, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eme_pkcs1_encode = function (v, len, cb) {
  var PS, buf, err, n_randos, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  ret = err = null;
  (function(_this) {
    return (function(__iced_k) {
      if (v.length &#x3e; len - 11) {
        return __iced_k(err = new Error(&#x22;cannot encrypt message -- it&#x27;s too long!&#x22;));
      } else {
        n_randos = len - 3 - v.length;
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/pad.iced&#x22;,
            funcname: &#x22;eme_pkcs1_encode&#x22;
          });
          eme_random(n_randos, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return PS = arguments[0];
              };
            })(),
            lineno: 93
          }));
          __iced_deferrals._fulfill();
        })(function() {
          buf = Buffer.concat([new Buffer([0x00, 0x02]), PS, new Buffer([0x00]), v]);
          return __iced_k(ret = nbs(buffer_to_ui8a(buf), 256));
        });
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.pad.emsa_pkcs1_decode" id="apidoc.element.kbpgp.pad.emsa_pkcs1_decode">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>emsa_pkcs1_decode
        <span class="apidocSignatureSpan">(v, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emsa_pkcs1_decode = function (v, hasher) {
  var err, h, header, i, ret;
  err = ret = null;
  i = 0;
  if (v.length &#x3c; 2) {
    err = new Error(&#x22;signature was way too short: &#x3c; 2 bytes&#x22;);
  } else {
    if (v.readUInt16BE(0) !== 0x0001) {
      err = new Error(&#x22;Sig verify error: Didn&#x27;t get two-byte header 0x00 0x01&#x22;);
    } else {
      i = 2;
      while (i &#x3c; v.length &#x26;&#x26; (v.readUInt8(i) === 0xff)) {
        i++;
      }
      if (i &#x3e;= v.length || v.readUInt8(i) !== 0) {
        err = new Error(&#x22;Sig verify error: Missed the 0x0 separator&#x22;);
      } else {
        i++;
        header = hash_headers[hasher.algname];
        if (!bufeq_secure(new Buffer(header), v.slice(i, header.length + i))) {
          err = new Error(&#x22;Sig verify error: missing ASN header for &#x22; + hasher.algname);
        } else {
          i += header.length;
          h = v.slice(i);
          if (h.length !== hasher.output_length) {
            err = new Error(&#x22;Sig verify error: trailing garbage in signature&#x22;);
          } else {
            ret = h;
          }
        }
      }
    }
  }
  return [err, ret];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.pad.emsa_pkcs1_encode" id="apidoc.element.kbpgp.pad.emsa_pkcs1_encode">
        function <span class="apidocSignatureSpan">kbpgp.pad.</span>emsa_pkcs1_encode
        <span class="apidocSignatureSpan">(hashed_data, len, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emsa_pkcs1_encode = function (hashed_data, len, opts) {
  var buf, hasher, headers, i, n;
  if (opts == null) {
    opts = {};
  }
  hasher = opts.hasher || SHA512;
  headers = hash_headers[hasher.algname];
  n = len - headers.length - 3 - hasher.output_length;
  buf = Buffer.concat([
    new Buffer([0x00, 0x01]), new Buffer((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 &#x3c;= n ? _i &#x3c; n : _i &#x3e; n; i = 0 &#x3c;= n ? ++_i : --_i) {
        _results.push(0xff);
      }
      return _results;
    })()), new Buffer([0x00]), new Buffer(headers), hashed_data
  ]);
  return nbs(buffer_to_ui8a(buf), 256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.parser" id="apidoc.module.kbpgp.parser">module kbpgp.parser</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.parser.parse" id="apidoc.element.kbpgp.parser.parse">
        function <span class="apidocSignatureSpan">kbpgp.parser.</span>parse
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (buf) {
  return util.katch(function() {
    return (new MessageParser(new SlicerBuffer(buf))).parse();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Pair.__super__.constructor.call(this, {
    pub: pub,
    priv: priv
  });
}

Pair.parse = function(pub_raw) {
  return BaseKeyPair.<span class="apidocCodeKeywordSpan">parse</span>(Pair, pub_raw);
};

Pair.prototype.can_encrypt = function() {
  return false;
};

Pair.prototype.fulfills_flags = function(flags) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.primegen" id="apidoc.module.kbpgp.primegen">module kbpgp.primegen</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.primegen.fermat2_test" id="apidoc.element.kbpgp.primegen.fermat2_test">
        function <span class="apidocSignatureSpan">kbpgp.primegen.</span>fermat2_test
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fermat2_test = function (n) {
  var Bl, bl, i, ret, t, _i;
  t = nbv(1);
  bl = n.bitLength();
  bl--;
  Bl = n.byteLength();
  for (i = _i = bl; bl &#x3c;= 0 ? _i &#x3c;= 0 : _i &#x3e;= 0; i = bl &#x3c;= 0 ? ++_i : --_i) {
    t = t.square();
    if (t.byteLength() &#x3e; Bl) {
      t = t.mod(n);
    }
    if (n.testBit(i)) {
      t = t.shiftLeft(1);
    }
  }
  if (t.compareTo(n) &#x3e; 0) {
    t = t.mod(n);
  }
  ret = t.compareTo(nbv(2)) === 0;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.primegen.miller_rabin" id="apidoc.element.kbpgp.primegen.miller_rabin">
        function <span class="apidocSignatureSpan">kbpgp.primegen.</span>miller_rabin
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">miller_rabin = function (_arg, cb) {
  var asp, esc, i, iter, p, p1, r, ret, s, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  p = _arg.p, iter = _arg.iter, asp = _arg.asp;
  asp || (asp = new ASP({}));
  iter || (iter = 10);
  esc = make_esc(cb, &#x22;miller_rabin&#x22;);
  ret = _MR_small_check({
    p: p
  });
  (function(_this) {
    return (function(__iced_k) {
      if (ret) {
        p1 = p.subtract(BigInteger.ONE);
        s = p1.getLowestSetBit();
        r = p1.shiftRight(s);
        ret = true;
        (function(__iced_k) {
          var _begin, _end, _i, _positive, _results, _step, _while;
          i = 0;
          _begin = 0;
          _end = iter;
          if (_end &#x3e; _begin) {
            _step = 1;
          } else {
            _step = -1;
          }
          _positive = _end &#x3e; _begin;
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = __iced_k;
            _continue = function() {
              return iced.trampoline(function() {
                i += _step;
                return _while(__iced_k);
              });
            };
            _next = _continue;
            if (!!((_positive === true &#x26;&#x26; i &#x3e;= iter) || (_positive === false &#x26;&#x26; i &#x3c;= iter))) {
              return _break();
            } else {

              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
                });
                asp.progress({
                  what: &#x22;mr&#x22;,
                  i: i,
                  total: iter,
                  p: p
                }, esc(__iced_deferrals.defer({
                  lineno: 122
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  if (!_MR_inner({
                    s: s,
                    r: r,
                    p: p,
                    p1: p1
                  })) {
                    ret = false;
                    (function(__iced_k) {
_break()
                    })(__iced_k);
                  } else {
                    return __iced_k();
                  }
                })(_next);
              });
            }
          };
          _while(__iced_k);
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
            });
            asp.progress({
              what: &#x22;mr&#x22;,
              i: iter,
              total: iter,
              p: p
            }, esc(__iced_deferrals.defer({
              lineno: 127
            })));
            __iced_deferrals._fulfill();
          })(__iced_k);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(null, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.primegen.naive_is_prime" id="apidoc.element.kbpgp.primegen.naive_is_prime">
        function <span class="apidocSignatureSpan">kbpgp.primegen.</span>naive_is_prime
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naive_is_prime = function (n) {
  var biggest, p, _i, _len;
  biggest = Math.floor(Math.sqrt(n));
  for (_i = 0, _len = small_primes.length; _i &#x3c; _len; _i++) {
    p = small_primes[_i];
    if (p &#x3e; biggest) {
      return true;
    }
    if ((n % p) === 0) {
      return false;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.primegen.nbs" id="apidoc.element.kbpgp.primegen.nbs">
        function <span class="apidocSignatureSpan">kbpgp.primegen.</span>nbs
        <span class="apidocSignatureSpan">(s, base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nbs = function (s, base) {
  var r;
  if (base == null) {
    base = 10;
  }
  r = nbi();
  return r.fromString(s, base);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.primegen.random_prime" id="apidoc.element.kbpgp.primegen.random_prime">
        function <span class="apidocSignatureSpan">kbpgp.primegen.</span>random_prime
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random_prime = function (_arg, cb) {
  var asp, e, esc, go, iters, nbits, p, range, sieve, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbits = _arg.nbits, iters = _arg.iters, asp = _arg.asp, e = _arg.e;
  sieve = [1, 2];
  go = true;
  esc = make_esc(cb, &#x22;random_prime&#x22;);
  range = nbits;
  p = null;
  (function(_this) {
    return (function(__iced_k) {
      var _while;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!go) {
          return _break();
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
            });
            SRF().random_nbit(nbits, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return p = arguments[0];
                };
              })(),
              lineno: 262
            }));
            __iced_deferrals._fulfill();
          })(function() {
            p = p.setBit(0).setBit(nbits - 1).setBit(nbits - 2);
            (function(__iced_k) {
              if ((e == null) || p.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
                  });
                  asp.progress({
                    what: &#x22;guess&#x22;,
                    p: p
                  }, esc(__iced_deferrals.defer({
                    lineno: 265
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
                    });
                    prime_search({
                      start: p,
                      range: range,
                      sieve: sieve,
                      asp: asp,
                      iters: iters
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return p = arguments[0];
                        };
                      })(),
                      lineno: 266
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(go = (p == null) || (p.compareTo(BigInteger.ZERO) === 0));
                  });
                });
              } else {
                return __iced_k();
              }
            })(_next);
          });
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/kbpgp/src/primegen.iced&#x22;
        });
        asp.progress({
          what: &#x22;found&#x22;,
          p: p
        }, esc(__iced_deferrals.defer({
          lineno: 269
        })));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(null, p);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.processor" id="apidoc.module.kbpgp.processor">module kbpgp.processor</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock" id="apidoc.element.kbpgp.processor.KeyBlock">
        function <span class="apidocSignatureSpan">kbpgp.processor.</span>KeyBlock
        <span class="apidocSignatureSpan">(packets, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyBlock(packets, opts) {
  this.packets = packets;
  this.verified_signatures = [];
  this.subkeys = [];
  this.primary = null;
  this.userids = [];
  this.user_attributes = [];
  this.warnings = new Warnings();
  this.opts = opts || {};
  if (this.opts.strict == null) {
    this.opts.strict = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message" id="apidoc.element.kbpgp.processor.Message">
        function <span class="apidocSignatureSpan">kbpgp.processor.</span>Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.keyfetch = _arg.keyfetch, this.data_fn = _arg.data_fn, this.data = _arg.data, this.strict = _arg.strict, this.now = _arg.
now;
  this.literals = [];
  this.enc_data_packet = null;
  this.warnings = new Warnings();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {
var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
body = _arg.body;
esc = make_esc(cb, &#x22;get_payload_from_raw_sig_body&#x22;);
payload = null;
m = new processor.<span class="apidocCodeKeywordSpan">Message</span>({});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
      funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.do_message" id="apidoc.element.kbpgp.processor.do_message">
        function <span class="apidocSignatureSpan">kbpgp.processor.</span>do_message
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">do_message = function (_arg, cb) {
  var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, now, proc, raw, strict, warnings, ___iced_passed_deferral
, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg
.data, strict = _arg.strict, now = _arg.now;
  literals = null;
  err = msg = warnings = esk = null;
  if (armored != null) {
    _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];
  } else if (raw != null) {
    msg_type || (msg_type = C.message_types.generic);
    msg = {
      body: raw,
      type: msg_type
    };
  } else {
    err = new Error(&#x22;No input to do_message; need either &#x27;armored&#x27; or &#x27;raw&#x27; input&#x22;);
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        if (strict == null) {
          strict = true;
        }
        proc = new Message({
          keyfetch: keyfetch,
          data_fn: data_fn,
          data: data,
          strict: strict,
          now: now
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;
          });
          proc.parse_and_process(msg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 409
          }));
          __iced_deferrals._fulfill();
        })(function() {
          warnings = proc.warnings;
          return __iced_k(esk = proc.encryption_subkey);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals, warnings, esk);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.processor.KeyBlock" id="apidoc.module.kbpgp.processor.KeyBlock">module kbpgp.processor.KeyBlock</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.KeyBlock" id="apidoc.element.kbpgp.processor.KeyBlock.KeyBlock">
        function <span class="apidocSignatureSpan">kbpgp.processor.</span>KeyBlock
        <span class="apidocSignatureSpan">(packets, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyBlock(packets, opts) {
  this.packets = packets;
  this.verified_signatures = [];
  this.subkeys = [];
  this.primary = null;
  this.userids = [];
  this.user_attributes = [];
  this.warnings = new Warnings();
  this.opts = opts || {};
  if (this.opts.strict == null) {
    this.opts.strict = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.processor.KeyBlock.prototype" id="apidoc.module.kbpgp.processor.KeyBlock.prototype">module kbpgp.processor.KeyBlock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_issuer" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._check_issuer">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_issuer
        <span class="apidocSignatureSpan">(i, packet, primary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_issuer = function (i, packet, primary) {
  var fp, iid, pid, wanted;
  if ((fp = packet.get_issuer_fingerprint()) != null) {
    if (bufeq_secure(fp, (wanted = this.primary.get_fingerprint()))) {
      return wanted;
    } else {
      this.warnings.push(&#x22;Skipping signature by another issuer: &#x22; + (fp.toString(&#x27;hex&#x27;)) + &#x22; != &#x22; + (wanted != null ? wanted.toString
(&#x27;hex&#x27;) : void 0));
      return null;
    }
  }
  if ((iid = packet.get_issuer_key_id()) != null) {
    if (bufeq_secure(iid, (pid = this.primary.get_key_id()))) {
      return pid;
    } else {
      this.warnings.push(&#x22;Skipping signature by another issuer: &#x22; + (iid != null ? iid.toString(&#x27;hex&#x27;) : void 0) + &#x22; != &#x22; + (pid
 != null ? pid.toString(&#x27;hex&#x27;) : void 0));
      return null;
    }
  }
  this.warnings.push(&#x22;Signature is missing an issuer (at packet=&#x22; + i + &#x22;)&#x22;);
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_keys" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._check_keys">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_keys = function () {
  return this._check_primary() || this._check_subkeys();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_primary" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._check_primary">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_primary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_primary = function () {
  var err;
  return err = !this.primary.is_self_signed() ? new Error(&#x22;no valid primary key self-signature or key(s) have expired&#x22;) : (this.
userids = this.primary.get_signed_userids()).length === 0 ? new Error(&#x22;no valid Userid signed into key&#x22;) : (this.user_attributes
 = this.primary.get_signed_user_attributes(), null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._check_subkeys" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._check_subkeys">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_check_subkeys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_subkeys = function () {
  var err, i, k, msg, subkeys, _i, _len;
  subkeys = this.subkeys;
  err = null;
  this.subkeys = [];
  for (i = _i = 0, _len = subkeys.length; _i &#x3c; _len; i = ++_i) {
    k = subkeys[i];
    if (err == null) {
      if (k.is_signed_subkey_of(this.primary, this.opts)) {
        this.subkeys.push(k);
      } else {
        msg = &#x22;Subkey &#x22; + i + &#x22; was invalid; discarding&#x22;;
        this.warnings.push(msg);
      }
    }
  }
  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._extract_keys" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._extract_keys">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_extract_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_extract_keys = function () {
  var err, i, p, _i, _len, _ref1;
  err = null;
  if (!this.packets.length) {
    err = new Error(&#x22;No packets; cannot extract a key&#x22;);
  } else if (!(this.primary = this.packets[0]).is_primary()) {
    err = new Error(&#x22;First packet must be the primary key&#x22;);
  } else {
    _ref1 = this.packets.slice(1);
    for (i = _i = 0, _len = _ref1.length; _i &#x3c; _len; i = ++_i) {
      p = _ref1[i];
      if (p.is_key_material() &#x26;&#x26; (err == null)) {
        if (p.key.is_toxic()) {
          this.warnings.push(&#x22;Ignoring toxic subkey (ElGamal Encrypt+Sign)&#x22;);
        } else if (!p.is_primary()) {
          this.subkeys.push(p);
        } else if (bufeq_secure(p.get_fingerprint(), this.primary.get_fingerprint())) {
          p.set_duplicate_primary();
        } else {
          err = new Error(&#x22;cannot have 2 primary keys&#x22;);
        }
      }
    }
  }
  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype._verify_sigs" id="apidoc.element.kbpgp.processor.KeyBlock.prototype._verify_sigs">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>_verify_sigs
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify_sigs = function (cb) {
  var err, i, issuer_id, msg, n_sigs, p, tmp, working_set, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  working_set = [];
  n_sigs = 0;
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref1, _results, _while;
      _ref1 = _this.packets.slice(1);
      _len = _ref1.length;
      i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(i &#x3c; _len)) {
          return _break();
        } else {
          p = _ref1[i];
          if (err == null) {
            (function(__iced_k) {
              if (!p.is_signature()) {
                if (n_sigs &#x3e; 0) {
                  n_sigs = 0;
                  working_set = [];
                }
                if (!p.is_duplicate_primary()) {
                  working_set.push(p);
                }
                (function(__iced_k) {
_continue()
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              n_sigs++;
              (function(__iced_k) {
                if ((issuer_id = _this._check_issuer(i, p, _this.primary)) != null) {
                  p.key = _this.primary.key;
                  p.primary = _this.primary;
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
                      funcname: &#x22;KeyBlock._verify_sigs&#x22;
                    });
                    p.verify(working_set, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return tmp = arguments[0];
                        };
                      })(),
                      lineno: 132
                    }), _this.opts);
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(typeof tmp !== &#x22;undefined&#x22; &#x26;&#x26; tmp !== null ? (msg = &#x22;Signature failure in packet &#x22; + i + &#x22;: &#x22; +
tmp.message + &#x22; (&#x22; + (issuer_id.toString(&#x27;hex&#x27;)) + &#x22;)&#x22;, _this.warnings.push(msg)) : _this.verified_signatures.push(p));
                  });
                } else {
                  return __iced_k();
                }
              })(_next);
            });
          } else {
            return _continue();
          }
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype.process" id="apidoc.element.kbpgp.processor.KeyBlock.prototype.process">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>process
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (cb) {
  var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = this._extract_keys();
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;KeyBlock.process&#x22;
          });
          _this._verify_sigs(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 87
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      var _ref1;
      if (!((err != null) || ((_ref1 = _this.opts) != null ? _ref1.no_check_keys : void 0))) {
        err = _this._check_keys();
      }
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
kb = new KeyBlock(packets, opts);
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/michal/kbpgp/src/openpgp/keymanager.iced&#x22;,
    funcname: &#x22;KeyManager.import_from_pgp_message&#x22;
  });
  kb.<span class="apidocCodeKeywordSpan">process</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return err = arguments[0];
      };
    })(),
    lineno: 621
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.KeyBlock.prototype.to_obj" id="apidoc.element.kbpgp.processor.KeyBlock.prototype.to_obj">
        function <span class="apidocSignatureSpan">kbpgp.processor.KeyBlock.prototype.</span>to_obj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_obj = function () {
  return {
    subkeys: this.subkeys,
    primary: this.primary,
    userids: this.userids
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.processor.Message" id="apidoc.module.kbpgp.processor.Message">module kbpgp.processor.Message</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.Message" id="apidoc.element.kbpgp.processor.Message.Message">
        function <span class="apidocSignatureSpan">kbpgp.processor.</span>Message
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(_arg) {
  this.keyfetch = _arg.keyfetch, this.data_fn = _arg.data_fn, this.data = _arg.data, this.strict = _arg.strict, this.now = _arg.
now;
  this.literals = [];
  this.enc_data_packet = null;
  this.warnings = new Warnings();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {
var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;
__iced_k = __iced_k_noop;
___iced_passed_deferral = iced.findDeferral(arguments);
body = _arg.body;
esc = make_esc(cb, &#x22;get_payload_from_raw_sig_body&#x22;);
payload = null;
m = new processor.<span class="apidocCodeKeywordSpan">Message</span>({});
(function(_this) {
  return (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
      funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.processor.Message.prototype" id="apidoc.module.kbpgp.processor.Message.prototype">module kbpgp.processor.Message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._decrypt" id="apidoc.element.kbpgp.processor.Message.prototype._decrypt">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_decrypt
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decrypt = function (cb) {
  var edat, err, esc, is_enc, packets, pkcs5, plaintext, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  esc = make_esc(cb, &#x22;Message::decrypt&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
        funcname: &#x22;Message._decrypt&#x22;
      });
      _this._get_session_key(esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            is_enc = arguments[0];
            sesskey = arguments[1];
            return pkcs5 = arguments[2];
          };
        })(),
        lineno: 215
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (is_enc) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._decrypt&#x22;
            });
            _this._find_encrypted_data(esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return edat = arguments[0];
                };
              })(),
              lineno: 217
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
                funcname: &#x22;Message._decrypt&#x22;
              });
              _this._decrypt_with_session_key(sesskey, edat, pkcs5, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return plaintext = arguments[0];
                  };
                })(),
                lineno: 218
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
                  funcname: &#x22;Message._decrypt&#x22;
                });
                _this._parse(plaintext, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return packets = arguments[0];
                    };
                  })(),
                  lineno: 219
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(_this.packets = packets.concat(_this.packets));
              });
            });
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._decrypt_with_session_key" id="apidoc.element.kbpgp.processor.Message.prototype._decrypt_with_session_key">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_decrypt_with_session_key
        <span class="apidocSignatureSpan">(sesskey, edat, pkcs5, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decrypt_with_session_key = function (sesskey, edat, pkcs5, cb) {
  var cipher, err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  _ref1 = katch(function() {
    return import_key_pgp(sesskey, pkcs5);
  }), err = _ref1[0], cipher = _ref1[1];
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._decrypt_with_session_key&#x22;
          });
          edat.decrypt({
            cipher: cipher
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return ret = arguments[1];
              };
            })(),
            lineno: 201
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._find_encrypted_data" id="apidoc.element.kbpgp.processor.Message.prototype._find_encrypted_data">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_find_encrypted_data
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find_encrypted_data = function (cb) {
  var err, ret;
  err = ret = null;
  if (this.packets.length &#x26;&#x26; (ret = this.packets[0].to_enc_data_packet())) {
    this.packets.pop();
  } else {
    err = new Error(&#x22;Could not find encrypted data packet&#x22;);
  }
  return cb(err, ret);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._frame_signatures" id="apidoc.element.kbpgp.processor.Message.prototype._frame_signatures">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_frame_signatures
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_frame_signatures = function () {
  var o, p, payload, ret, stack, _i, _j, _len, _len1, _ref1;
  ret = [];
  stack = [];
  payload = [];
  _ref1 = this.packets;
  for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
    p = _ref1[_i];
    if (p.tag === C.packet_tags.one_pass_sig) {
      stack.push({
        open: p
      });
    } else if (!stack.length) {

    } else if (p.tag === C.packet_tags.signature) {
      o = stack.pop();
      o.close = p;
      ret.push(o);
    } else {
      payload.push(p);
    }
  }
  for (_j = 0, _len1 = ret.length; _j &#x3c; _len1; _j++) {
    o = ret[_j];
    o.payload = payload;
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._get_session_key" id="apidoc.element.kbpgp.processor.Message.prototype._get_session_key">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_get_session_key
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_get_session_key = function (cb) {
  var enc, err, esk_packets, fingerprint, index, key_ids, key_material, km, p, packet, pkcs5, privk, sesskey, ___iced_passed_deferral
, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key_ids = [];
  esk_packets = [];
  err = null;
  pkcs5 = false;
  key_ids = (function() {
    var _results;
    _results = [];
    while (this.packets.length &#x26;&#x26; (p = this.packets[0].to_esk_packet())) {
      esk_packets.push(p);
      this.packets.shift();
      _results.push(p.get_key_id());
    }
    return _results;
  }).call(this);
  (function(_this) {
    return (function(__iced_k) {
      if (key_ids.length) {
        enc = true;
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._get_session_key&#x22;
          });
          _this.keyfetch.fetch(key_ids, konst.ops.decrypt, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                km = arguments[1];
                return index = arguments[2];
              };
            })(),
            lineno: 173
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if (err == null) {
              packet = esk_packets[index];
              key_material = km.find_pgp_key_material(key_ids[index]);
              fingerprint = key_material.get_fingerprint();
              privk = key_material.key;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
                  funcname: &#x22;Message._get_session_key&#x22;
                });
                privk.decrypt_and_unpad(packet.ekey, {
                  fingerprint: fingerprint
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      sesskey = arguments[1];
                      return pkcs5 = arguments[2];
                    };
                  })(),
                  lineno: 179
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(err == null ? _this.encryption_subkey = key_material : void 0);
              });
            } else {
              return __iced_k();
            }
          })(__iced_k);
        });
      } else {
        return __iced_k(enc = false);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, enc, sesskey, pkcs5);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._inflate" id="apidoc.element.kbpgp.processor.Message.prototype._inflate">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_inflate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inflate = function (cb) {
  var esc, inflated, p, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  packets = [];
  esc = make_esc(cb, &#x22;Message::_inflate&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref1, _results, _while;
      _ref1 = _this.packets;
      _len = _ref1.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          p = _ref1[_i];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._inflate&#x22;
            });
            p.inflate(esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return inflated = arguments[0];
                };
              })(),
              lineno: 229
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (typeof inflated !== &#x22;undefined&#x22; &#x26;&#x26; inflated !== null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
                    funcname: &#x22;Message._inflate&#x22;
                  });
                  _this._parse(inflated, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return p = arguments[0];
                      };
                    })(),
                    lineno: 231
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return __iced_k(packets.push.apply(packets, p));
                });
              } else {
                return __iced_k(packets.push(p));
              }
            })(_next);
          });
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      _this.packets = packets;
      return cb(null);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._parse" id="apidoc.element.kbpgp.processor.Message.prototype._parse">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_parse
        <span class="apidocSignatureSpan">(raw, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parse = function (raw, cb) {
  var err, packets, _ref1;
  _ref1 = parse(raw), err = _ref1[0], packets = _ref1[1];
  return cb(err, packets);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._process" id="apidoc.element.kbpgp.processor.Message.prototype._process">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_process
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_process = function (_arg, cb) {
  var err, literals, msg, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  msg = _arg.msg, packets = _arg.packets;
  msg.type || (msg.type = C.message_types.generic);
  (function(_this) {
    return (function(__iced_k) {
      switch (msg.type) {
        case C.message_types.generic:
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._process&#x22;
            });
            _this._process_generic({
              packets: packets
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return literals = arguments[1];
                };
              })(),
              lineno: 357
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
          break;
        case C.message_types.clearsign:
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._process&#x22;
            });
            _this._verify_clearsign({
              packets: packets,
              clearsign: msg.clearsign
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return literals = arguments[1];
                };
              })(),
              lineno: 359
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
          break;
        case C.message_types.signature:
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._process&#x22;
            });
            _this._verify_signature({
              packets: packets
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return literals = arguments[1];
                };
              })(),
              lineno: 361
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
          break;
        default:
          return __iced_k(err = new Error(&#x22;Needed a &#x27;generic&#x27;, &#x27;clearsign&#x27;, or &#x27;signature&#x27; PGP message, got &#x22; + msg.type));
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._process_generic" id="apidoc.element.kbpgp.processor.Message.prototype._process_generic">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_process_generic
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_process_generic = function (_arg, cb) {
  var esc, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  packets = _arg.packets;
  this.packets = packets;
  esc = make_esc(cb, &#x22;Message:process&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
        funcname: &#x22;Message._process_generic&#x22;
      });
      _this._decrypt(esc(__iced_deferrals.defer({
        lineno: 312
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
          funcname: &#x22;Message._process_generic&#x22;
        });
        _this._inflate(esc(__iced_deferrals.defer({
          lineno: 313
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._process_generic&#x22;
          });
          _this._verify(esc(__iced_deferrals.defer({
            lineno: 314
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null, _this.collect_literals());
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._verify" id="apidoc.element.kbpgp.processor.Message.prototype._verify">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify = function (cb) {
  var esc, sig, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Message::_verify_sigs&#x22;);
  sigs = this._frame_signatures();
  (function(_this) {
    return (function(__iced_k) {
      var _i, _len, _ref1, _results, _while;
      _ref1 = sigs;
      _len = _ref1.length;
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _len)) {
          return _break();
        } else {
          sig = _ref1[_i];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._verify&#x22;
            });
            _this._verify_sig(sig, esc(__iced_deferrals.defer({
              lineno: 299
            })));
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(null);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(function() {
  (function(__iced_k) {
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
      funcname: &#x22;Verifier.run&#x22;
    });
    _this.<span class="apidocCodeKeywordSpan">_verify</span>(esc(__iced_deferrals.defer({
      lineno: 204
    })));
    __iced_deferrals._fulfill();
  })(function() {
    return cb(null, _this._literal);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._verify_clearsign" id="apidoc.element.kbpgp.processor.Message.prototype._verify_clearsign">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_clearsign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify_clearsign = function (_arg, cb) {
  var clearsign, err, literal, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  packets = _arg.packets, clearsign = _arg.clearsign;
  (function(_this) {
    return (function(__iced_k) {
      if (clearsign == null) {
        return __iced_k(err = new Error(&#x22;no clearsign data found&#x22;));
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._verify_clearsign&#x22;
          });
          verify_clearsign({
            packets: packets,
            clearsign: clearsign,
            keyfetch: _this.keyfetch
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literal = arguments[1];
              };
            })(),
            lineno: 323
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, [literal]);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._verify_sig" id="apidoc.element.kbpgp.processor.Message.prototype._verify_sig">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_sig
        <span class="apidocSignatureSpan">(sig, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify_sig = function (sig, cb) {
  var a, b, err, i, key_material, km, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  err = null;
  if (!bufeq_secure((a = sig.open.key_id), (b = sig.close.get_key_id()))) {
    err = new Error(&#x22;signature mismatch open v close: &#x22; + (a != null ? a.toString(&#x27;hex&#x27;) : void 0) + &#x22; != &#x22; + (b != null ? b.toString
(&#x27;hex&#x27;) : void 0));
  }
  (function(_this) {
    return (function(__iced_k) {
      if (err == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._verify_sig&#x22;
          });
          _this.keyfetch.fetch([a], konst.ops.verify, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                km = arguments[1];
                return i = arguments[2];
              };
            })(),
            lineno: 270
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(err != null ? err = new Error(&#x22;Can&#x27;t find a key for &#x22; + (a.toString(&#x27;hex&#x27;)) + &#x22;: &#x22; + err.message) : void
 0);
        });
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          key_material = km.find_pgp_key_material(a);
          sig.close.key = key_material.key;
          sig.close.subkey_material = key_material;
          sig.close.key_manager = km;
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
              funcname: &#x22;Message._verify_sig&#x22;
            });
            sig.close.verify(sig.payload, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 285
            }), {
              now: _this.now
            });
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k(!_this.strict ? (_this.warnings.push(&#x22;Problem fetching key &#x22; + (a.toString(&#x27;hex&#x27;)) + &#x22;: &#x22; + (err.toString
())), err = null) : void 0);
        }
      })(function() {
        return cb(err);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype._verify_signature" id="apidoc.element.kbpgp.processor.Message.prototype._verify_signature">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>_verify_signature
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verify_signature = function (_arg, cb) {
  var err, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  packets = _arg.packets;
  (function(_this) {
    return (function(__iced_k) {
      if (!((_this.data != null) || (_this.data_fn != null))) {
        return __iced_k(err = new Error(&#x22;Cannot verify detached signature without data input&#x22;));
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
            funcname: &#x22;Message._verify_signature&#x22;
          });
          verify_detached({
            packets: packets,
            data: _this.data,
            data_fn: _this.data_fn,
            keyfetch: _this.keyfetch
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 348
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, literals);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype.collect_literals" id="apidoc.element.kbpgp.processor.Message.prototype.collect_literals">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>collect_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collect_literals = function () {
  var p, _i, _len, _ref1, _results;
  _ref1 = this.packets;
  _results = [];
  for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
    p = _ref1[_i];
    if (p.tag === C.packet_tags.literal) {
      _results.push(p);
    }
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype.parse_and_inflate" id="apidoc.element.kbpgp.processor.Message.prototype.parse_and_inflate">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>parse_and_inflate
        <span class="apidocSignatureSpan">(body, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_and_inflate = function (body, cb) {
  var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Message::parse_and_inflate&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
        funcname: &#x22;Message.parse_and_inflate&#x22;
      });
      _this._parse(body, esc(__iced_deferrals.defer({
        assign_fn: (function(__slot_1) {
          return function() {
            return __slot_1.packets = arguments[0];
          };
        })(_this),
        lineno: 330
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
          funcname: &#x22;Message.parse_and_inflate&#x22;
        });
        _this._inflate(esc(__iced_deferrals.defer({
          lineno: 331
        })));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(null, _this.collect_literals());
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.get_unverified_payload_from_raw_sig_body&#x22;
  });
  m.<span class="apidocCodeKeywordSpan">parse_and_inflate</span>(body, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return literals = arguments[0];
      };
    })(),
    lineno: 48
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.processor.Message.prototype.parse_and_process" id="apidoc.element.kbpgp.processor.Message.prototype.parse_and_process">
        function <span class="apidocSignatureSpan">kbpgp.processor.Message.prototype.</span>parse_and_process
        <span class="apidocSignatureSpan">(msg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_and_process = function (msg, cb) {
  var esc, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  esc = make_esc(cb, &#x22;Message::parse_and_process&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
        funcname: &#x22;Message.parse_and_process&#x22;
      });
      _this._parse(msg.body, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return packets = arguments[0];
          };
        })(),
        lineno: 338
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/home/michal/kbpgp/src/openpgp/processor.iced&#x22;,
          funcname: &#x22;Message.parse_and_process&#x22;
        });
        _this._process({
          msg: msg,
          packets: packets
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return literals = arguments[0];
            };
          })(),
          lineno: 339
        })));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(null, literals);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
eng = new processor.Message(opts);
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.unbox&#x22;
  });
  eng.<span class="apidocCodeKeywordSpan">parse_and_process</span>({
    body: msg.body
  }, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return literals = arguments[0];
      };
    })(),
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.rand" id="apidoc.module.kbpgp.rand">module kbpgp.rand</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.rand.MRF" id="apidoc.element.kbpgp.rand.MRF">
        function <span class="apidocSignatureSpan">kbpgp.rand.</span>MRF
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MRF = function () {
  if (_mrf == null) {
    _mrf = new MediumRandomFountain();
  }
  return _mrf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.rand.SRF" id="apidoc.element.kbpgp.rand.SRF">
        function <span class="apidocSignatureSpan">kbpgp.rand.</span>SRF
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SRF = function () {
  if (_srf == null) {
    _srf = new StrongRandomFountain();
  }
  return _srf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.rfc3394" id="apidoc.module.kbpgp.rfc3394">module kbpgp.rfc3394</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.rfc3394.unwrap" id="apidoc.element.kbpgp.rfc3394.unwrap">
        function <span class="apidocSignatureSpan">kbpgp.rfc3394.</span>unwrap
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (_arg) {
  var A, AES, B, C, P, R, cipher, ciphertext, err, i, j, key, n, r, t, _i, _j, _k, _len, _ref;
  ciphertext = _arg.ciphertext, key = _arg.key, cipher = _arg.cipher;
  _ref = setup({
    input: ciphertext,
    key: key,
    cipher: cipher
  }), err = _ref[0], C = _ref[1], AES = _ref[2], n = _ref[3];
  if (err != null) {
    return [err, null];
  }
  A = C[0];
  R = C.slice(1);
  t = new WordArray([0, 6 * R.length]);
  for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
    for (i = _j = R.length - 1; _j &#x3e;= 0; i = _j += -1) {
      r = R[i];
      A.xor(t, {});
      B = A.clone().concat(r);
      AES.decryptBlock(B.words);
      A = B.slice(0, 2);
      R[i] = B.slice(2, 4);
      t.words[1]--;
    }
  }
  if (A.equal(IV)) {
    P = new WordArray([]);
    for (_k = 0, _len = R.length; _k &#x3c; _len; _k++) {
      r = R[_k];
      P.concat(r);
    }
    return [null, P.to_buffer()];
  } else {
    return [new Error(&#x22;integrity check failure; got bad IV in decryption&#x22;), null];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.rfc3394.wrap" id="apidoc.element.kbpgp.rfc3394.wrap">
        function <span class="apidocSignatureSpan">kbpgp.rfc3394.</span>wrap
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (_arg) {
  var A, AES, B, C, P, R, cipher, err, i, j, key, plaintext, r, t, _i, _j, _k, _len, _len1, _ref;
  plaintext = _arg.plaintext, key = _arg.key, cipher = _arg.cipher;
  _ref = setup({
    input: plaintext,
    key: key,
    cipher: cipher
  }), err = _ref[0], P = _ref[1], AES = _ref[2];
  if (err != null) {
    throw err;
  }
  A = IV;
  R = P;
  t = new WordArray([0, 0]);
  for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
    for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
      r = R[i];
      t.words[1]++;
      B = A.clone().concat(r);
      AES.encryptBlock(B.words);
      A = B.slice(0, 2);
      R[i] = B.slice(2, 4);
      A.xor(t, {});
    }
  }
  C = A;
  for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
    r = R[_k];
    C.concat(r);
  }
  return C.to_buffer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.rsa" id="apidoc.module.kbpgp.rsa">module kbpgp.rsa</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.rsa.Output" id="apidoc.element.kbpgp.rsa.Output">
        function <span class="apidocSignatureSpan">kbpgp.rsa.</span>Output
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Output(_arg) {
  this.y_mpi = _arg.y_mpi, this.y_buf = _arg.y_buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.rsa.Pair" id="apidoc.element.kbpgp.rsa.Pair">
        function <span class="apidocSignatureSpan">kbpgp.rsa.</span>Pair
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.rsa.RSA" id="apidoc.element.kbpgp.rsa.RSA">
        function <span class="apidocSignatureSpan">kbpgp.rsa.</span>RSA
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pair(_arg) {
  var priv, pub;
  priv = _arg.priv, pub = _arg.pub;
  Pair.__super__.constructor.call(this, {
    priv: priv,
    pub: pub
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.s2k" id="apidoc.module.kbpgp.s2k">module kbpgp.s2k</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.s2k.S2K" id="apidoc.element.kbpgp.s2k.S2K">
        function <span class="apidocSignatureSpan">kbpgp.s2k.</span>S2K
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function S2K() {
  this.hash = SHA256;
  this.streamer = streamers.SHA256();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.s2k.SecretKeyMaterial" id="apidoc.element.kbpgp.s2k.SecretKeyMaterial">
        function <span class="apidocSignatureSpan">kbpgp.s2k.</span>SecretKeyMaterial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKeyMaterial() {
  this.s2k_convention = null;
  this.s2k = null;
  this.iv = null;
  this.cipher = null;
  this.payload = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.sigeng" id="apidoc.module.kbpgp.sigeng">module kbpgp.sigeng</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.sigeng.SignatureEngine" id="apidoc.element.kbpgp.sigeng.SignatureEngine">
        function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>SignatureEngine
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SignatureEngine(_arg) {
  this.km = _arg.km;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.sigeng.decode_sig" id="apidoc.element.kbpgp.sigeng.decode_sig">
        function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>decode_sig
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode_sig = function (_arg) {
  var armored, err, msg, mt, _ref;
  armored = _arg.armored;
  _ref = decode(armored), err = _ref[0], msg = _ref[1];
  mt = C.openpgp.message_types;
  if ((err == null) &#x26;&#x26; (msg.type !== mt.generic)) {
    err = new Error(&#x22;wrong message type; expected a generic message; got &#x22; + msg.type);
  }
  return [err, msg];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.sigeng.get_sig_body" id="apidoc.element.kbpgp.sigeng.get_sig_body">
        function <span class="apidocSignatureSpan">kbpgp.sigeng.</span>get_sig_body
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_sig_body = function (_arg) {
  var armored, err, msg, res, _ref;
  armored = _arg.armored;
  res = null;
  _ref = decode_sig({
    armored: armored
  }), err = _ref[0], msg = _ref[1];
  if (err == null) {
    res = msg.body;
  }
  return [err, res];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.symmetric" id="apidoc.module.kbpgp.symmetric">module kbpgp.symmetric</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.symmetric.checksum2" id="apidoc.element.kbpgp.symmetric.checksum2">
        function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>checksum2
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checksum2 = function (buf) {
  var i, res, _i, _ref;
  res = 0;
  for (i = _i = 0, _ref = buf.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    res = (res + buf.readUInt8(i)) &#x26; 0xffff;
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.symmetric.export_key_pgp" id="apidoc.element.kbpgp.symmetric.export_key_pgp">
        function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>export_key_pgp
        <span class="apidocSignatureSpan">(algo_id, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export_key_pgp = function (algo_id, key) {
  var csum;
  csum = checksum2(key);
  return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.symmetric.get_cipher" id="apidoc.element.kbpgp.symmetric.get_cipher">
        function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>get_cipher
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_cipher = function (n) {
  var ret;
  n || (n = C.AES256);
  ret = (function() {
    switch (n) {
      case C.AES128:
        return {
          klass: AES,
          key_size: 16
        };
      case C.AES192:
        return {
          klass: AES,
          key_size: 24
        };
      case C.AES256:
        return {
          klass: AES,
          key_size: 32
        };
      case C.CAST5:
        return {
          klass: CAST5,
          key_size: CAST5.keySize
        };
      default:
        throw new Error(&#x22;unknown cipher: &#x22; + n);
    }
  })();
  ret.type = n;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Pub.type = Const.public_key_algorithms.ECDH;

Pub.prototype.type = Pub.type;

Pub.prototype.apply_defaults = function() {
  this.cipher || (this.cipher = sym.<span class="apidocCodeKeywordSpan">get_cipher</span>());
  return this.hasher || (this.hasher = hashmod.SHA512);
};

Pub.prototype.read_params = function(sb) {
  var n, size, v, val;
  if ((size = sb.read_uint8()) &#x3c; (n = Const.ecdh.param_bytes)) {
    throw new Error(&#x22;Need at least &#x22; + n + &#x22; bytes of params; got &#x22; + size);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.symmetric.import_key_pgp" id="apidoc.element.kbpgp.symmetric.import_key_pgp">
        function <span class="apidocSignatureSpan">kbpgp.symmetric.</span>import_key_pgp
        <span class="apidocSignatureSpan">(msg, pkcs5_padding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_key_pgp = function (msg, pkcs5_padding) {
  var checksum, cipher, err, key, ret, sb;
  if (pkcs5_padding == null) {
    pkcs5_padding = false;
  }
  sb = new SlicerBuffer(msg);
  ret = err = null;
  cipher = get_cipher(sb.read_uint8());
  key = sb.read_buffer(cipher.key_size);
  checksum = sb.read_uint16();
  err = checksum2(key) !== checksum ? new Error(&#x22;Checksum mismatch&#x22;) : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset()) : !
sb.rem() ? null : new Error(&#x22;Junk at the end of input&#x22;);
  if (err != null) {
    throw err;
  }
  return new cipher.klass(WordArray.from_buffer(key));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec" id="apidoc.module.kbpgp.triplesec">module kbpgp.triplesec</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base" id="apidoc.element.kbpgp.triplesec.Base">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Base
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Base(_arg) {
  var key, version;
  key = _arg.key, version = _arg.version;
  this.version = V[version != null ? version : CURRENT_VERSION];
  if (this.version == null) {
    throw new Error(&#x22;unknown version: &#x22; + version);
  }
  this.set_key(key);
  this.derived_keys = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Buffer" id="apidoc.element.kbpgp.triplesec.Buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === &#x27;number&#x27;) {
    if (typeof encodingOrOffset === &#x27;string&#x27;) {
      throw new Error(
        &#x27;If encoding is specified then the first argument must be a string&#x27;
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor" id="apidoc.element.kbpgp.triplesec.Decryptor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Decryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decryptor(_arg) {
  var enc, key;
  key = _arg.key, enc = _arg.enc;
  Decryptor.__super__.constructor.call(this, {
    key: key
  });
  if (enc != null) {
    this.key = enc.key;
    this.derived_keys = enc.derived_keys;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor" id="apidoc.element.kbpgp.triplesec.Encryptor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Encryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encryptor(_arg) {
  var key, rng, version;
  key = _arg.key, rng = _arg.rng, version = _arg.version;
  Encryptor.__super__.constructor.call(this, {
    key: key,
    version: version
  });
  this.rng = rng || prng.generate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC" id="apidoc.element.kbpgp.triplesec.HMAC">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC
        <span class="apidocSignatureSpan">(key, klass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC(key, klass) {
  var i, _i, _ref;
  if (klass == null) {
    klass = SHA512;
  }
  this.key = key.clone();
  this.hasher = new klass();
  this.hasherBlockSize = this.hasher.blockSize;
  this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
  if (this.key.sigBytes &#x3e; this.hasherBlockSizeBytes) {
    this.key = this.hasher.finalize(this.key);
  }
  this.key.clamp();
  this._oKey = this.key.clone();
  this._iKey = this.key.clone();
  for (i = _i = 0, _ref = this.hasherBlockSize; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    this._oKey.words[i] ^= 0x5c5c5c5c;
    this._iKey.words[i] ^= 0x36363636;
  }
  this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256" id="apidoc.element.kbpgp.triplesec.HMAC_SHA256">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC_SHA256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC_SHA256(key) {
  HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray" id="apidoc.element.kbpgp.triplesec.WordArray">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>WordArray
        <span class="apidocSignatureSpan">(words, sigBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WordArray(words, sigBytes) {
  this.words = words || [];
  this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.decrypt" id="apidoc.element.kbpgp.triplesec.decrypt">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>decrypt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (_arg, cb) {
  var data, dec, err, key, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key = _arg.key, data = _arg.data, progress_hook = _arg.progress_hook;
  dec = new Decryptor({
    key: key
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;
      });
      dec.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return pt = arguments[1];
          };
        })(),
        lineno: 180
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      dec.scrub();
      return cb(err, pt);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.decrypt_and_unpad&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">decrypt</span>(ciphertext.c(), __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return m = arguments[1];
      };
    })(),
    lineno: 122
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.encrypt" id="apidoc.element.kbpgp.triplesec.encrypt">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>encrypt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (_arg, cb) {
  var data, enc, err, key, progress_hook, ret, rng, version, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key = _arg.key, data = _arg.data, rng = _arg.rng, progress_hook = _arg.progress_hook, version = _arg.version;
  enc = new Encryptor({
    key: key,
    rng: rng,
    version: version
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;
      });
      enc.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return ret = arguments[1];
          };
        })(),
        lineno: 475
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      enc.scrub();
      return cb(err, ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/elgamal.iced&#x22;,
    funcname: &#x22;Pair.pad_and_encrypt&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">encrypt</span>(m, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return c_mpis = arguments[0];
      };
    })(),
    lineno: 114
  }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.pbkdf2" id="apidoc.element.kbpgp.triplesec.pbkdf2">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>pbkdf2
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2 = function (_arg, cb) {
  var c, dkLen, eng, key, klass, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key = _arg.key, salt = _arg.salt, klass = _arg.klass, c = _arg.c, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
  eng = new PBKDF2({
    klass: klass,
    c: c
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/pbkdf2.iced&#x22;
      });
      eng.run({
        key: key,
        salt: salt,
        dkLen: dkLen,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return out = arguments[0];
          };
        })(),
        lineno: 106
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(out);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.scrypt" id="apidoc.element.kbpgp.triplesec.scrypt">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>scrypt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrypt = function (_arg, cb) {
  var N, c, c0, c1, dkLen, eng, key, klass, p, progress_hook, r, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key = _arg.key, salt = _arg.salt, r = _arg.r, N = _arg.N, p = _arg.p, c0 = _arg.c0, c1 = _arg.c1, c = _arg.c, klass = _arg.klass
, progress_hook = _arg.progress_hook, dkLen = _arg.dkLen;
  eng = new Scrypt({
    r: r,
    N: N,
    p: p,
    c: c,
    c0: c0,
    c1: c1,
    klass: klass
  });
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/scrypt.iced&#x22;
      });
      eng.run({
        key: key,
        salt: salt,
        progress_hook: progress_hook,
        dkLen: dkLen
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return wa = arguments[0];
          };
        })(),
        lineno: 263
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(wa);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Base" id="apidoc.module.kbpgp.triplesec.Base">module kbpgp.triplesec.Base</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.Base" id="apidoc.element.kbpgp.triplesec.Base.Base">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Base
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Base(_arg) {
  var key, version;
  key = _arg.key, version = _arg.version;
  this.version = V[version != null ? version : CURRENT_VERSION];
  if (this.version == null) {
    throw new Error(&#x22;unknown version: &#x22; + version);
  }
  this.set_key(key);
  this.derived_keys = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Base.prototype" id="apidoc.module.kbpgp.triplesec.Base.prototype">module kbpgp.triplesec.Base.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype._check_scrubbed" id="apidoc.element.kbpgp.triplesec.Base.prototype._check_scrubbed">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>_check_scrubbed
        <span class="apidocSignatureSpan">(key, where, ecb, okcb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_check_scrubbed = function (key, where, ecb, okcb) {
  if ((key != null) &#x26;&#x26; !key.is_scrubbed()) {
    return okcb();
  } else {
    return ecb(new Error(&#x22;&#x22; + where + &#x22;: Failed due to scrubbed key!&#x22;), null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.clone_derived_keys" id="apidoc.element.kbpgp.triplesec.Base.prototype.clone_derived_keys">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>clone_derived_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone_derived_keys = function () {
  var algo, key, key_ring, ret, salt, _ref1;
  ret = null;
  if (this.derived_keys != null) {
    ret = {};
    _ref1 = this.derived_keys;
    for (salt in _ref1) {
      key_ring = _ref1[salt];
      ret[salt] = {};
      for (algo in key_ring) {
        key = key_ring[algo];
        ret[salt][algo] = algo === &#x27;extra&#x27; ? key : key.clone();
      }
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.kdf" id="apidoc.element.kbpgp.triplesec.Base.prototype.kdf">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>kdf
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kdf = function (_arg, cb) {
  var args, dkLen, end, extra_keymaterial, i, k, key, keys, len, lens, order, progress_hook, raw, salt, salt_hex, v, ___iced_passed_deferral
, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
        funcname: &#x22;Base.kdf&#x22;
      });
      _this._check_scrubbed(_this.key, &#x22;in KDF&#x22;, cb, __iced_deferrals.defer({
        lineno: 97
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      salt_hex = salt.to_hex();
      key = _this.key.clone();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Base.kdf&#x22;
        });
        _this._check_scrubbed(key, &#x22;KDF&#x22;, cb, __iced_deferrals.defer({
          lineno: 105
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if ((keys = _this.derived_keys[salt_hex]) == null) {
            _this._kdf = new _this.version.kdf.klass(_this.version.kdf.opts);
            lens = {
              hmac: _this.version.hmac_key_size,
              aes: AES.keySize,
              twofish: TwoFish.keySize,
              salsa20: salsa20.Salsa20.keySize
            };
            order = [&#x27;hmac&#x27;, &#x27;aes&#x27;, &#x27;twofish&#x27;, &#x27;salsa20&#x27;];
            dkLen = extra_keymaterial || 0;
            for (k in lens) {
              v = lens[k];
              dkLen += v;
            }
            args = {
              dkLen: dkLen,
              key: key,
              progress_hook: progress_hook,
              salt: salt
            };
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
                funcname: &#x22;Base.kdf&#x22;
              });
              _this._kdf.run(args, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return raw = arguments[0];
                  };
                })(),
                lineno: 124
              }));
              __iced_deferrals._fulfill();
            })(function() {
              var _i, _len;
              keys = {};
              i = 0;
              for (_i = 0, _len = order.length; _i &#x3c; _len; _i++) {
                k = order[_i];
                v = lens[k];
                len = v / 4;
                end = i + len;
                keys[k] = new WordArray(raw.words.slice(i, end));
                i = end;
              }
              keys.extra = (new WordArray(raw.words.slice(end))).to_buffer();
              return __iced_k(_this.derived_keys[salt_hex] = keys);
            });
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(null, keys);
        });
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    __iced_deferrals._fulfill();
  });
})(this)((function(_this) {
  return function() {
    params = _this.format_params({
      fingerprint: fingerprint
    });
    key = _this.<span class="apidocCodeKeywordSpan">kdf</span>({
      X: S,
      params: params
    });
    C = wrap({
      key: key,
      plaintext: m,
      cipher: _this.cipher
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_aes" id="apidoc.element.kbpgp.triplesec.Base.prototype.run_aes">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_aes
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run_aes = function (_arg, cb) {
  var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
        funcname: &#x22;Base.run_aes&#x22;
      });
      _this._check_scrubbed(key, &#x22;AES&#x22;, cb, __iced_deferrals.defer({
        lineno: 252
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      block_cipher = new AES(key);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Base.run_aes&#x22;
        });
        ctr.bulk_encrypt({
          block_cipher: block_cipher,
          iv: iv,
          input: input,
          progress_hook: progress_hook,
          what: &#x22;aes&#x22;
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ct = arguments[0];
            };
          })(),
          lineno: 254
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher.scrub();
        return cb(null, iv.clone().concat(ct));
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_salsa20" id="apidoc.element.kbpgp.triplesec.Base.prototype.run_salsa20">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_salsa20
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run_salsa20 = function (_arg, cb) {
  var args, ct, input, iv, key, output_iv, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  input = _arg.input, key = _arg.key, iv = _arg.iv, output_iv = _arg.output_iv, progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
        funcname: &#x22;Base.run_salsa20&#x22;
      });
      _this._check_scrubbed(key, &#x22;Salsa20&#x22;, cb, __iced_deferrals.defer({
        lineno: 200
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      args = {
        input: input,
        progress_hook: progress_hook,
        key: key,
        iv: iv
      };
      if (_this.version.xsalsa20_rev) {
        args.key = key.clone().endian_reverse();
        args.iv = iv.clone().endian_reverse();
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Base.run_salsa20&#x22;
        });
        salsa20.bulk_encrypt(args, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ct = arguments[0];
            };
          })(),
          lineno: 212
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (output_iv) {
          ct = iv.clone().concat(ct);
        }
        if (_this.version.xsalsa20_rev) {
          args.key.scrub();
          args.iv.scrub();
        }
        return cb(null, ct);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.run_twofish" id="apidoc.element.kbpgp.triplesec.Base.prototype.run_twofish">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>run_twofish
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run_twofish = function (_arg, cb) {
  var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
        funcname: &#x22;Base.run_twofish&#x22;
      });
      _this._check_scrubbed(key, &#x22;TwoFish&#x22;, cb, __iced_deferrals.defer({
        lineno: 235
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      block_cipher = new TwoFish(key);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Base.run_twofish&#x22;
        });
        ctr.bulk_encrypt({
          block_cipher: block_cipher,
          iv: iv,
          input: input,
          progress_hook: progress_hook,
          what: &#x22;twofish&#x22;
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ct = arguments[0];
            };
          })(),
          lineno: 237
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher.scrub();
        return cb(null, iv.clone().concat(ct));
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.scrub" id="apidoc.element.kbpgp.triplesec.Base.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  var algo, key, key_ring, salt, _ref1;
  if (this.key != null) {
    this.key.scrub();
  }
  if (this.derived_keys != null) {
    _ref1 = this.derived_keys;
    for (salt in _ref1) {
      key_ring = _ref1[salt];
      for (algo in key_ring) {
        key = key_ring[algo];
        if (algo !== &#x27;extra&#x27;) {
          key.scrub();
        }
      }
    }
  }
  this.derived_keys = {};
  if (this.salt != null) {
    this.salt.scrub();
  }
  this.salt = null;
  return this.key = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.set_key" id="apidoc.element.kbpgp.triplesec.Base.prototype.set_key">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>set_key
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set_key = function (key) {
  var wakey;
  if (key != null) {
    wakey = WordArray.from_buffer(key);
    if (!this.key || !this.key.equal(wakey)) {
      this.scrub();
      return this.key = wakey;
    }
  } else {
    return this.scrub();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Base.prototype.sign" id="apidoc.element.kbpgp.triplesec.Base.prototype.sign">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Base.prototype.</span>sign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (_arg, cb) {
  var input, key, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  input = _arg.input, key = _arg.key, salt = _arg.salt, progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
        funcname: &#x22;Base.sign&#x22;
      });
      _this._check_scrubbed(key, &#x22;HMAC&#x22;, cb, __iced_deferrals.defer({
        lineno: 182
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      input = (new WordArray(_this.version.header)).concat(salt).concat(input);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Base.sign&#x22;
        });
        Concat.bulk_sign({
          key: key,
          input: input,
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return out = arguments[0];
            };
          })(),
          lineno: 184
        }));
        __iced_deferrals._fulfill();
      })(function() {
        input.scrub();
        return cb(null, out);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Decryptor" id="apidoc.module.kbpgp.triplesec.Decryptor">module kbpgp.triplesec.Decryptor</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.Decryptor" id="apidoc.element.kbpgp.triplesec.Decryptor.Decryptor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Decryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decryptor(_arg) {
  var enc, key;
  key = _arg.key, enc = _arg.enc;
  Decryptor.__super__.constructor.call(this, {
    key: key
  });
  if (enc != null) {
    this.key = enc.key;
    this.derived_keys = enc.derived_keys;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Decryptor.prototype" id="apidoc.module.kbpgp.triplesec.Decryptor.prototype">module kbpgp.triplesec.Decryptor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.clone" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var ret, _ref1;
  ret = new Decryptor({
    key: (_ref1 = this.key) != null ? _ref1.to_buffer() : void 0,
    rng: this.rng,
    version: this.version
  });
  ret.derived_keys = this.clone_derived_keys();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.constructor" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decryptor(_arg) {
  var enc, key;
  key = _arg.key, enc = _arg.enc;
  Decryptor.__super__.constructor.call(this, {
    key: key
  });
  if (enc != null) {
    this.key = enc.key;
    this.derived_keys = enc.derived_keys;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.generate_keys" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.generate_keys">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>generate_keys
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate_keys = function (_arg, cb) {
  var err, keys, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  progress_hook = _arg.progress_hook;
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
        funcname: &#x22;Decryptor.generate_keys&#x22;
      });
      _this.kdf({
        salt: _this.salt,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return keys = arguments[1];
          };
        })(),
        lineno: 114
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, keys);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_header" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_header">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>read_header
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_header = function (cb) {
  var err, wa;
  err = (wa = this.ct.unshift(2)) == null ? new Error(&#x22;Ciphertext underrun in header&#x22;) : (this.version = V[wa.words[1]]) == null
 ? new Error(&#x22;bad header; couldn&#x27;t find a good version (got &#x22; + wa.words[1] + &#x22;)&#x22;) : wa.words[0] !== this.version.header[0] ? new
 Error(&#x22;Bad header: unrecognized magic value&#x22;) : null;
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_salt" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.read_salt">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>read_salt
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_salt = function (cb) {
  var err;
  err = (this.salt = this.ct.unshift(this.version.salt_size / 4)) == null ? new Error(&#x22;Ciphertext underrrun in read_salt&#x22;) : null
;
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.run" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.run">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>run
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (_arg, cb) {
  var ct1, ct2, data, esc, iv, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, progress_hook = _arg.progress_hook;
  esc = make_esc(cb, &#x22;Decryptor::run&#x22;);
  this.ct = WordArray.from_buffer(data);
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
        funcname: &#x22;Decryptor.run&#x22;
      });
      _this.read_header(esc(__iced_deferrals.defer({
        lineno: 141
      })));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
          funcname: &#x22;Decryptor.run&#x22;
        });
        _this.read_salt(esc(__iced_deferrals.defer({
          lineno: 142
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
            funcname: &#x22;Decryptor.run&#x22;
          });
          _this.generate_keys({
            progress_hook: progress_hook
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.keys = arguments[0];
              };
            })(_this),
            lineno: 143
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
              funcname: &#x22;Decryptor.run&#x22;
            });
            _this.verify_sig(_this.keys.hmac, esc(__iced_deferrals.defer({
              lineno: 144
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
                funcname: &#x22;Decryptor.run&#x22;
              });
              _this.unshift_iv(AES.ivSize, &#x22;AES&#x22;, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return iv = arguments[0];
                  };
                })(),
                lineno: 145
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
                  funcname: &#x22;Decryptor.run&#x22;
                });
                _this.run_aes({
                  iv: iv,
                  input: _this.ct,
                  key: _this.keys.aes,
                  progress_hook: progress_hook
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return ct2 = arguments[0];
                    };
                  })(),
                  lineno: 146
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
                    funcname: &#x22;Decryptor.run&#x22;
                  });
                  _this.u ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
    funcname: &#x22;sign&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">run</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        encoded = arguments[1];
        return signature = arguments[2];
      };
    })(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.unshift_iv" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.unshift_iv">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>unshift_iv
        <span class="apidocSignatureSpan">(n_bytes, which, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift_iv = function (n_bytes, which, cb) {
  var err, iv;
  err = (iv = this.ct.unshift(n_bytes / 4)) != null ? null : new Error(&#x22;Ciphertext underrun in &#x22; + which);
  return cb(err, iv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Decryptor.prototype.verify_sig" id="apidoc.element.kbpgp.triplesec.Decryptor.prototype.verify_sig">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Decryptor.prototype.</span>verify_sig
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify_sig = function (key, cb) {
  var computed, err, received, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      if ((received = _this.ct.unshift(Concat.get_output_size() / 4)) == null) {
        return __iced_k(err = new Error(&#x22;Ciphertext underrun in signature&#x22;));
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/dec.iced&#x22;,
            funcname: &#x22;Decryptor.verify_sig&#x22;
          });
          _this.sign({
            input: _this.ct,
            key: key,
            salt: _this.salt
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return computed = arguments[1];
              };
            })(),
            lineno: 63
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(err = err != null ? err : received.equal(computed) ? null : new Error(&#x27;Signature mismatch or bad decryption
 key&#x27;));
        });
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Encryptor" id="apidoc.module.kbpgp.triplesec.Encryptor">module kbpgp.triplesec.Encryptor</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.Encryptor" id="apidoc.element.kbpgp.triplesec.Encryptor.Encryptor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>Encryptor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encryptor(_arg) {
  var key, rng, version;
  key = _arg.key, rng = _arg.rng, version = _arg.version;
  Encryptor.__super__.constructor.call(this, {
    key: key,
    version: version
  });
  this.rng = rng || prng.generate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.Encryptor.prototype" id="apidoc.module.kbpgp.triplesec.Encryptor.prototype">module kbpgp.triplesec.Encryptor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.clone" id="apidoc.element.kbpgp.triplesec.Encryptor.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var ret, _ref1, _ref2;
  ret = new Encryptor({
    key: (_ref1 = this.key) != null ? _ref1.to_buffer() : void 0,
    rng: this.rng,
    version: (_ref2 = this.version) != null ? _ref2.version : void 0
  });
  ret.derived_keys = this.clone_derived_keys();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.constructor" id="apidoc.element.kbpgp.triplesec.Encryptor.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Encryptor(_arg) {
  var key, rng, version;
  key = _arg.key, rng = _arg.rng, version = _arg.version;
  Encryptor.__super__.constructor.call(this, {
    key: key,
    version: version
  });
  this.rng = rng || prng.generate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.pick_random_ivs" id="apidoc.element.kbpgp.triplesec.Encryptor.prototype.pick_random_ivs">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>pick_random_ivs
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pick_random_ivs = function (_arg, cb) {
  var iv_lens, ivs, k, progress_hook, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  progress_hook = _arg.progress_hook;
  iv_lens = {
    aes: AES.ivSize,
    twofish: TwoFish.ivSize,
    salsa20: salsa20.Salsa20.ivSize
  };
  ivs = {};
  (function(_this) {
    return (function(__iced_k) {
      var _i, _k, _keys, _ref1, _results, _while;
      _ref1 = iv_lens;
      _keys = (function() {
        var _results1;
        _results1 = [];
        for (_k in _ref1) {
          _results1.push(_k);
        }
        return _results1;
      })();
      _i = 0;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!(_i &#x3c; _keys.length)) {
          return _break();
        } else {
          k = _keys[_i];
          v = _ref1[k];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
              funcname: &#x22;Encryptor.pick_random_ivs&#x22;
            });
            _this.rng(v, __iced_deferrals.defer({
              assign_fn: (function(__slot_1, __slot_2) {
                return function() {
                  return __slot_1[__slot_2] = arguments[0];
                };
              })(ivs, k),
              lineno: 377
            }));
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      return cb(ivs);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.resalt" id="apidoc.element.kbpgp.triplesec.Encryptor.prototype.resalt">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>resalt
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resalt = function (_arg, cb) {
  var err, extra_keymaterial, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
  err = null;
  (function(_this) {
    return (function(__iced_k) {
      if (salt == null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
            funcname: &#x22;Encryptor.resalt&#x22;
          });
          _this.rng(_this.version.salt_size, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.salt = arguments[0];
              };
            })(_this),
            lineno: 393
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k(salt.length !== _this.version.salt_size ? err = new Error(&#x22;Need a salt of exactly &#x22; + _this.version.salt_size
 + &#x22; bytes (got &#x22; + salt.length + &#x22;)&#x22;) : _this.salt = WordArray.alloc(salt));
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
              funcname: &#x22;Encryptor.resalt&#x22;
            });
            _this.kdf({
              extra_keymaterial: extra_keymaterial,
              progress_hook: progress_hook,
              salt: _this.salt
            }, __iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  err = arguments[0];
                  return __slot_1.keys = arguments[1];
                };
              })(_this),
              lineno: 399
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(err, _this.keys);
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.Encryptor.prototype.run" id="apidoc.element.kbpgp.triplesec.Encryptor.prototype.run">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.Encryptor.prototype.</span>run
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (_arg, cb) {
  var ct1, ct2, ct3, data, esc, extra_keymaterial, ivs, progress_hook, pt, ret, salt, sig, ___iced_passed_deferral, __iced_deferrals
, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  data = _arg.data, salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
  esc = make_esc(cb, &#x22;Encryptor::run&#x22;);
  (function(_this) {
    return (function(__iced_k) {
      if ((salt != null) || (_this.salt == null)) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
            funcname: &#x22;Encryptor.run&#x22;
          });
          _this.resalt({
            salt: salt,
            extra_keymaterial: extra_keymaterial,
            progress_hook: progress_hook
          }, esc(__iced_deferrals.defer({
            lineno: 430
          })));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
          funcname: &#x22;Encryptor.run&#x22;
        });
        _this.pick_random_ivs({
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ivs = arguments[0];
            };
          })(),
          lineno: 431
        }));
        __iced_deferrals._fulfill();
      })(function() {
        pt = WordArray.from_buffer(data);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
            funcname: &#x22;Encryptor.run&#x22;
          });
          _this.run_salsa20({
            input: pt,
            key: _this.keys.salsa20,
            progress_hook: progress_hook,
            iv: ivs.salsa20,
            output_iv: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct1 = arguments[0];
              };
            })(),
            lineno: 433
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
              funcname: &#x22;Encryptor.run&#x22;
            });
            _this.run_twofish({
              input: ct1,
              key: _this.keys.twofish,
              progress_hook: progress_hook,
              iv: ivs.twofish
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ct2 = arguments[0];
                };
              })(),
              lineno: 434
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: &#x22;/Users/max/src/keybase/triplesec/src/enc.iced&#x22;,
                funcname: &#x22;Encryptor.run&#x22;
              });
              _this.run_aes({
                input: ct2,
                key: _this.keys.aes,
                progress_hook: progress_hook,
                iv: ivs.aes
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return ct3 = arguments[0];
                  };
                })(),
                lineno: 435
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (fu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced&#x22;,
    funcname: &#x22;sign&#x22;
  });
  b.<span class="apidocCodeKeywordSpan">run</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        encoded = arguments[1];
        return signature = arguments[2];
      };
    })(),
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.HMAC" id="apidoc.module.kbpgp.triplesec.HMAC">module kbpgp.triplesec.HMAC</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.HMAC" id="apidoc.element.kbpgp.triplesec.HMAC.HMAC">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC
        <span class="apidocSignatureSpan">(key, klass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC(key, klass) {
  var i, _i, _ref;
  if (klass == null) {
    klass = SHA512;
  }
  this.key = key.clone();
  this.hasher = new klass();
  this.hasherBlockSize = this.hasher.blockSize;
  this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
  if (this.key.sigBytes &#x3e; this.hasherBlockSizeBytes) {
    this.key = this.hasher.finalize(this.key);
  }
  this.key.clamp();
  this._oKey = this.key.clone();
  this._iKey = this.key.clone();
  for (i = _i = 0, _ref = this.hasherBlockSize; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    this._oKey.words[i] ^= 0x5c5c5c5c;
    this._iKey.words[i] ^= 0x36363636;
  }
  this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.HMAC.prototype" id="apidoc.module.kbpgp.triplesec.HMAC.prototype">module kbpgp.triplesec.HMAC.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.finalize" id="apidoc.element.kbpgp.triplesec.HMAC.prototype.finalize">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>finalize
        <span class="apidocSignatureSpan">(wa)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function (wa) {
  var innerHash, innerHash2, out;
  innerHash = this.hasher.finalize(wa);
  this.hasher.reset();
  innerHash2 = this._oKey.clone().concat(innerHash);
  out = this.hasher.finalize(innerHash2);
  innerHash.scrub();
  innerHash2.scrub();
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
VerifierBase = require(&#x27;./verifier&#x27;).Base;

packetsigs = require(&#x27;./packet/packetsigs&#x27;);

hash_obj_to_fn = function(obj) {
  var fn;
  fn = function(buf) {
    return obj.<span class="apidocCodeKeywordSpan">finalize</span>(WordArray.from_buffer(buf)).to_buffer();
  };
  return fn.algname = buf.algname;
};

Signer = (function() {
  function Signer(_arg) {
    this.data = _arg.data, this.hash_streamer = _arg.hash_streamer, this.signing_key = _arg.signing_key;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.get_output_size" id="apidoc.element.kbpgp.triplesec.HMAC.prototype.get_output_size">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>get_output_size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_output_size = function () {
  return this.hasher.output_size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.reset" id="apidoc.element.kbpgp.triplesec.HMAC.prototype.reset">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  return this.hasher.reset().update(this._iKey);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

CAST5.prototype.keySize = CAST5.keySize;

function CAST5(key) {
  var n;
  this.masking = new Array(16);
  this.rotate = new Array(16);
  this.<span class="apidocCodeKeywordSpan">reset</span>();
  if (key.sigBytes !== (n = this.keySize)) {
    throw new Error(&#x22;key must be &#x22; + n + &#x22; bytes&#x22;);
  }
  this.keySchedule(key);
}

CAST5.prototype.reset = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.scrub" id="apidoc.element.kbpgp.triplesec.HMAC.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  this.key.scrub();
  this._iKey.scrub();
  return this._oKey.scrub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC.prototype.update" id="apidoc.element.kbpgp.triplesec.HMAC.prototype.update">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC.prototype.</span>update
        <span class="apidocSignatureSpan">(wa)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (wa) {
  this.hasher.update(wa);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Signer.prototype._run_hash = function(cb) {
  var err;
  err = null;
  if (this.hash_streamer != null) {

  } else if (this.data != null) {
    this.hash_streamer = streamers.SHA512();
    this.hash_streamer.<span class="apidocCodeKeywordSpan">update</span>(this.data);
  } else {
    err = new Error(&#x22;Need either a hasher or data&#x22;);
  }
  return cb(err);
};

return Signer;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.HMAC_SHA256" id="apidoc.module.kbpgp.triplesec.HMAC_SHA256">module kbpgp.triplesec.HMAC_SHA256</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256.HMAC_SHA256" id="apidoc.element.kbpgp.triplesec.HMAC_SHA256.HMAC_SHA256">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>HMAC_SHA256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC_SHA256(key) {
  HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.HMAC_SHA256.prototype" id="apidoc.module.kbpgp.triplesec.HMAC_SHA256.prototype">module kbpgp.triplesec.HMAC_SHA256.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.HMAC_SHA256.prototype.constructor" id="apidoc.element.kbpgp.triplesec.HMAC_SHA256.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.HMAC_SHA256.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC_SHA256(key) {
  HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.WordArray" id="apidoc.module.kbpgp.triplesec.WordArray">module kbpgp.triplesec.WordArray</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.WordArray" id="apidoc.element.kbpgp.triplesec.WordArray.WordArray">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.</span>WordArray
        <span class="apidocSignatureSpan">(words, sigBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WordArray(words, sigBytes) {
  this.words = words || [];
  this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.alloc" id="apidoc.element.kbpgp.triplesec.WordArray.alloc">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>alloc
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (b) {
  if (Buffer.isBuffer(b)) {
    return WordArray.from_buffer(b);
  } else if ((typeof b === &#x27;object&#x27;) &#x26;&#x26; (b instanceof WordArray)) {
    return b;
  } else if (typeof b === &#x27;string&#x27;) {
    return WordArray.from_hex(b);
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return true;
  }
};

BaseKeyPair.parse = function(klass, pub_raw) {
  var err, key, len, _ref1;
  _ref1 = klass.Pub.<span class="apidocCodeKeywordSpan">alloc</span>(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];
  if (key != null) {
    key = new klass({
      pub: key
    });
  }
  return [err, key, len];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_buffer" id="apidoc.element.kbpgp.triplesec.WordArray.from_buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_buffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_buffer = function (b) {
  var ch, last, p, words;
  words = [];
  p = 0;
  while ((b.length - p) &#x3e;= 4) {
    words.push(b.readUInt32BE(p));
    p += 4;
  }
  if (p &#x3c; b.length) {
    last = 0;
    while (p &#x3c; b.length) {
      ch = b.readUInt8(p);
      last |= ch &#x3c;&#x3c; (24 - (p % 4) * 8);
      p++;
    }
    last = util.fixup_uint32(last);
    words.push(last);
  }
  return new WordArray(words, b.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return C.to_buffer();
};

setup = function(_arg) {
  var AES, K, P, a, b, cipher, err, input, key, klass;
  input = _arg.input, key = _arg.key, cipher = _arg.cipher;
  P = split64(WordArray.<span class="apidocCodeKeywordSpan">from_buffer</span>(input));
  K = WordArray.from_buffer(key);
  klass = cipher.klass;
  AES = new klass(K);
  err = null;
  if ((a = cipher.key_size) !== (b = key.length)) {
    err = new Error(&#x22;Bad key, needed &#x22; + a + &#x22; bytes, but got &#x22; + b);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_buffer_le" id="apidoc.element.kbpgp.triplesec.WordArray.from_buffer_le">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_buffer_le
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_buffer_le = function (b) {
  var ch, last, p, words;
  words = [];
  p = 0;
  while ((b.length - p) &#x3e;= 4) {
    words.push(b.readUInt32LE(p));
    p += 4;
  }
  if (p &#x3c; b.length) {
    last = 0;
    while (p &#x3c; b.length) {
      ch = b.readUInt8(p);
      last |= ch &#x3c;&#x3c; ((p % 4) * 8);
      p++;
    }
    last = util.fixup_uint32(last);
    words.push(last);
  }
  return new WordArray(words, b.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_hex" id="apidoc.element.kbpgp.triplesec.WordArray.from_hex">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_hex
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_hex = function (s) {
  return WordArray.from_buffer(new Buffer(s, &#x27;hex&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(function() {
var IV, WordArray, bufeq_secure, setup, split64, unwrap, wrap;

WordArray = require(&#x27;triplesec&#x27;).WordArray;

bufeq_secure = require(&#x27;./util&#x27;).bufeq_secure;

IV = WordArray.<span class="apidocCodeKeywordSpan">from_hex</span>(&#x22;A6A6A6A6A6A6A6A6&#x22;);

split64 = function(wa) {
  return wa.split(wa.words.length &#x3e;&#x3e; 1);
};

exports.wrap = wrap = function(_arg) {
  var A, AES, B, C, P, R, cipher, err, i, j, key, plaintext, r, t, _i, _j, _k, _len, _len1, _ref;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_hex_le" id="apidoc.element.kbpgp.triplesec.WordArray.from_hex_le">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_hex_le
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_hex_le = function (s) {
  return WordArray.from_buffer_le(new Buffer(s, &#x27;hex&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_i32a" id="apidoc.element.kbpgp.triplesec.WordArray.from_i32a">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_i32a
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_i32a = function (v) {
  return new WordArray(Array.apply([], v));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_ui8a" id="apidoc.element.kbpgp.triplesec.WordArray.from_ui8a">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_ui8a
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_ui8a = function (v) {
  return WordArray.from_buffer(ui8a_to_buffer(v));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_utf8" id="apidoc.element.kbpgp.triplesec.WordArray.from_utf8">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_utf8
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_utf8 = function (s) {
  return WordArray.from_buffer(new Buffer(s, &#x27;utf8&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.from_utf8_le" id="apidoc.element.kbpgp.triplesec.WordArray.from_utf8_le">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.</span>from_utf8_le
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from_utf8_le = function (s) {
  return WordArray.from_buffer_le(new Buffer(s, &#x27;utf8&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.WordArray.prototype" id="apidoc.module.kbpgp.triplesec.WordArray.prototype">module kbpgp.triplesec.WordArray.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.clamp" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.clamp">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>clamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clamp = function () {
  this.words[this.sigBytes &#x3e;&#x3e;&#x3e; 2] &#x26;= 0xffffffff &#x3c;&#x3c; (32 - (this.sigBytes % 4) * 8);
  this.words.length = Math.ceil(this.sigBytes / 4);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.clone" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new WordArray(this.words.slice(0), this.sigBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.cmp_ule" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.cmp_ule">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>cmp_ule
        <span class="apidocSignatureSpan">(wa2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmp_ule = function (wa2) {
  return util.buffer_cmp_ule(this.to_buffer(), wa2.to_buffer());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.concat" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.concat">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>concat
        <span class="apidocSignatureSpan">(wordArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (wordArray) {
  var i, thatByte, thatSigBytes, thatWords, _i;
  thatWords = wordArray.words;
  thatSigBytes = wordArray.sigBytes;
  this.clamp();
  if (this.sigBytes % 4) {
    for (i = _i = 0; 0 &#x3c;= thatSigBytes ? _i &#x3c; thatSigBytes : _i &#x3e; thatSigBytes; i = 0 &#x3c;= thatSigBytes ? ++_i : --_i) {
      thatByte = (thatWords[i &#x3e;&#x3e;&#x3e; 2] &#x3e;&#x3e;&#x3e; (24 - (i % 4) * 8)) &#x26; 0xff;
      this.words[(this.sigBytes + i) &#x3e;&#x3e;&#x3e; 2] |= thatByte &#x3c;&#x3c; (24 - ((this.sigBytes + i) % 4) * 8);
    }
  } else {
    this.words = this.words.concat(thatWords);
  }
  this.sigBytes += thatSigBytes;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return [null, new klass(d), orig_len - raw.length];
  }
};

BaseKey.prototype.serialize = function() {
  var e;
  return Buffer.<span class="apidocCodeKeywordSpan">concat</span>((function() {
    var _i, _len, _ref1, _results;
    _ref1 = this.ORDER;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
      e = _ref1[_i];
      _results.push(this[e].to_mpi_buffer());
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.endian_reverse" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.endian_reverse">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>endian_reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endian_reverse = function () {
  var i, w, _i, _len, _ref;
  _ref = this.words;
  for (i = _i = 0, _len = _ref.length; _i &#x3c; _len; i = ++_i) {
    w = _ref[i];
    this.words[i] = endian_reverse(w);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.equal" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.equal">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>equal
        <span class="apidocSignatureSpan">(wa)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equal = function (wa) {
  var i, ret, w, _i, _len, _ref;
  ret = true;
  if (wa.sigBytes !== this.sigBytes) {
    ret = false;
  } else {
    _ref = this.words;
    for (i = _i = 0, _len = _ref.length; _i &#x3c; _len; i = ++_i) {
      w = _ref[i];
      if (util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])) {
        ret = false;
      }
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    B = A.clone().concat(r);
    AES.decryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    t.words[1]--;
  }
}
if (A.<span class="apidocCodeKeywordSpan">equal</span>(IV)) {
  P = new WordArray([]);
  for (_k = 0, _len = R.length; _k &#x3c; _len; _k++) {
    r = R[_k];
    P.concat(r);
  }
  return [null, P.to_buffer()];
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.is_scrubbed" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.is_scrubbed">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>is_scrubbed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_scrubbed = function () {
  var w, _i, _len, _ref;
  _ref = this.words;
  for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
    w = _ref[_i];
    if (w !== 0) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.scrub" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  return util.scrub_vec(this.words);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.slice" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.slice">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>slice
        <span class="apidocSignatureSpan">(low, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (low, hi) {
  var n, sb;
  n = this.words.length;
  if (!((low &#x3c; hi) &#x26;&#x26; (hi &#x3c;= n))) {
    throw new Error(&#x22;Bad WordArray slice [&#x22; + low + &#x22;,&#x22; + hi + &#x22;)] when only &#x22; + n + &#x22; avail&#x22;);
  }
  sb = (hi - low) * 4;
  if (hi === n) {
    sb -= n * 4 - this.sigBytes;
  }
  return new WordArray(this.words.slice(low, hi), sb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _j, _results;
  _results = [];
  for (i = _j = 0; 0 &#x3c;= start ? _j &#x3c; start : _j &#x3e; start; i = 0 &#x3c;= start ? ++_j : --_j) {
    _results.push(0);
  }
  return _results;
})());
_ref1 = str.<span class="apidocCodeKeywordSpan">slice</span>(start);
for (i = _j = _ref1.length - 1; _j &#x3e;= 0; i = _j += -1) {
  c = _ref1[i];
  if ((char_index = this.lookup[c]) == null) {
    throw new Error(&#x27;Value passed is not a valid BaseX string.&#x27;);
  }
  num = num.add(base.multiply(nbv(char_index)));
  base = base.multiply(this.basebn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.split" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.split">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>split
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (n) {
  var i, out, sz;
  if (!(((this.sigBytes % 4) === 0) &#x26;&#x26; ((this.words.length % n) === 0))) {
    throw new Error(&#x22;bad key alignment&#x22;);
  }
  sz = this.words.length / n;
  out = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.words.length; sz &#x3e; 0 ? _i &#x3c; _ref : _i &#x3e; _ref; i = _i += sz) {
      _results.push(new WordArray(this.words.slice(i, i + sz)));
    }
    return _results;
  }).call(this);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
WordArray = require(&#x27;triplesec&#x27;).WordArray;

bufeq_secure = require(&#x27;./util&#x27;).bufeq_secure;

IV = WordArray.from_hex(&#x22;A6A6A6A6A6A6A6A6&#x22;);

split64 = function(wa) {
  return wa.<span class="apidocCodeKeywordSpan">split</span>(wa.words.length &#x3e;&#x3e; 1);
};

exports.wrap = wrap = function(_arg) {
  var A, AES, B, C, P, R, cipher, err, i, j, key, plaintext, r, t, _i, _j, _k, _len, _len1, _ref;
  plaintext = _arg.plaintext, key = _arg.key, cipher = _arg.cipher;
  _ref = setup({
    input: plaintext,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_buffer" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.to_buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_buffer = function () {
  var ch, out, p, w, _i, _len, _ref;
  out = new Buffer(this.sigBytes);
  p = 0;
  _ref = this.words;
  for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
    w = _ref[_i];
    if (!((this.sigBytes - p) &#x3e;= 4)) {
      continue;
    }
    w = util.fixup_uint32(w);
    out.writeUInt32BE(w, p);
    p += 4;
  }
  while (p &#x3c; this.sigBytes) {
    ch = (this.words[p &#x3e;&#x3e;&#x3e; 2] &#x3e;&#x3e;&#x3e; (24 - (p % 4) * 8)) &#x26; 0xff;
    out.writeUInt8(ch, p);
    p++;
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  C = A;
  for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
    r = R[_k];
    C.concat(r);
  }
  return C.<span class="apidocCodeKeywordSpan">to_buffer</span>();
};

setup = function(_arg) {
  var AES, K, P, a, b, cipher, err, input, key, klass;
  input = _arg.input, key = _arg.key, cipher = _arg.cipher;
  P = split64(WordArray.from_buffer(input));
  K = WordArray.from_buffer(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_hex" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.to_hex">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_hex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_hex = function () {
  return this.to_buffer().toString(&#x27;hex&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_ui8a" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.to_ui8a">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_ui8a
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_ui8a = function () {
  return buffer_to_ui8a(this.to_buffer());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.to_utf8" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.to_utf8">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>to_utf8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to_utf8 = function () {
  return this.to_buffer().toString(&#x27;utf8&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.truncate" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.truncate">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>truncate
        <span class="apidocSignatureSpan">(n_bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function (n_bytes) {
  var n_words;
  if (!(n_bytes &#x3c;= this.sigBytes)) {
    throw new Error(&#x22;Cannot truncate: &#x22; + n_bytes + &#x22; &#x3e; &#x22; + this.sigBytes);
  }
  n_words = Math.ceil(n_bytes / 4);
  return new WordArray(this.words.slice(0, n_words), n_bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.unshift" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.unshift">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>unshift
        <span class="apidocSignatureSpan">(n_words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (n_words) {
  var ret;
  if (this.words.length &#x3e;= n_words) {
    ret = this.words.splice(0, n_words);
    this.sigBytes -= n_words * 4;
    return new WordArray(ret);
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            i: 1,
            total: 1
          }, esc(__iced_deferrals.defer({
            lineno: 76
          })));
          __iced_deferrals._fulfill();
        })(function() {
          _this.packets.<span class="apidocCodeKeywordSpan">unshift</span>(ops_framed);
          _this.packets.push(fp);
          return cb(null);
        });
      });
    });
  };
})(this));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.WordArray.prototype.xor" id="apidoc.element.kbpgp.triplesec.WordArray.prototype.xor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.WordArray.prototype.</span>xor
        <span class="apidocSignatureSpan">(wa2, _arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xor = function (wa2, _arg) {
  var dst_offset, i, n_words, src_offset, tmp, _i;
  dst_offset = _arg.dst_offset, src_offset = _arg.src_offset, n_words = _arg.n_words;
  if (!dst_offset) {
    dst_offset = 0;
  }
  if (!src_offset) {
    src_offset = 0;
  }
  if (n_words == null) {
    n_words = wa2.words.length - src_offset;
  }
  if (this.words.length &#x3c; dst_offset + n_words) {
    throw new Error(&#x22;dest range exceeded (&#x22; + this.words.length + &#x22; &#x3c; &#x22; + (dst_offset + n_words) + &#x22;)&#x22;);
  }
  if (wa2.words.length &#x3c; src_offset + n_words) {
    throw new Error(&#x22;source range exceeded&#x22;);
  }
  for (i = _i = 0; 0 &#x3c;= n_words ? _i &#x3c; n_words : _i &#x3e; n_words; i = 0 &#x3c;= n_words ? ++_i : --_i) {
    tmp = this.words[dst_offset + i] ^ wa2.words[src_offset + i];
    this.words[dst_offset + i] = util.fixup_uint32(tmp);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.clone().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.<span class="apidocCodeKeywordSpan">xor</span>(t, {});
  }
}
C = A;
for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
  r = R[_k];
  C.concat(r);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.ciphers" id="apidoc.module.kbpgp.triplesec.ciphers">module kbpgp.triplesec.ciphers</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES" id="apidoc.element.kbpgp.triplesec.ciphers.AES">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>AES
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AES(key) {
  this._key = key.clone();
  this._doReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20" id="apidoc.element.kbpgp.triplesec.ciphers.Salsa20">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>Salsa20
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Salsa20() {
  return Salsa20.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.</span>TwoFish
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TwoFish(key) {
  this._key = key.clone();
  this.gMDS0 = [];
  this.gMDS1 = [];
  this.gMDS2 = [];
  this.gMDS3 = [];
  this.gSubKeys = [];
  this.gSBox = [];
  this.k64Cnt = 0;
  this._doReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.ciphers.AES.prototype" id="apidoc.module.kbpgp.triplesec.ciphers.AES.prototype">module kbpgp.triplesec.ciphers.AES.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doCryptBlock" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doCryptBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>_doCryptBlock
        <span class="apidocSignatureSpan">(M, offset, keySchedule, SUB_MIX, SBOX)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doCryptBlock = function (M, offset, keySchedule, SUB_MIX, SBOX) {
  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
  s0 = M[offset] ^ keySchedule[0];
  s1 = M[offset + 1] ^ keySchedule[1];
  s2 = M[offset + 2] ^ keySchedule[2];
  s3 = M[offset + 3] ^ keySchedule[3];
  ksRow = 4;
  for (round = _i = 1, _ref = this._nRounds; 1 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; round = 1 &#x3c;= _ref ? ++_i : --_i) {
    t0 = SUB_MIX[0][s0 &#x3e;&#x3e;&#x3e; 24] ^ SUB_MIX[1][(s1 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] ^ SUB_MIX[2][(s2 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] ^ SUB_MIX[3][s3 &#x26; 0xff] ^ keySchedule
[ksRow++];
    t1 = SUB_MIX[0][s1 &#x3e;&#x3e;&#x3e; 24] ^ SUB_MIX[1][(s2 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] ^ SUB_MIX[2][(s3 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] ^ SUB_MIX[3][s0 &#x26; 0xff] ^ keySchedule
[ksRow++];
    t2 = SUB_MIX[0][s2 &#x3e;&#x3e;&#x3e; 24] ^ SUB_MIX[1][(s3 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] ^ SUB_MIX[2][(s0 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] ^ SUB_MIX[3][s1 &#x26; 0xff] ^ keySchedule
[ksRow++];
    t3 = SUB_MIX[0][s3 &#x3e;&#x3e;&#x3e; 24] ^ SUB_MIX[1][(s0 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] ^ SUB_MIX[2][(s1 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] ^ SUB_MIX[3][s2 &#x26; 0xff] ^ keySchedule
[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t0 = ((SBOX[s0 &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24) | (SBOX[(s1 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (SBOX[(s2 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) | SBOX[s3 &#x26; 0xff]) ^ keySchedule
[ksRow++];
  t1 = ((SBOX[s1 &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24) | (SBOX[(s2 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (SBOX[(s3 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) | SBOX[s0 &#x26; 0xff]) ^ keySchedule
[ksRow++];
  t2 = ((SBOX[s2 &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24) | (SBOX[(s3 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (SBOX[(s0 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) | SBOX[s1 &#x26; 0xff]) ^ keySchedule
[ksRow++];
  t3 = ((SBOX[s3 &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24) | (SBOX[(s0 &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (SBOX[(s1 &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) | SBOX[s2 &#x26; 0xff]) ^ keySchedule
[ksRow++];
  M[offset] = t0;
  M[offset + 1] = t1;
  M[offset + 2] = t2;
  return M[offset + 3] = t3;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doReset" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
  keyWords = this._key.words;
  keySize = this._key.sigBytes / 4;
  this._nRounds = keySize + 6;
  ksRows = (this._nRounds + 1) * 4;
  this._keySchedule = [];
  for (ksRow = _i = 0; 0 &#x3c;= ksRows ? _i &#x3c; ksRows : _i &#x3e; ksRows; ksRow = 0 &#x3c;= ksRows ? ++_i : --_i) {
    this._keySchedule[ksRow] = ksRow &#x3c; keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (
t = (t &#x3c;&#x3c; 8) | (t &#x3e;&#x3e;&#x3e; 24), t = (G.SBOX[t &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24) | (G.SBOX[(t &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (G.SBOX[(t &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) |
G.SBOX[t &#x26; 0xff], t ^= G.RCON[(ksRow / keySize) | 0] &#x3c;&#x3c; 24) : keySize &#x3e; 6 &#x26;&#x26; ksRow % keySize === 4 ? t = (G.SBOX[t &#x3e;&#x3e;&#x3e; 24] &#x3c;&#x3c; 24
) | (G.SBOX[(t &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff] &#x3c;&#x3c; 16) | (G.SBOX[(t &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff] &#x3c;&#x3c; 8) | G.SBOX[t &#x26; 0xff] : void 0, this._keySchedule[ksRow - keySize
] ^ t);
  }
  this._invKeySchedule = [];
  for (invKsRow = _j = 0; 0 &#x3c;= ksRows ? _j &#x3c; ksRows : _j &#x3e; ksRows; invKsRow = 0 &#x3c;= ksRows ? ++_j : --_j) {
    ksRow = ksRows - invKsRow;
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
    this._invKeySchedule[invKsRow] = invKsRow &#x3c; 4 || ksRow &#x3c;= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t &#x3e;&#x3e;&#x3e; 24]] ^ G.INV_SUB_MIX[1][G.SBOX
[(t &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t &#x26; 0xff]];
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.constructor" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AES(key) {
  this._key = key.clone();
  this._doReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.decryptBlock" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.decryptBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>decryptBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptBlock = function (M, offset) {
  var _ref, _ref1;
  if (offset == null) {
    offset = 0;
  }
  _ref = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref[0], M[offset + 3] = _ref[1];
  this._doCryptBlock(M, offset, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
  return _ref1 = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref1[0], M[offset + 3] = _ref1[1], _ref1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
R = C.slice(1);
t = new WordArray([0, 6 * R.length]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = R.length - 1; _j &#x3e;= 0; i = _j += -1) {
    r = R[i];
    A.xor(t, {});
    B = A.clone().concat(r);
    AES.<span class="apidocCodeKeywordSpan">decryptBlock</span>(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    t.words[1]--;
  }
}
if (A.equal(IV)) {
  P = new WordArray([]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.encryptBlock" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.encryptBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>encryptBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptBlock = function (M, offset) {
  if (offset == null) {
    offset = 0;
  }
  return this._doCryptBlock(M, offset, this._keySchedule, G.SUB_MIX, G.SBOX);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.clone().concat(r);
    AES.<span class="apidocCodeKeywordSpan">encryptBlock</span>(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.scrub" id="apidoc.element.kbpgp.triplesec.ciphers.AES.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.AES.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  scrub_vec(this._keySchedule);
  scrub_vec(this._invKeySchedule);
  return this._key.scrub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.ciphers.Salsa20.prototype" id="apidoc.module.kbpgp.triplesec.ciphers.Salsa20.prototype">module kbpgp.triplesec.ciphers.Salsa20.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._generateBlockBuffer" id="apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._generateBlockBuffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>_generateBlockBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_generateBlockBuffer = function () {
  var e, i, v, _i, _len;
  this._buf = new Buffer(this.blockSize);
  v = this._generateBlock();
  for (i = _i = 0, _len = v.length; _i &#x3c; _len; i = ++_i) {
    e = v[i];
    this._buf.writeUInt32LE(fixup_uint32(e), i * 4);
  }
  return this._buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._reset" id="apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype._reset">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>_reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reset = function () {
  Salsa20.__super__._reset.call(this);
  return this._i = this.blockSize;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.constructor" id="apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Salsa20() {
  return Salsa20.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.getBytes" id="apidoc.element.kbpgp.triplesec.ciphers.Salsa20.prototype.getBytes">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.Salsa20.prototype.</span>getBytes
        <span class="apidocSignatureSpan">(needed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function (needed) {
  var bsz, n, v;
  if (needed == null) {
    needed = this.blockSize;
  }
  v = [];
  bsz = this.blockSize;
  if ((this._i === bsz) &#x26;&#x26; (needed === bsz)) {
    return this._generateBlockBuffer();
  } else {
    while (needed &#x3e; 0) {
      if (this._i === bsz) {
        this._generateBlockBuffer();
        this._i = 0;
      }
      n = Math.min(needed, bsz - this._i);
      v.push((n === bsz ? this._buf : this._buf.slice(this._i, this._i + n)));
      this._i += n;
      needed -= n;
    }
    return Buffer.concat(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.ciphers.TwoFish.prototype" id="apidoc.module.kbpgp.triplesec.ciphers.TwoFish.prototype">module kbpgp.triplesec.ciphers.TwoFish.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.F32" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.F32">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>F32
        <span class="apidocSignatureSpan">(x, k32)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">F32 = function (x, k32) {
  var b0, b1, b2, b3, k0, k1, k2, k3, m, res;
  b0 = this.getByte(x, 0);
  b1 = this.getByte(x, 1);
  b2 = this.getByte(x, 2);
  b3 = this.getByte(x, 3);
  k0 = k32[0];
  k1 = k32[1];
  k2 = k32[2];
  k3 = k32[3];
  m = this.k64Cnt &#x26; 3;
  res = m === 1 ? this.gMDS0[(G.P[G.P_01][b0] &#x26; 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][b1] &#x26; 0xff) ^ this.getByte
(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][b2] &#x26; 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][b3] &#x26; 0xff) ^ this.getByte(k0, 3
)] : (m === 0 ? (b0 = (G.P[G.P_04][b0] &#x26; 0xff) ^ this.getByte(k3, 0), b1 = (G.P[G.P_14][b1] &#x26; 0xff) ^ this.getByte(k3, 1), b2 = (
G.P[G.P_24][b2] &#x26; 0xff) ^ this.getByte(k3, 2), b3 = (G.P[G.P_34][b3] &#x26; 0xff) ^ this.getByte(k3, 3)) : void 0, m === 0 || m === 3
 ? (b0 = (G.P[G.P_03][b0] &#x26; 0xff) ^ this.getByte(k2, 0), b1 = (G.P[G.P_13][b1] &#x26; 0xff) ^ this.getByte(k2, 1), b2 = (G.P[G.P_23][
b2] &#x26; 0xff) ^ this.getByte(k2, 2), b3 = (G.P[G.P_33][b3] &#x26; 0xff) ^ this.getByte(k2, 3)) : void 0, this.gMDS0[(G.P[G.P_01][(G.P[G
.P_02][b0] &#x26; 0xff) ^ this.getByte(k1, 0)] &#x26; 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] &#x26; 0xff) ^ this
.getByte(k1, 1)] &#x26; 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] &#x26; 0xff) ^ this.getByte(k1, 2)] &#x26; 0xff
) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] &#x26; 0xff) ^ this.getByte(k1, 3)] &#x26; 0xff) ^ this.getByte(k0, 3)]);
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_0" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_0">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Fe32_0
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fe32_0 = function (x) {
  return this.gSBox[0x000 + 2 * (x &#x26; 0xff)] ^ this.gSBox[0x001 + 2 * ((x &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff)] ^ this.gSBox[0x200 + 2 * ((x &#x3e;&#x3e;&#x3e; 16) &#x26;
0xff)] ^ this.gSBox[0x201 + 2 * ((x &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_3" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Fe32_3">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Fe32_3
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fe32_3 = function (x) {
  return this.gSBox[0x000 + 2 * ((x &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff)] ^ this.gSBox[0x001 + 2 * (x &#x26; 0xff)] ^ this.gSBox[0x200 + 2 * ((x &#x3e;&#x3e;&#x3e; 8) &#x26;
0xff)] ^ this.gSBox[0x201 + 2 * ((x &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR1" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR1">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>LFSR1
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LFSR1 = function (x) {
  return (x &#x3e;&#x3e; 1) ^ ((x &#x26; 0x01) !== 0 ? G.GF256_FDBK_2 : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR2" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.LFSR2">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>LFSR2
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LFSR2 = function (x) {
  return (x &#x3e;&#x3e; 2) ^ ((x &#x26; 0x02) !== 0 ? G.GF256_FDBK_2 : 0) ^ ((x &#x26; 0x01) !== 0 ? G.GF256_FDBK_4 : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_X" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_X">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Mx_X
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mx_X = function (x) {
  return x ^ this.LFSR2(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_Y" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.Mx_Y">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>Mx_Y
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mx_Y = function (x) {
  return x ^ this.LFSR1(x) ^ this.LFSR2(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_MDS_Encode" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_MDS_Encode">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>RS_MDS_Encode
        <span class="apidocSignatureSpan">(k0, k1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RS_MDS_Encode = function (k0, k1) {
  var i, r, _i, _j;
  r = k1;
  for (i = _i = 0; _i &#x3c; 4; i = ++_i) {
    r = this.RS_rem(r);
  }
  r ^= k0;
  for (i = _j = 0; _j &#x3c; 4; i = ++_j) {
    r = this.RS_rem(r);
  }
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_rem" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.RS_rem">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>RS_rem
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RS_rem = function (x) {
  var b, g2, g3;
  b = (x &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff;
  g2 = ((b &#x3c;&#x3c; 1) ^ ((b &#x26; 0x80) !== 0 ? G.RS_GF_FDBK : 0)) &#x26; 0xff;
  g3 = ((b &#x3e;&#x3e;&#x3e; 1) ^ ((b &#x26; 0x01) !== 0 ? G.RS_GF_FDBK &#x3e;&#x3e;&#x3e; 1 : 0)) ^ g2;
  return (x &#x3c;&#x3c; 8) ^ (g3 &#x3c;&#x3c; 24) ^ (g2 &#x3c;&#x3c; 16) ^ (g3 &#x3c;&#x3c; 8) ^ b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype._doReset" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  var A, B, b0, b1, b2, b3, i, j, k0, k1, k2, k3, k32e, k32o, m, m1, mX, mY, p, q, sBoxKeys, _i, _j, _k, _l, _ref, _ref1, _results
;
  k32e = [];
  k32o = [];
  sBoxKeys = [];
  m1 = [];
  mX = [];
  mY = [];
  this.k64Cnt = this._key.words.length / 2;
  if (this.k64Cnt &#x3c; 1) {
    throw &#x22;Key size less than 64 bits&#x22;;
  }
  if (this.k64Cnt &#x3e; 4) {
    throw &#x22;Key size larger than 256 bits&#x22;;
  }
  for (i = _i = 0; _i &#x3c; 256; i = ++_i) {
    j = G.P[0][i] &#x26; 0xff;
    m1[0] = j;
    mX[0] = this.Mx_X(j) &#x26; 0xff;
    mY[0] = this.Mx_Y(j) &#x26; 0xff;
    j = G.P[1][i] &#x26; 0xff;
    m1[1] = j;
    mX[1] = this.Mx_X(j) &#x26; 0xff;
    mY[1] = this.Mx_Y(j) &#x26; 0xff;
    this.gMDS0[i] = m1[G.P_00] | mX[G.P_00] &#x3c;&#x3c; 8 | mY[G.P_00] &#x3c;&#x3c; 16 | mY[G.P_00] &#x3c;&#x3c; 24;
    this.gMDS1[i] = mY[G.P_10] | mY[G.P_10] &#x3c;&#x3c; 8 | mX[G.P_10] &#x3c;&#x3c; 16 | m1[G.P_10] &#x3c;&#x3c; 24;
    this.gMDS2[i] = mX[G.P_20] | mY[G.P_20] &#x3c;&#x3c; 8 | m1[G.P_20] &#x3c;&#x3c; 16 | mY[G.P_20] &#x3c;&#x3c; 24;
    this.gMDS3[i] = mX[G.P_30] | m1[G.P_30] &#x3c;&#x3c; 8 | mY[G.P_30] &#x3c;&#x3c; 16 | mX[G.P_30] &#x3c;&#x3c; 24;
  }
  for (i = _j = 0, _ref = this.k64Cnt; 0 &#x3c;= _ref ? _j &#x3c; _ref : _j &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_j : --_j) {
    p = i * 2;
    k32e[i] = this.switchEndianness(this._key.words[p]);
    k32o[i] = this.switchEndianness(this._key.words[p + 1]);
    sBoxKeys[this.k64Cnt - 1 - i] = this.RS_MDS_Encode(k32e[i], k32o[i]);
  }
  for (i = _k = 0, _ref1 = 40 / 2; 0 &#x3c;= _ref1 ? _k &#x3c; _ref1 : _k &#x3e; _ref1; i = 0 &#x3c;= _ref1 ? ++_k : --_k) {
    q = i * G.SK_STEP;
    A = this.F32(q, k32e);
    B = this.F32(q + G.SK_BUMP, k32o);
    B = B &#x3c;&#x3c; 8 | B &#x3e;&#x3e;&#x3e; 24;
    A += B;
    this.gSubKeys[i * 2] = A;
    A += B;
    this.gSubKeys[i * 2 + 1] = A &#x3c;&#x3c; G.SK_ROTL | A &#x3e;&#x3e;&#x3e; (32 - G.SK_ROTL);
  }
  k0 = sBoxKeys[0];
  k1 = sBoxKeys[1];
  k2 = sBoxKeys[2];
  k3 = sBoxKeys[3];
  this.gSBox = [];
  _results = [];
  for (i = _l = 0; _l &#x3c; 256; i = ++_l) {
    b0 = b1 = b2 = b3 = i;
    m = this.k64Cnt &#x26; 3;
    if (m === 1) {
      this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][b0] &#x26; 0xff) ^ this.getByte(k0, 0)];
      this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][b1] &#x26; 0xff) ^ this.getByte(k0, 1)];
      this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][b2] &#x26; 0xff) ^ this.getByte(k0, 2)];
      _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][b3] &#x26; 0xff) ^ this.getByte(k0, 3)]);
    } else {
      if (m === 0) {
        b0 = (G.P[G.P_04][b0] &#x26; 0xff) ^ this.getByte(k3, 0);
        b1 = (G.P[G.P_14][b1] &#x26; 0xff) ^ this.getByte(k3, 1);
        b2 = (G.P[G.P_24][b2] &#x26; 0xff) ^ this.getByte(k3, 2);
        b3 = (G.P[G.P_34][b3] &#x26; 0xff) ^ this.getByte(k3, 3);
      }
      if (m === 0 || m === 3) {
        b0 = (G.P[G.P_03][b0] &#x26; 0xff) ^ this.getByte(k2, 0);
        b1 = (G.P[G.P_13][b1] &#x26; 0xff) ^ this.getByte(k2, 1);
        b2 = (G.P[G.P_23][b2] &#x26; 0xff) ^ this.getByte(k2, 2);
        b3 = (G.P[G.P_33][b3] &#x26; 0xff) ^ this.getByte(k2, 3);
      }
      this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] &#x26; 0xff) ^ this.getByte(k1, 0)] &#x26; 0xff) ^ this.getByte(k0, 0)];
      this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] &#x26; 0xff) ^ this.getByte(k1, 1)] &#x26; 0xff) ^ this.getByte(k0,
1)];
      this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] &#x26; 0xff) ^ this.getByte(k1, 2)] &#x26; 0xff) ^ this.getByte
(k0, 2)];
      _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] &#x26; 0xff) ^ this.getByte(k1, 3)] &#x26; 0xff) ^
this.getByte(k0, 3)]);
    }
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.constructor" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TwoFish(key) {
  this._key = key.clone();
  this.gMDS0 = [];
  this.gMDS1 = [];
  this.gMDS2 = [];
  this.gMDS3 = [];
  this.gSubKeys = [];
  this.gSBox = [];
  this.k64Cnt = 0;
  this._doReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.decryptBlock" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.decryptBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>decryptBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptBlock = function (M, offset) {
  var k, r, t0, t1, x0, x1, x2, x3, _i;
  if (offset == null) {
    offset = 0;
  }
  x2 = this.switchEndianness(M[offset]) ^ this.gSubKeys[4];
  x3 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[5];
  x0 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[6];
  x1 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[7];
  k = 8 + 2 * 16 - 1;
  for (r = _i = 0; _i &#x3c; 16; r = _i += 2) {
    t0 = this.Fe32_0(x2);
    t1 = this.Fe32_3(x3);
    x1 ^= t0 + 2 * t1 + this.gSubKeys[k--];
    x0 = (x0 &#x3c;&#x3c; 1 | x0 &#x3e;&#x3e;&#x3e; 31) ^ (t0 + t1 + this.gSubKeys[k--]);
    x1 = x1 &#x3e;&#x3e;&#x3e; 1 | x1 &#x3c;&#x3c; 31;
    t0 = this.Fe32_0(x0);
    t1 = this.Fe32_3(x1);
    x3 ^= t0 + 2 * t1 + this.gSubKeys[k--];
    x2 = (x2 &#x3c;&#x3c; 1 | x2 &#x3e;&#x3e;&#x3e; 31) ^ (t0 + t1 + this.gSubKeys[k--]);
    x3 = x3 &#x3e;&#x3e;&#x3e; 1 | x3 &#x3c;&#x3c; 31;
  }
  M[offset] = this.switchEndianness(x0 ^ this.gSubKeys[0]);
  M[offset + 1] = this.switchEndianness(x1 ^ this.gSubKeys[1]);
  M[offset + 2] = this.switchEndianness(x2 ^ this.gSubKeys[2]);
  return M[offset + 3] = this.switchEndianness(x3 ^ this.gSubKeys[3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
R = C.slice(1);
t = new WordArray([0, 6 * R.length]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = R.length - 1; _j &#x3e;= 0; i = _j += -1) {
    r = R[i];
    A.xor(t, {});
    B = A.clone().concat(r);
    AES.<span class="apidocCodeKeywordSpan">decryptBlock</span>(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    t.words[1]--;
  }
}
if (A.equal(IV)) {
  P = new WordArray([]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.encryptBlock" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.encryptBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>encryptBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptBlock = function (M, offset) {
  var k, r, t0, t1, x0, x1, x2, x3, _i;
  if (offset == null) {
    offset = 0;
  }
  x0 = this.switchEndianness(M[offset]) ^ this.gSubKeys[0];
  x1 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[1];
  x2 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[2];
  x3 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[3];
  k = 8;
  for (r = _i = 0; _i &#x3c; 16; r = _i += 2) {
    t0 = this.Fe32_0(x0);
    t1 = this.Fe32_3(x1);
    x2 ^= t0 + t1 + this.gSubKeys[k++];
    x2 = x2 &#x3e;&#x3e;&#x3e; 1 | x2 &#x3c;&#x3c; 31;
    x3 = (x3 &#x3c;&#x3c; 1 | x3 &#x3e;&#x3e;&#x3e; 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
    t0 = this.Fe32_0(x2);
    t1 = this.Fe32_3(x3);
    x0 ^= t0 + t1 + this.gSubKeys[k++];
    x0 = x0 &#x3e;&#x3e;&#x3e; 1 | x0 &#x3c;&#x3c; 31;
    x1 = (x1 &#x3c;&#x3c; 1 | x1 &#x3e;&#x3e;&#x3e; 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
  }
  M[offset] = this.switchEndianness(x2 ^ this.gSubKeys[4]);
  M[offset + 1] = this.switchEndianness(x3 ^ this.gSubKeys[5]);
  M[offset + 2] = this.switchEndianness(x0 ^ this.gSubKeys[6]);
  return M[offset + 3] = this.switchEndianness(x1 ^ this.gSubKeys[7]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.clone().concat(r);
    AES.<span class="apidocCodeKeywordSpan">encryptBlock</span>(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
for (_k = 0, _len1 = R.length; _k &#x3c; _len1; _k++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.getByte" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.getByte">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>getByte
        <span class="apidocSignatureSpan">(x, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getByte = function (x, n) {
  return (x &#x3e;&#x3e;&#x3e; (n * 8)) &#x26; 0xFF;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.scrub" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {
  scrub_vec(this.gSubKeys);
  scrub_vec(this.gSBox);
  return this._key.scrub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.switchEndianness" id="apidoc.element.kbpgp.triplesec.ciphers.TwoFish.prototype.switchEndianness">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.ciphers.TwoFish.prototype.</span>switchEndianness
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchEndianness = function (word) {
  return ((word &#x26; 0xff) &#x3c;&#x3c; 24) | (((word &#x3e;&#x3e; 8) &#x26; 0xff) &#x3c;&#x3c; 16) | (((word &#x3e;&#x3e; 16) &#x26; 0xff) &#x3c;&#x3c; 8) | ((word &#x3e;&#x3e; 24) &#x26; 0xff);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.hash" id="apidoc.module.kbpgp.triplesec.hash">module kbpgp.triplesec.hash</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.MD5" id="apidoc.element.kbpgp.triplesec.hash.MD5">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>MD5
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MD5() {
  return MD5.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.RIPEMD160" id="apidoc.element.kbpgp.triplesec.hash.RIPEMD160">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>RIPEMD160
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RIPEMD160() {
  return RIPEMD160.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA1" id="apidoc.element.kbpgp.triplesec.hash.SHA1">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA1() {
  return SHA1.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA224" id="apidoc.element.kbpgp.triplesec.hash.SHA224">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA224
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA224() {
  return SHA224.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA256" id="apidoc.element.kbpgp.triplesec.hash.SHA256">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA256
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA256() {
  return SHA256.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  S2K = (function() {
S2K.prototype._count = function(c, bias) {
  return (16 + (c &#x26; 15)) &#x3c;&#x3c; ((c &#x3e;&#x3e; 4) + bias);
};

function S2K() {
  this.hash = SHA256;
  this.streamer = streamers.<span class="apidocCodeKeywordSpan">SHA256</span>();
}

S2K.prototype.set_hash_algorithm = function(which) {
  if ((this.hash = alloc(which)) != null) {
    return this.streamer = streamers[this.hash.algname]();
  } else {
    console.warn(&#x22;No such hash: &#x22; + which + &#x22;; defaulting to SHA-256&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3" id="apidoc.element.kbpgp.triplesec.hash.SHA3">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA3
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA3() {
  return SHA3.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA384" id="apidoc.element.kbpgp.triplesec.hash.SHA384">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA384
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA384() {
  return SHA384.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA512" id="apidoc.element.kbpgp.triplesec.hash.SHA512">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.</span>SHA512
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA512() {
  return SHA512.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signer.prototype._run_hash = function(cb) {
  var err;
  err = null;
  if (this.hash_streamer != null) {

  } else if (this.data != null) {
    this.hash_streamer = streamers.<span class="apidocCodeKeywordSpan">SHA512</span>();
    this.hash_streamer.update(this.data);
  } else {
    err = new Error(&#x22;Need either a hasher or data&#x22;);
  }
  return cb(err);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.hash.SHA3.prototype" id="apidoc.module.kbpgp.triplesec.hash.SHA3.prototype">module kbpgp.triplesec.hash.SHA3.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doFinalize" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doFinalize">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doFinalize = function () {
  var blockSizeBits, data, dataWords, hashWords, i, lane, laneLsw, laneMsw, nBitsLeft, nBitsTotal, outputLengthBytes, outputLengthLanes
, state, _i;
  data = this._data;
  dataWords = data.words;
  nBitsTotal = this._nDataBytes * 8;
  nBitsLeft = data.sigBytes * 8;
  blockSizeBits = this.blockSize * 32;
  dataWords[nBitsLeft &#x3e;&#x3e;&#x3e; 5] |= 0x1 &#x3c;&#x3c; (24 - nBitsLeft % 32);
  dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) &#x3e;&#x3e;&#x3e; 5) - 1] |= 0x80;
  data.sigBytes = dataWords.length * 4;
  this._process();
  state = this._state;
  outputLengthBytes = this.outputLength / 8;
  outputLengthLanes = outputLengthBytes / 8;
  hashWords = [];
  for (i = _i = 0; 0 &#x3c;= outputLengthLanes ? _i &#x3c; outputLengthLanes : _i &#x3e; outputLengthLanes; i = 0 &#x3c;= outputLengthLanes ? ++_i : --
_i) {
    lane = state[i];
    laneMsw = lane.high;
    laneLsw = lane.low;
    laneMsw = (((laneMsw &#x3c;&#x3c; 8) | (laneMsw &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((laneMsw &#x3c;&#x3c; 24) | (laneMsw &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
    laneLsw = (((laneLsw &#x3c;&#x3c; 8) | (laneLsw &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((laneLsw &#x3c;&#x3c; 24) | (laneLsw &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
    hashWords.push(laneLsw);
    hashWords.push(laneMsw);
  }
  return new WordArray(hashWords, outputLengthBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doProcessBlock" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doProcessBlock">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doProcessBlock
        <span class="apidocSignatureSpan">(M, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doProcessBlock = function (M, offset) {
  var G, M2i, M2i1, T0, TLane, TPiLane, Tx, Tx1, Tx1Lane, Tx1Lsw, Tx1Msw, Tx2Lane, Tx4, i, lane, laneIndex, laneLsw, laneMsw, nBlockSizeLanes
, rhoOffset, round, roundConstant, state, state0, tLsw, tMsw, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q, _results;
  G = glbl;
  state = this._state;
  nBlockSizeLanes = this.blockSize / 2;
  for (i = _i = 0; 0 &#x3c;= nBlockSizeLanes ? _i &#x3c; nBlockSizeLanes : _i &#x3e; nBlockSizeLanes; i = 0 &#x3c;= nBlockSizeLanes ? ++_i : --_i) {
    M2i = M[offset + 2 * i];
    M2i1 = M[offset + 2 * i + 1];
    M2i = (((M2i &#x3c;&#x3c; 8) | (M2i &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((M2i &#x3c;&#x3c; 24) | (M2i &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
    M2i1 = (((M2i1 &#x3c;&#x3c; 8) | (M2i1 &#x3e;&#x3e;&#x3e; 24)) &#x26; 0x00ff00ff) | (((M2i1 &#x3c;&#x3c; 24) | (M2i1 &#x3e;&#x3e;&#x3e; 8)) &#x26; 0xff00ff00);
    lane = state[i];
    lane.high ^= M2i1;
    lane.low ^= M2i;
  }
  _results = [];
  for (round = _j = 0; _j &#x3c; 24; round = ++_j) {
    for (x = _k = 0; _k &#x3c; 5; x = ++_k) {
      tMsw = tLsw = 0;
      for (y = _l = 0; _l &#x3c; 5; y = ++_l) {
        lane = state[x + 5 * y];
        tMsw ^= lane.high;
        tLsw ^= lane.low;
      }
      Tx = G.T[x];
      Tx.high = tMsw;
      Tx.low = tLsw;
    }
    for (x = _m = 0; _m &#x3c; 5; x = ++_m) {
      Tx4 = G.T[(x + 4) % 5];
      Tx1 = G.T[(x + 1) % 5];
      Tx1Msw = Tx1.high;
      Tx1Lsw = Tx1.low;
      tMsw = Tx4.high ^ ((Tx1Msw &#x3c;&#x3c; 1) | (Tx1Lsw &#x3e;&#x3e;&#x3e; 31));
      tLsw = Tx4.low ^ ((Tx1Lsw &#x3c;&#x3c; 1) | (Tx1Msw &#x3e;&#x3e;&#x3e; 31));
      for (y = _n = 0; _n &#x3c; 5; y = ++_n) {
        lane = state[x + 5 * y];
        lane.high ^= tMsw;
        lane.low ^= tLsw;
      }
    }
    for (laneIndex = _o = 1; _o &#x3c; 25; laneIndex = ++_o) {
      lane = state[laneIndex];
      laneMsw = lane.high;
      laneLsw = lane.low;
      rhoOffset = G.RHO_OFFSETS[laneIndex];
      if (rhoOffset &#x3c; 32) {
        tMsw = (laneMsw &#x3c;&#x3c; rhoOffset) | (laneLsw &#x3e;&#x3e;&#x3e; (32 - rhoOffset));
        tLsw = (laneLsw &#x3c;&#x3c; rhoOffset) | (laneMsw &#x3e;&#x3e;&#x3e; (32 - rhoOffset));
      } else {
        tMsw = (laneLsw &#x3c;&#x3c; (rhoOffset - 32)) | (laneMsw &#x3e;&#x3e;&#x3e; (64 - rhoOffset));
        tLsw = (laneMsw &#x3c;&#x3c; (rhoOffset - 32)) | (laneLsw &#x3e;&#x3e;&#x3e; (64 - rhoOffset));
      }
      TPiLane = G.T[G.PI_INDEXES[laneIndex]];
      TPiLane.high = tMsw;
      TPiLane.low = tLsw;
    }
    T0 = G.T[0];
    state0 = state[0];
    T0.high = state0.high;
    T0.low = state0.low;
    for (x = _p = 0; _p &#x3c; 5; x = ++_p) {
      for (y = _q = 0; _q &#x3c; 5; y = ++_q) {
        laneIndex = x + 5 * y;
        lane = state[laneIndex];
        TLane = G.T[laneIndex];
        Tx1Lane = G.T[((x + 1) % 5) + 5 * y];
        Tx2Lane = G.T[((x + 2) % 5) + 5 * y];
        lane.high = TLane.high ^ (~Tx1Lane.high &#x26; Tx2Lane.high);
        lane.low = TLane.low ^ (~Tx1Lane.low &#x26; Tx2Lane.low);
      }
    }
    lane = state[0];
    roundConstant = G.ROUND_CONSTANTS[round];
    lane.high ^= roundConstant.high;
    _results.push(lane.low ^= roundConstant.low);
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doReset" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype._doReset">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>_doReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doReset = function () {
  var i;
  return this._state = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i &#x3c; 25; i = ++_i) {
      _results.push(new X64Word(0, 0));
    }
    return _results;
  })();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.clone" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.clone">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var out;
  out = new SHA3();
  this.copy_to(out);
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A = IV;
R = P;
t = new WordArray([0, 0]);
for (j = _i = 0; _i &#x3c; 6; j = ++_i) {
  for (i = _j = 0, _len = R.length; _j &#x3c; _len; i = ++_j) {
    r = R[i];
    t.words[1]++;
    B = A.<span class="apidocCodeKeywordSpan">clone</span>().concat(r);
    AES.encryptBlock(B.words);
    A = B.slice(0, 2);
    R[i] = B.slice(2, 4);
    A.xor(t, {});
  }
}
C = A;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.constructor" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.constructor">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SHA3() {
  return SHA3.__super__.constructor.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.copy_to" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.copy_to">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (obj) {
  var s;
  SHA3.__super__.copy_to.call(this, obj);
  return obj._state = (function() {
    var _i, _len, _ref1, _results;
    _ref1 = this._state;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
      s = _ref1[_i];
      _results.push(s.clone());
    }
    return _results;
  }).call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.scrub" id="apidoc.element.kbpgp.triplesec.hash.SHA3.prototype.scrub">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hash.SHA3.prototype.</span>scrub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return cb(null);
    };
  })(this));
};

Burner.prototype.scrub = function() {
  if (this._cipher != null) {
    this._cipher.<span class="apidocCodeKeywordSpan">scrub</span>();
  }
  if (this._session_key != null) {
    return scrub_buffer(this._session_key);
  }
};

Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.hmac" id="apidoc.module.kbpgp.triplesec.hmac">module kbpgp.triplesec.hmac</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hmac.HMAC" id="apidoc.element.kbpgp.triplesec.hmac.HMAC">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>HMAC
        <span class="apidocSignatureSpan">(key, klass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC(key, klass) {
  var i, _i, _ref;
  if (klass == null) {
    klass = SHA512;
  }
  this.key = key.clone();
  this.hasher = new klass();
  this.hasherBlockSize = this.hasher.blockSize;
  this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
  if (this.key.sigBytes &#x3e; this.hasherBlockSizeBytes) {
    this.key = this.hasher.finalize(this.key);
  }
  this.key.clamp();
  this._oKey = this.key.clone();
  this._iKey = this.key.clone();
  for (i = _i = 0, _ref = this.hasherBlockSize; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    this._oKey.words[i] ^= 0x5c5c5c5c;
    this._iKey.words[i] ^= 0x36363636;
  }
  this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hmac.HMAC_SHA256" id="apidoc.element.kbpgp.triplesec.hmac.HMAC_SHA256">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>HMAC_SHA256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HMAC_SHA256(key) {
  HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hmac.bulk_sign" id="apidoc.element.kbpgp.triplesec.hmac.bulk_sign">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>bulk_sign
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulk_sign = function (_arg, cb) {
  var eng, input, key, klass, progress_hook, res, slice_args, what, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  key = _arg.key, input = _arg.input, progress_hook = _arg.progress_hook, klass = _arg.klass, what = _arg.what;
  klass || (klass = HMAC);
  what || (what = &#x22;hmac_sha512&#x22;);
  eng = new klass(key);
  input.clamp();
  slice_args = {
    update: function(lo, hi) {
      return eng.update(input.slice(lo, hi));
    },
    finalize: function() {
      return eng.finalize();
    },
    default_n: eng.hasherBlockSize * 1000
  };
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/hmac.iced&#x22;
      });
      util.bulk(input.sigBytes, slice_args, {
        what: what,
        progress_hook: progress_hook,
        cb: __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return res = arguments[0];
            };
          })(),
          lineno: 137
        })
      });
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      eng.scrub();
      return cb(res);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.hmac.sign" id="apidoc.element.kbpgp.triplesec.hmac.sign">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.hmac.</span>sign
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (_arg) {
  var eng, hash_class, input, key, out;
  key = _arg.key, input = _arg.input, hash_class = _arg.hash_class;
  eng = new HMAC(key, hash_class);
  out = eng.finalize(input.clamp());
  eng.scrub();
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (function(_this) {
return (function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/dsa.iced&#x22;,
    funcname: &#x22;Pair.pad_and_sign&#x22;
  });
  _this.priv.<span class="apidocCodeKeywordSpan">sign</span>(h, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return sig = arguments[0];
      };
    })(),
    lineno: 128
  }));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.prng" id="apidoc.module.kbpgp.triplesec.prng">module kbpgp.triplesec.prng</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.PRNG" id="apidoc.element.kbpgp.triplesec.prng.PRNG">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>PRNG
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PRNG() {
  this.meg = new more_entropy.Generator();
  this.adrbg = new ADRBG(((function(_this) {
    return function(n, cb) {
      return _this.gen_seed(n, cb);
    };
  })(this)), XOR.sign);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.generate" id="apidoc.element.kbpgp.triplesec.prng.generate">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>generate
        <span class="apidocSignatureSpan">(n, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (n, cb) {
  if (_prng == null) {
    _prng = new PRNG();
  }
  return _prng.generate(n, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.native_rng" id="apidoc.element.kbpgp.triplesec.prng.native_rng">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.</span>native_rng
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">native_rng = function (x) {
  if (_native_rng == null) {
    throw new Error(&#x27;No rng found; tried requiring &#x22;crypto&#x22; and window.crypto&#x27;);
  }
  return _native_rng(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.prng.PRNG.prototype" id="apidoc.module.kbpgp.triplesec.prng.PRNG.prototype">module kbpgp.triplesec.prng.PRNG.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.gen_seed" id="apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.gen_seed">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>gen_seed
        <span class="apidocSignatureSpan">(nbits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gen_seed = function (nbits, cb) {
  var b, bufs, cat, nbytes, wa, words, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  nbytes = nbits / 8;
  bufs = [];
  bufs.push(this.now_to_buffer());
  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: &#x22;/Users/max/src/keybase/triplesec/src/prng.iced&#x22;,
        funcname: &#x22;PRNG.gen_seed&#x22;
      });
      _this.meg.generate(nbits, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return words = arguments[0];
          };
        })(),
        lineno: 83
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      var _i, _len;
      bufs.push(_this.now_to_buffer());
      bufs.push(new Buffer(words));
      bufs.push(native_rng(nbytes));
      bufs.push(_this.now_to_buffer());
      cat = Buffer.concat(bufs);
      wa = WordArray.from_buffer(cat);
      util.scrub_buffer(cat);
      for (_i = 0, _len = bufs.length; _i &#x3c; _len; _i++) {
        b = bufs[_i];
        util.scrub_buffer(b);
      }
      return cb(wa);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.generate" id="apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.generate">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>generate
        <span class="apidocSignatureSpan">(n, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (n, cb) {
  return this.adrbg.generate(n, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (err == null) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/home/zapu/pgp/kbpgp/src/ecc/base.iced&#x22;,
    funcname: &#x22;generate&#x22;
  });
  curve.<span class="apidocCodeKeywordSpan">generate</span>(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        x = arguments[0].x;
        return R = arguments[0].R;
      };
    })(),
    lineno: 58
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.now_to_buffer" id="apidoc.element.kbpgp.triplesec.prng.PRNG.prototype.now_to_buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.prng.PRNG.prototype.</span>now_to_buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now_to_buffer = function () {
  var buf, d, ms, s;
  d = Date.now();
  ms = d % 1000;
  s = Math.floor(d / 1000);
  buf = new Buffer(8);
  buf.writeUInt32BE(s, 0);
  buf.writeUInt32BE(ms, 4);
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.triplesec.util" id="apidoc.module.kbpgp.triplesec.util">module kbpgp.triplesec.util</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.buffer_cmp_ule" id="apidoc.element.kbpgp.triplesec.util.buffer_cmp_ule">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>buffer_cmp_ule
        <span class="apidocSignatureSpan">(b1, b2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer_cmp_ule = function (b1, b2) {
  var I, J, i, j, x, y;
  i = j = 0;
  I = b1.length;
  J = b2.length;
  while (i &#x3c; I &#x26;&#x26; b1.readUInt8(i) === 0) {
    i++;
  }
  while (j &#x3c; J &#x26;&#x26; b2.readUInt8(j) === 0) {
    j++;
  }
  if ((I - i) &#x3e; (J - j)) {
    return 1;
  } else if ((J - j) &#x3e; (I - i)) {
    return -1;
  }
  while (i &#x3c; I) {
    if ((x = b1.readUInt8(i)) &#x3c; (y = b2.readUInt8(j))) {
      return -1;
    } else if (y &#x3c; x) {
      return 1;
    }
    i++;
    j++;
  }
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.bulk" id="apidoc.element.kbpgp.triplesec.util.bulk">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>bulk
        <span class="apidocSignatureSpan">(n_input_bytes, _arg, _arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulk = function (n_input_bytes, _arg, _arg1) {
  var call_ph, cb, default_n, delay, finalize, i, left, n, n_words, progress_hook, ret, total_words, update, what, ___iced_passed_deferral
, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  update = _arg.update, finalize = _arg.finalize, default_n = _arg.default_n;
  delay = _arg1.delay, n = _arg1.n, cb = _arg1.cb, what = _arg1.what, progress_hook = _arg1.progress_hook;
  i = 0;
  left = 0;
  total_words = Math.ceil(n_input_bytes / 4);
  delay || (delay = default_delay);
  n || (n = default_n);
  call_ph = function(i) {
    return typeof progress_hook === &#x22;function&#x22; ? progress_hook({
      what: what,
      i: i,
      total: total_words
    }) : void 0;
  };
  call_ph(0);
  (function(_this) {
    return (function(__iced_k) {
      var _while;
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = __iced_k;
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = _continue;
        if (!((left = total_words - i) &#x3e; 0)) {
          return _break();
        } else {
          n_words = Math.min(n, left);
          update(i, i + n_words);
          call_ph(i);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: &#x22;/Users/max/src/keybase/triplesec/src/util.iced&#x22;,
              funcname: &#x22;bulk&#x22;
            });
            delay(i, total_words, __iced_deferrals.defer({
              lineno: 105
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(i += n_words);
          });
        }
      };
      _while(__iced_k);
    });
  })(this)((function(_this) {
    return function() {
      call_ph(total_words);
      ret = finalize();
      return cb(ret);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.copy_buffer" id="apidoc.element.kbpgp.triplesec.util.copy_buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>copy_buffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_buffer = function (b) {
  var i, ret, _i, _ref;
  ret = new Buffer(b.length);
  for (i = _i = 0, _ref = b.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    ret.writeUInt8(b.readUInt8(i), i);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.default_delay" id="apidoc.element.kbpgp.triplesec.util.default_delay">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>default_delay
        <span class="apidocSignatureSpan">(i, n, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default_delay = function (i, n, cb) {
  var ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  (function(_this) {
    return (function(__iced_k) {
      if (typeof setImmediate !== &#x22;undefined&#x22; &#x26;&#x26; setImmediate !== null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/util.iced&#x22;
          });
          setImmediate(__iced_deferrals.defer({
            lineno: 45
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/triplesec/src/util.iced&#x22;
          });
          setTimeout(__iced_deferrals.defer({
            lineno: 47
          }), 1);
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb();
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.fixup_uint32" id="apidoc.element.kbpgp.triplesec.util.fixup_uint32">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>fixup_uint32
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixup_uint32 = function (x) {
  var ret, x_pos;
  ret = x &#x3e; uint_max || x &#x3c; 0 ? (x_pos = Math.abs(x) % uint_max, x &#x3c; 0 ? uint_max - x_pos : x_pos) : x;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.scrub_buffer" id="apidoc.element.kbpgp.triplesec.util.scrub_buffer">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>scrub_buffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub_buffer = function (b) {
  var i, n_full_words;
  n_full_words = b.length &#x3e;&#x3e; 2;
  i = 0;
  while (i &#x3c; n_full_words) {
    b.writeUInt32LE(0, i);
    i += 4;
  }
  while (i &#x3c; b.length) {
    b.writeUInt8(0, i);
    i++;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.triplesec.util.scrub_vec" id="apidoc.element.kbpgp.triplesec.util.scrub_vec">
        function <span class="apidocSignatureSpan">kbpgp.triplesec.util.</span>scrub_vec
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrub_vec = function (v) {
  var i, _i, _ref;
  for (i = _i = 0, _ref = v.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    v[i] = 0;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.ukm" id="apidoc.module.kbpgp.ukm">module kbpgp.ukm</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.ukm.decode_sig" id="apidoc.element.kbpgp.ukm.decode_sig">
        function <span class="apidocSignatureSpan">kbpgp.ukm.</span>decode_sig
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode_sig = function (_arg) {
  var armored;
  armored = _arg.armored;
  if (is_pgp_sig(armored)) {
    return pgp_sig.decode_sig({
      armored: armored
    });
  } else {
    return kb.decode_sig({
      armored: armored
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ukm.get_sig_body" id="apidoc.element.kbpgp.ukm.get_sig_body">
        function <span class="apidocSignatureSpan">kbpgp.ukm.</span>get_sig_body
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_sig_body = function (_arg) {
  var armored;
  armored = _arg.armored;
  if (is_pgp_sig(armored)) {
    return pgp_sig.get_sig_body({
      armored: armored
    });
  } else {
    return kb.get_sig_body({
      armored: armored
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.ukm.import_armored_public" id="apidoc.element.kbpgp.ukm.import_armored_public">
        function <span class="apidocSignatureSpan">kbpgp.ukm.</span>import_armored_public
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import_armored_public = function (_arg, cb) {
  var armored, asp, err, opts, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  armored = _arg.armored, asp = _arg.asp, opts = _arg.opts;
  warnings = null;
  (function(_this) {
    return (function(__iced_k) {
      if (armored.match(/^-{5}BEGIN PGP PUBLIC KEY BLOCK-{5}/)) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/ukm.iced&#x22;,
            funcname: &#x22;import_armored_public&#x22;
          });
          pgp.KeyManager.import_from_armored_pgp({
            armored: armored,
            asp: asp,
            opts: opts
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                ret = arguments[1];
                return warnings = arguments[2];
              };
            })(),
            lineno: 12
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/ukm.iced&#x22;,
            funcname: &#x22;import_armored_public&#x22;
          });
          kb.KeyManager.import_public({
            hex: armored
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return ret = arguments[1];
              };
            })(),
            lineno: 14
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    });
  })(this)((function(_this) {
    return function() {
      return cb(err, ret, warnings);
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.util" id="apidoc.module.kbpgp.util">module kbpgp.util</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.util.ASP" id="apidoc.element.kbpgp.util.ASP">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>ASP
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ASP(_arg) {
  var canceler, delay, progress_hook;
  progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;
  this._delay = delay != null ? delay : 2;
  this._canceler = canceler || (new Canceler());
  this._progress_hook = progress_hook || (function(obj) {});
  this._section = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.Warnings" id="apidoc.element.kbpgp.util.Warnings">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>Warnings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Warnings() {
  this._w = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.akatch" id="apidoc.element.kbpgp.util.akatch">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>akatch
        <span class="apidocSignatureSpan">(fn, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">akatch = function (fn, cb) {
  return asyncify(katch(fn), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.assert_no_nulls" id="apidoc.element.kbpgp.util.assert_no_nulls">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>assert_no_nulls
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert_no_nulls = function (v) {
  var e, ok, _i, _len;
  ok = true;
  for (_i = 0, _len = v.length; _i &#x3c; _len; _i++) {
    e = v[_i];
    if (e == null) {
      ok = false;
    }
  }
  if (!ok) {
    console.error(&#x22;Found 1 or more nulls in vector: &#x22;);
    console.error(v);
    return assert(false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.asyncify" id="apidoc.element.kbpgp.util.asyncify">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>asyncify
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asyncify = function (args, cb) {
  return cb.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.athrow" id="apidoc.element.kbpgp.util.athrow">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>athrow
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">athrow = function (err, cb) {
  return cb(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.bufeq_fast" id="apidoc.element.kbpgp.util.bufeq_fast">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>bufeq_fast
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufeq_fast = function (x, y) {
  var i, _i, _ref;
  if ((x == null) &#x26;&#x26; (y == null)) {
    return true;
  }
  if ((x == null) || (y == null)) {
    return false;
  }
  if (x.length !== y.length) {
    return false;
  }
  for (i = _i = 0, _ref = x.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    if (x.readUInt8(i) !== y.readUInt8(i)) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.bufeq_secure" id="apidoc.element.kbpgp.util.bufeq_secure">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>bufeq_secure
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufeq_secure = function (x, y) {
  var check, i, ret;
  ret = (function() {
    var _i, _ref;
    if ((x == null) &#x26;&#x26; (y == null)) {
      return true;
    } else if ((x == null) || (y == null)) {
      return false;
    } else if (x.length !== y.length) {
      return false;
    } else {
      check = 0;
      for (i = _i = 0, _ref = x.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
        check |= x.readUInt8(i) ^ y.readUInt8(i);
      }
      return check === 0;
    }
  })();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Pub._alloc = function(raw) {
var expected, key, l, len, mpi_length_headers, oid, pre, pub, sb;
sb = new SlicerBuffer(raw);
pre = sb.rem();
l = sb.read_uint8();
oid = sb.read_buffer(l);
expected = Pub.OID;
if (!util.<span class="apidocCodeKeywordSpan">bufeq_secure</span>(oid, expected)) {
  throw new Error(&#x22;Wrong OID in EdDSA key&#x22;);
}
mpi_length_headers = sb.read_buffer(Pub.MPI_LENGTH_HEADERS.length);
if (!util.bufeq_secure(mpi_length_headers, Pub.MPI_LENGTH_HEADERS)) {
  throw new Error(&#x22;Wrong MPI length headers&#x22;);
}
key = sb.read_buffer(kbnacl.sign.publicKeyLength);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.buffer_to_ui8a" id="apidoc.element.kbpgp.util.buffer_to_ui8a">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>buffer_to_ui8a
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer_to_ui8a = function (b) {
  var i, l, ret, _i;
  l = b.length;
  ret = new Uint8Array(l);
  for (i = _i = 0; 0 &#x3c;= l ? _i &#x3c; l : _i &#x3e; l; i = 0 &#x3c;= l ? ++_i : --_i) {
    ret[i] = b.readUInt8(i);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.bufferify" id="apidoc.element.kbpgp.util.bufferify">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>bufferify
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferify = function (s) {
  if (Buffer.isBuffer(s)) {
    return s;
  } else if (typeof s === &#x27;string&#x27;) {
    return new Buffer(s, &#x27;utf8&#x27;);
  } else {
    throw new Error(&#x22;Cannot convert to buffer: &#x22; + s);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.bufxor" id="apidoc.element.kbpgp.util.bufxor">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>bufxor
        <span class="apidocSignatureSpan">(b1, b2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufxor = function (b1, b2) {
  var arr, c, i;
  arr = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = b1.length; _i &#x3c; _len; i = ++_i) {
      c = b1[i];
      _results.push(c ^ b2[i]);
    }
    return _results;
  })();
  return new Buffer(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.calc_checksum" id="apidoc.element.kbpgp.util.calc_checksum">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>calc_checksum
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calc_checksum = function (text) {
  var i, ret, _i, _ref;
  ret = 0;
  for (i = _i = 0, _ref = text.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; i = 0 &#x3c;= _ref ? ++_i : --_i) {
    ret = (ret + text.readUInt8(i)) % 65536;
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.encode_length" id="apidoc.element.kbpgp.util.encode_length">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>encode_length
        <span class="apidocSignatureSpan">(l, five_byte)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode_length = function (l, five_byte) {
  var ret;
  if (five_byte == null) {
    five_byte = false;
  }
  ret = null;
  if (l &#x3e;= 8384 || five_byte) {
    ret = new Buffer(5);
    ret.writeUInt8(0xff, 0);
    ret.writeUInt32BE(l, 1);
  } else if (l &#x3c; 192) {
    ret = new Buffer(1);
    ret.writeUInt8(l, 0);
  } else if (l &#x3e;= 192 &#x26;&#x26; l &#x3c; 8384) {
    ret = new Buffer(2);
    ret.writeUInt16BE((l - 192) + (192 &#x3c;&#x3c; 8), 0);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.fingerprint_to_key_id_64" id="apidoc.element.kbpgp.util.fingerprint_to_key_id_64">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>fingerprint_to_key_id_64
        <span class="apidocSignatureSpan">(fp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fingerprint_to_key_id_64 = function (fp) {
  return fp.slice(-16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.fit_to_size" id="apidoc.element.kbpgp.util.fit_to_size">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>fit_to_size
        <span class="apidocSignatureSpan">(size, buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fit_to_size = function (size, buf) {
  var i, l;
  l = size - buf.length;
  if (l === 0) {
    return buf;
  } else if (l &#x3e; 0) {
    return Buffer.concat([
      buf, new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 &#x3c;= l ? _i &#x3c;= l : _i &#x3e;= l; i = 1 &#x3c;= l ? ++_i : --_i) {
          _results.push(0x00);
        }
        return _results;
      })())
    ]);
  } else if (l &#x3c; 0) {
    return buf.slice(-size);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Pub.prototype.verify = function(_arg, payload, cb) {
  var err, naclw, r, s, sig, _, _ref1;
  r = _arg[0], s = _arg[1];
  naclw = kbnacl.alloc({
    publicKey: this.key
  });
  sig = util.<span class="apidocCodeKeywordSpan">fit_to_size</span>(kbnacl.sign.signatureLength, Buffer.concat([r, s]));
  _ref1 = naclw.verify({
    payload: payload,
    sig: sig,
    detached: true
  }), err = _ref1[0], _ = _ref1[1];
  return cb(err);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.format_fingerprint" id="apidoc.element.kbpgp.util.format_fingerprint">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>format_fingerprint
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format_fingerprint = function (raw) {
  var hex, i, parts;
  hex = raw.toString(&#x27;hex&#x27;).toUpperCase();
  parts = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = hex.length; _i &#x3c; _ref; i = _i += 4) {
      _results.push(hex.slice(i, i + 4));
    }
    return _results;
  })();
  return parts.join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.format_pgp_fingerprint_2" id="apidoc.element.kbpgp.util.format_pgp_fingerprint_2">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>format_pgp_fingerprint_2
        <span class="apidocSignatureSpan">(buf, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format_pgp_fingerprint_2 = function (buf, opts) {
  var hex, i, length, parts, spc;
  if (opts == null) {
    opts = {};
  }
  hex = buf.toString(&#x27;hex&#x27;);
  length = (opts != null ? opts.length : void 0) || 40;
  spc = (opts != null ? opts.space : void 0) || &#x27; &#x27;;
  hex = hex.toUpperCase().slice(-length);
  if (hex.length === 40) {
    parts = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = hex.length; _i &#x3c; _ref; i = _i += 4) {
        _results.push(hex.slice(i, i + 4));
      }
      return _results;
    })();
    parts = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = parts.length; _i &#x3c; _ref; i = _i += 5) {
        _results.push(parts.slice(i, i + 5).join(spc));
      }
      return _results;
    })();
    return parts.join(spc + spc);
  } else if (hex.length &#x3e; 8) {
    parts = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = hex.length; _i &#x3c; _ref; i = _i += 4) {
        _results.push(hex.slice(i, i + 4));
      }
      return _results;
    })();
    return parts.join(spc);
  } else {
    return hex;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.fpeq" id="apidoc.element.kbpgp.util.fpeq">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>fpeq
        <span class="apidocSignatureSpan">(fp1, fp2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fpeq = function (fp1, fp2) {
  return strip(fp1).toLowerCase() === strip(fp2).toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.genseed" id="apidoc.element.kbpgp.util.genseed">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>genseed
        <span class="apidocSignatureSpan">(_arg, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genseed = function (_arg, cb) {
  var err, len, rseed, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;
  __iced_k = __iced_k_noop;
  ___iced_passed_deferral = iced.findDeferral(arguments);
  seed = _arg.seed, split = _arg.split, len = _arg.len, server_half = _arg.server_half;
  err = rseed = null;
  if (server_half == null) {
    server_half = null;
  }
  (function(_this) {
    return (function(__iced_k) {
      if ((seed == null) || (split &#x26;&#x26; (server_half == null))) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: &#x22;/Users/max/src/keybase/kbpgp/src/keybase/util.iced&#x22;
          });
          SRF().random_bytes(len, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return rseed = arguments[0];
              };
            })(),
            lineno: 16
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    });
  })(this)((function(_this) {
    return function() {
      if ((seed != null) &#x26;&#x26; seed.length !== len) {
        err = new Error(&#x22;Wrong seed length; need &#x22; + len + &#x22; bytes; got &#x22; + seed.length);
      } else if ((seed != null) &#x26;&#x26; (rseed != null)) {
        server_half = rseed;
        seed = bufxor(seed, rseed);
      } else if ((seed != null) &#x26;&#x26; (server_half != null)) {
        seed = bufxor(seed, server_half);
      } else if (seed == null) {
        seed = rseed;
      }
      return cb(err, {
        seed: seed,
        server_half: server_half
      });
    };
  })(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.json_stringify_sorted" id="apidoc.element.kbpgp.util.json_stringify_sorted">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>json_stringify_sorted
        <span class="apidocSignatureSpan">(o, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json_stringify_sorted = function (o, opts) {
  var i, json_safe, lb, o2, sort_fn, space_it, spaces, str;
  opts = opts || {};
  sort_fn = opts.sort_fn || null;
  spaces = opts.spaces || null;
  lb = opts.spaces != null ? &#x22;\n&#x22; : &#x22;&#x22;;
  if ((typeof spaces) === &#x22;number&#x22;) {
    spaces = ((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 &#x3c;= spaces ? _i &#x3c; spaces : _i &#x3e; spaces; i = 0 &#x3c;= spaces ? ++_i : --_i) {
        _results.push(&#x22; &#x22;);
      }
      return _results;
    })()).join(&#x22;&#x22;);
  }
  space_it = function(depth) {
    if (spaces == null) {
      return &#x22;&#x22;;
    }
    return &#x22;\n&#x22; + ((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 &#x3c;= depth ? _i &#x3c; depth : _i &#x3e; depth; i = 0 &#x3c;= depth ? ++_i : --_i) {
        _results.push(spaces);
      }
      return _results;
    })()).join(&#x22;&#x22;);
  };
  json_safe = function(os, depth) {
    var k, keys, s, sp, spp, v;
    if (Array.isArray(os)) {
      s = &#x22;[&#x22; + ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = os.length; _i &#x3c; _len; _i++) {
          v = os[_i];
          _results.push(json_safe(v, depth + 1));
        }
        return _results;
      })()).join(&#x27;,&#x27;) + &#x22;]&#x22;;
    } else if ((typeof os) === &#x22;object&#x22;) {
      if (!os) {
        s = JSON.stringify(os);
      } else {
        sp = space_it(depth);
        spp = space_it(depth + 1);
        keys = (function() {
          var _results;
          _results = [];
          for (k in os) {
            _results.push(k);
          }
          return _results;
        })();
        if (sort_fn) {
          keys.sort(sort_fn);
        } else {
          keys.sort();
        }
        s = &#x22;{&#x22; + ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = keys.length; _i &#x3c; _len; _i++) {
            k = keys[_i];
            _results.push(spp + JSON.stringify(k) + &#x22;:&#x22; + json_safe(os[k], depth + 1));
          }
          return _results;
        })()).join(&#x27;,&#x27;) + sp + &#x22;}&#x22;;
      }
    } else {
      s = JSON.stringify(os);
    }
    return s;
  };
  str = JSON.stringify(o);
  if (str === void 0) {
    return str;
  } else {
    o2 = JSON.parse(str);
    return json_safe(o2, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.katch" id="apidoc.element.kbpgp.util.katch">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>katch
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">katch = function (fn) {
  var e, err, ret;
  ret = err = null;
  try {
    ret = fn();
  } catch (_error) {
    e = _error;
    err = e;
  }
  return [err, ret];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.make_time_packet" id="apidoc.element.kbpgp.util.make_time_packet">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>make_time_packet
        <span class="apidocSignatureSpan">(d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make_time_packet = function (d) {
  var b;
  d || (d = Math.floor(Date.now() / 1000));
  b = new Buffer(4);
  b.writeUInt32BE(d, 0);
  return b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.obj_extract" id="apidoc.element.kbpgp.util.obj_extract">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>obj_extract
        <span class="apidocSignatureSpan">(o, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">obj_extract = function (o, keys) {
  var k, ret, _i, _len;
  ret = {};
  for (_i = 0, _len = keys.length; _i &#x3c; _len; _i++) {
    k = keys[_i];
    ret[k] = o[k];
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.ops_to_keyflags" id="apidoc.element.kbpgp.util.ops_to_keyflags">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>ops_to_keyflags
        <span class="apidocSignatureSpan">(ops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ops_to_keyflags = function (ops) {
  var out;
  out = 0;
  if (ops &#x26; C.ops.encrypt) {
    out |= C.openpgp.key_flags.encrypt_comm;
  }
  if (ops &#x26; C.ops.decrypt) {
    out |= C.openpgp.key_flags.encrypt_comm;
  }
  if (ops &#x26; C.ops.verify) {
    out |= C.openpgp.key_flags.sign_data;
  }
  if (ops &#x26; C.ops.sign) {
    out |= C.openpgp.key_flags.sign_data;
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.streq_secure" id="apidoc.element.kbpgp.util.streq_secure">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>streq_secure
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streq_secure = function (x, y) {
  var B;
  B = function(x) {
    if (x != null) {
      return bufferify(x);
    } else {
      return null;
    }
  };
  return bufeq_secure(B(x), B(y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.strip" id="apidoc.element.kbpgp.util.strip">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>strip
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strip = function (x) {
  return x.split(/\s+/).join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.trim" id="apidoc.element.kbpgp.util.trim">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>trim
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trim = function (x) {
  var m;
  if ((m = x != null ? x.match(/^\s+(.*?)$/) : void 0)) {
    x = m[1];
  }
  if ((m = x != null ? x.match(/^(.*?)\s+$/) : void 0)) {
    x = m[1];
  }
  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  return cb(null);
};

Verifier.prototype._make_hasher = function(cb) {
  var err, h;
  err = null;
  h = (this.clearsign.headers.hash || &#x27;MD5&#x27;).<span class="apidocCodeKeywordSpan">trim</span>();
  if ((this._sig.hasher = hashmod[h]) == null) {
    err = new Error(&#x22;Unknown hash algorithm: &#x22; + h);
  }
  return cb(err);
};

Verifier.prototype._verify = function(cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.ui32a_to_ui8a" id="apidoc.element.kbpgp.util.ui32a_to_ui8a">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>ui32a_to_ui8a
        <span class="apidocSignatureSpan">(v, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ui32a_to_ui8a = function (v, out) {
  var k, w, _i, _len;
  if (out == null) {
    out = null;
  }
  out || (out = new Uint8Array(v.length * 4));
  k = 0;
  for (_i = 0, _len = v.length; _i &#x3c; _len; _i++) {
    w = v[_i];
    out[k++] = (w &#x3e;&#x3e; 24) &#x26; 0xff;
    out[k++] = (w &#x3e;&#x3e; 16) &#x26; 0xff;
    out[k++] = (w &#x3e;&#x3e; 8) &#x26; 0xff;
    out[k++] = w &#x26; 0xff;
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.ui8a_to_ui32a" id="apidoc.element.kbpgp.util.ui8a_to_ui32a">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>ui8a_to_ui32a
        <span class="apidocSignatureSpan">(v, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ui8a_to_ui32a = function (v, out) {
  var b, i, k, tmp, _i, _len;
  if (out == null) {
    out = null;
  }
  out || (out = new Uint32Array(v.length &#x3e;&#x3e; 2));
  k = 0;
  for (i = _i = 0, _len = v.length; _i &#x3c; _len; i = _i += 4) {
    b = v[i];
    tmp = (b &#x3c;&#x3c; 24) + (v[i + 1] &#x3c;&#x3c; 16) + (v[i + 2] &#x3c;&#x3c; 8) + v[i + 3];
    out[k++] = tmp;
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.uint_to_buffer" id="apidoc.element.kbpgp.util.uint_to_buffer">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>uint_to_buffer
        <span class="apidocSignatureSpan">(nbits, i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uint_to_buffer = function (nbits, i) {
  var ret;
  ret = null;
  switch (nbits) {
    case 16:
      ret = new Buffer(2);
      ret.writeUInt16BE(i, 0);
      break;
    case 32:
      ret = new Buffer(4);
      ret.writeUInt32BE(i, 0);
      break;
    case 8:
      ret = new Buffer(1);
      ret.writeUInt8(i, 0);
      break;
    default:
      throw new Error(&#x22;Bit types not found: &#x22; + nbit);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.unix_time" id="apidoc.element.kbpgp.util.unix_time">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>unix_time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unix_time = function () {
  return Math.floor(Date.now() / 1000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.xxd" id="apidoc.element.kbpgp.util.xxd">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>xxd
        <span class="apidocSignatureSpan">(buf, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xxd = function (buf, opts) {
  var i, line, lines, p, pad, q, quartets, v;
  if (opts == null) {
    opts = {};
  }
  q = opts.q || 8;
  p = opts.p || 7;
  buf = buf.toString(&#x27;hex&#x27;);
  quartets = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = buf.length; _i &#x3c; _ref; i = _i += 4) {
      _results.push(buf.slice(i, i + 4));
    }
    return _results;
  })();
  lines = (function() {
    var _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = quartets.length; q &#x3e; 0 ? _i &#x3c; _ref : _i &#x3e; _ref; i = _i += q) {
      _results.push(quartets.slice(i, i + q).join(&#x27; &#x27;));
    }
    return _results;
  })();
  pad = function(s, n) {
    return ((function() {
      var _i, _ref, _results;
      _results = [];
      for (_i = 0, _ref = n - s.length; 0 &#x3c;= _ref ? _i &#x3c; _ref : _i &#x3e; _ref; 0 &#x3c;= _ref ? _i++ : _i--) {
        _results.push(&#x27;0&#x27;);
      }
      return _results;
    })()).join(&#x27;&#x27;) + s;
  };
  v = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i &#x3c; _len; i = ++_i) {
      line = lines[i];
      _results.push(pad((i * 2 * q).toString(16), p) + &#x22;: &#x22; + line);
    }
    return _results;
  })();
  return v.join(&#x22;\n&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.util.Warnings" id="apidoc.module.kbpgp.util.Warnings">module kbpgp.util.Warnings</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.util.Warnings.Warnings" id="apidoc.element.kbpgp.util.Warnings.Warnings">
        function <span class="apidocSignatureSpan">kbpgp.util.</span>Warnings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Warnings() {
  this._w = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.util.Warnings.prototype" id="apidoc.module.kbpgp.util.Warnings.prototype">module kbpgp.util.Warnings.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.util.Warnings.prototype.push" id="apidoc.element.kbpgp.util.Warnings.prototype.push">
        function <span class="apidocSignatureSpan">kbpgp.util.Warnings.prototype.</span>push
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function () {
  var args, _ref;
  args = 1 &#x3c;= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref = this._w).push.apply(_ref, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var e;
  return Buffer.concat((function() {
    var _i, _len, _ref1, _results;
    _ref1 = this.ORDER;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
      e = _ref1[_i];
      _results.<span class="apidocCodeKeywordSpan">push</span>(this[e].to_mpi_buffer());
    }
    return _results;
  }).call(this));
};

BaseKey.prototype.validity_check = function(cb) {
  return cb(null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.Warnings.prototype.warnings" id="apidoc.element.kbpgp.util.Warnings.prototype.warnings">
        function <span class="apidocSignatureSpan">kbpgp.util.Warnings.prototype.</span>warnings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warnings = function () {
  return this._w;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.util.base64u" id="apidoc.module.kbpgp.util.base64u">module kbpgp.util.base64u</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.util.base64u.decode" id="apidoc.element.kbpgp.util.base64u.decode">
        function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>decode
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (b) {
  b = (b + Array(5 - b.length % 4).join(&#x27;=&#x27;)).replace(/\-/g, &#x27;+&#x27;).replace(/\_/g, &#x27;/&#x27;);
  return new Buffer(b, &#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          if (typeof msg === &#x27;string&#x27;) {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced&#x22;,
    funcname: &#x22;SignatureEngine.unbox&#x22;
  });
  _this.<span class="apidocCodeKeywordSpan">decode</span>(msg, esc(__iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        return msg = arguments[0];
      };
    })(),
    lineno: 72
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.base64u.encode" id="apidoc.element.kbpgp.util.base64u.encode">
        function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>encode
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (b) {
  return b.toString(&#x27;base64&#x27;).replace(/\+/g, &#x27;-&#x27;).replace(/\//g, &#x27;_&#x27;).replace(/=+$/, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
KeyManager.prototype.get_all_pgp_key_ids = function() {
  return this.pgp.get_all_key_ids();
};

KeyManager.prototype.get_ekid_b64_str = function() {
  var k;
  if ((k = this.get_ekid()) != null) {
    return base64u.<span class="apidocCodeKeywordSpan">encode</span>(k);
  } else {
    return null;
  }
};

KeyManager.prototype.get_fp2 = function() {
  return this.get_pgp_fingerprint();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kbpgp.util.base64u.verify" id="apidoc.element.kbpgp.util.base64u.verify">
        function <span class="apidocSignatureSpan">kbpgp.util.base64u.</span>verify
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (b) {
  return /^[A-Za-z0-9\-_]+$/.test(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
(function(__iced_k) {
  __iced_deferrals = new iced.Deferrals(__iced_k, {
    parent: ___iced_passed_deferral,
    filename: &#x22;/Users/max/src/keybase/kbpgp/src/basekeypair.iced&#x22;,
    funcname: &#x22;BaseKeyPair._dsa_verify_update_and_check_hash&#x22;
  });
  _this.pub.<span class="apidocCodeKeywordSpan">verify</span>(sig, hash, __iced_deferrals.defer({
    assign_fn: (function() {
      return function() {
        err = arguments[0];
        return v = arguments[1];
      };
    })(),
    lineno: 148
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kbpgp.verifier" id="apidoc.module.kbpgp.verifier">module kbpgp.verifier</a></h1>


    <h2>
        <a href="#apidoc.element.kbpgp.verifier.Base" id="apidoc.element.kbpgp.verifier.Base">
        function <span class="apidocSignatureSpan">kbpgp.verifier.</span>Base
        <span class="apidocSignatureSpan">(_arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Base(_arg) {
  this.packets = _arg.packets, this.keyfetch = _arg.keyfetch;
  this._sig = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
